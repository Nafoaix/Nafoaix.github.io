<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>STM32使用DWT实现微秒延时</title>
      <link href="/archives/96aa65ec.html"/>
      <url>/archives/96aa65ec.html</url>
      
        <content type="html"><![CDATA[<h2 id="STM32使用DWT实现微秒延时"><a href="#STM32使用DWT实现微秒延时" class="headerlink" title="STM32使用DWT实现微秒延时"></a>STM32使用DWT实现微秒延时</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;在使用Cortex-M内核单片机开发驱动时总是需要延时函数做超时判断，这时想实现微秒级延时，不想让CPU干等时间，又不想浪费硬件定时器资源，这时候可以使用<code>DWT(Data Watchpoint and Trace )数据观察点与跟踪组件</code>来实现延时功能。</p><h3 id="DWT数据观察点与跟踪组件介绍"><a href="#DWT数据观察点与跟踪组件介绍" class="headerlink" title="DWT数据观察点与跟踪组件介绍"></a>DWT数据观察点与跟踪组件介绍</h3><p>&emsp;&emsp;DWT挂载在AHB私有外设总线上，是一个处理数据观察点功能的模块。通过 DWT，可以设置数据观察点。当一个数据地址或数据的值匹配了观察点时，就说产生了一次匹配命中事件。匹配命中事件可以用于产生一个观察点事件，后者能激活调试器以产生数据跟踪信息，或者让 ETM 联动以跟踪在哪条指令上发生了匹配命中事件。作为调试功能这里就不过多展开了，可以去查看Cortex-M3 权威指南中内容，下面讲解以下DWT有关的寄存器。</p><h3 id="相关的DWT寄存器"><a href="#相关的DWT寄存器" class="headerlink" title="相关的DWT寄存器"></a>相关的DWT寄存器</h3><p>&emsp;&emsp; 要实现延时的功能，总共涉及到三个寄存器：DEMCR、DWT_CTRL、DWT_CYCCNT，分别用于开启DWT功能、开启CYCCNT及获得系统时钟计数值。</p><h4 id="DEM-CR寄存器"><a href="#DEM-CR寄存器" class="headerlink" title="DEM_CR寄存器"></a>DEM_CR寄存器</h4><p><img src="https://cdn.nafx.top/post_cover/20240322230442.png" alt="DEMCR寄存器"></p><p>&emsp;&emsp;DEM_CR寄存器<code>地址:0xE000EDFC</code>不仅包含了调试监视器的控制位，还包含了跟踪系统的使能位（TRCENA）以及若干向量抓捕（Vector Catch, VC）控制位。这里用到的是DEMCR寄存器的第24位TRCENA<code>DEMCR  |=  1 &lt;&lt; 24 </code>来使能DWT，这里需要注意的是DEMCR中的控制位是在上电复位时得到复位的。系统复位（例如，往 NVIC 应用程序中断及复位寄存器中写命令）不会影响到它们，在调试相关功能时推荐关掉下载器调试器的自动复位运行功能手动复位。</p><h4 id="DWT-CR寄存器"><a href="#DWT-CR寄存器" class="headerlink" title="DWT_CR寄存器"></a>DWT_CR寄存器</h4><p><img src="https://cdn.nafx.top/post_cover/20240323000833.png" alt="DWT_CR寄存器1"><br><img src="https://cdn.nafx.top/post_cover/20240323000952.png" alt="DWT_CR寄存器2"></p><p>&emsp;&emsp;DWT_CR寄存器<code>地址:0xE0001000</code>的第1位CYCCNTENA<code>DWTCR |= 1 &lt;&lt; 0</code>是CYCCNT计数器的使能开关，写1使能否则CYCCNT计数器将不会工作。</p><h4 id="DWT-CYCCNT寄存器"><a href="#DWT-CYCCNT寄存器" class="headerlink" title="DWT_CYCCNT寄存器"></a>DWT_CYCCNT寄存器</h4><p><img src="https://cdn.nafx.top/post_cover/DWT_CYCCNT.png" alt="DWT_CYCCNT寄存器"></p><p>&emsp;&emsp;DWT_CYCCNT寄存器<code>地址:0xE0001004</code> DWT周期计数器寄存器是一个32位向上的计数器，，用于记录处理器时钟的周期数，内核时钟跳动一次，该计数器就加1，当CYCCNT溢出之后，会清0重新开始向上计数，通过读取该寄存器的值，可以实现精确的计时功能。<br>&emsp;&emsp;例如F103系列，内核时钟是72M，那精度就是1/72M = 14ns，而程序的运行时间都是微秒级别的，所以14ns的精度是远远够的。 最长能记录的时间为：60s=2的32次方/72000000， 而如果是H7这种400M主频的芯片，那它的计时精度高达2.5ns（1/400000000 = 2.5），而如果是 i.MX RT1052这种高速的处理器， 最长能记录的时间为： 8.13s=2的32次方/528000000 (假设内核频率为528M，内核跳一次的时间大概为1/528M=1.9ns) 。</p><h3 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h3><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><ol><li>先使能DWT外设，这个由另外内核调试寄存器DEM_CR的位24控制，写1使能。</li><li>使能CYCCNT寄存器之前，先清0。</li><li>使能DWT_CYCCNT寄存器，这个由DWT_CR的CYCCNTENA控制，也就是DWT控制寄存器的位0控制，写1使能。</li></ol><h4 id="头文件-dwt-stm32-delay-h"><a href="#头文件-dwt-stm32-delay-h" class="headerlink" title="头文件 dwt_stm32_delay.h"></a>头文件 dwt_stm32_delay.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DWT_STM32_DELAY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DWT_STM32_DELAY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使能DEMCR寄存器的DWT使能位 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  DEM_CR      *(volatile u32 *)0xE000EDFC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  DEM_CR_TRCENA                   (0x01 &lt;&lt; 24) <span class="comment">//0x01000000</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使能DWT_CR寄存器的CYCCNT使能位 CYCCNT计数器开始计数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  DWT_CR      *(volatile u32 *)0xE0001000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  DWT_CR_CYCCNTENA                (0x01 &lt;&lt;  0) <span class="comment">//0x00000001</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//0xE0001004 DWT_CYCCNT RW Cycle Count register,   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  DWT_CYCCNT  *(volatile u32 *)0xE0001004</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  Initializes DWT_Cycle_Count for DWT_Delay_us function</span></span><br><span class="line"><span class="comment"> * @return Error DWT counter</span></span><br><span class="line"><span class="comment"> *         1: DWT counter Error</span></span><br><span class="line"><span class="comment"> *         0: DWT counter works</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">DWT_Delay_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DWT_Delay_us</span><span class="params">(<span class="keyword">uint32_t</span> _ulDelayTime)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DWT_Delay_ms</span><span class="params">(<span class="keyword">uint32_t</span> _ulDelayTime)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="dwt-stm32-delay-c文件"><a href="#dwt-stm32-delay-c文件" class="headerlink" title="dwt_stm32_delay.c文件"></a>dwt_stm32_delay.c文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dwt_stm32_delay.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  Initializes DWT_Clock_Cycle_Count for DWT_Delay_us function</span></span><br><span class="line"><span class="comment"> * @retval Error DWT counter</span></span><br><span class="line"><span class="comment"> *         1: clock cycle counter not started</span></span><br><span class="line"><span class="comment"> *         0: clock cycle counter works</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">DWT_Delay_Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DEM_CR  &amp;= ~DEM_CR_TRCENA;  <span class="comment">/* Disable TRCENA ~0x01000000 */</span> </span><br><span class="line">    DEM_CR  |=  DEM_CR_TRCENA; <span class="comment">/*对DEMCR寄存器的位24控制，写1使能DWT外设。0x01000000 */</span></span><br><span class="line">    DWT_CR  &amp;= ~DWT_CR_CYCCNTENA; <span class="comment">/* Disable clock cycle counter ~0x00000001 */</span></span><br><span class="line">    DWT_CR  |=  DWT_CR_CYCCNTENA;<span class="comment">/*对DWT控制寄存器的位0控制，写1使能CYCCNT寄存器。0x00000001 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reset the clock cycle counter value */</span></span><br><span class="line">    DWT_CYCCNT = <span class="number">0</span>;<span class="comment">/*对于DWT的CYCCNT计数寄存器清0。*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3 NO OPERATION instructions */</span></span><br><span class="line">    <span class="function">__ASM <span class="title">volatile</span> <span class="params">(<span class="string">&quot;NOP&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">__ASM <span class="title">volatile</span> <span class="params">(<span class="string">&quot;NOP&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">__ASM <span class="title">volatile</span> <span class="params">(<span class="string">&quot;NOP&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">/* Check if clock cycle counter has started */</span></span><br><span class="line">     <span class="keyword">if</span>(DWT_CYCCNT)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/*clock cycle counter started*/</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/*clock cycle counter not started*/</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DWT_Delay_us</span><span class="params">(<span class="keyword">uint32_t</span> _ulDelayTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> tCnt, tDelayCnt;</span><br><span class="line">    <span class="keyword">uint32_t</span> tStart;</span><br><span class="line">           </span><br><span class="line">    tStart = DWT_CYCCNT; <span class="comment">/* 刚进入时的计数器值 */</span></span><br><span class="line">    tCnt = <span class="number">0</span>;</span><br><span class="line">    tDelayCnt = _ulDelayTime * (SystemCoreClock / <span class="number">1000000</span>);</span><br><span class="line">    <span class="comment">/* 需要的节拍数 */</span>    <span class="comment">/*SystemCoreClock :系统时钟频率*/</span>                 </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(tCnt &lt; tDelayCnt)</span><br><span class="line">      &#123;</span><br><span class="line">        tCnt = DWT_CYCCNT - tStart; </span><br><span class="line">        <span class="comment">/* 求减过程中，如果发生第一次32位计数器重新计数，依然可以正确计算 */</span>       </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DWT_Delay_ms</span><span class="params">(<span class="keyword">uint32_t</span> _ulDelayTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  DWT_Delay_us(<span class="number">1000</span>*_ulDelayTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="说在最后"><a href="#说在最后" class="headerlink" title="说在最后"></a>说在最后</h3><p>&emsp;&emsp; 在计算延时过程中并没有对溢出做太多特殊处理，因为对于延时时间超过最大延时时间的溢出在使用中基本不会遇到，另外是在使用了RTOS的系统中对于DWT_CYCCNT值的不确定性，DWT_CYCCNT &lt; tStart溢出的情况由于变量都是uint32_t类型，tCnt会变成一个巨大的无符号数直接结束延时；DWT_CYCCNT &gt; tStart 溢出的情况可能会增加延时时间，对延时准确性，安全性等有考量不建议使用。</p>]]></content>
      
      
      <categories>
          
          <category> 学记笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络体系结构（五）</title>
      <link href="/archives/a7e40751.html"/>
      <url>/archives/a7e40751.html</url>
      
        <content type="html"><![CDATA[<h2 id="运输层-（network-layer）"><a href="#运输层-（network-layer）" class="headerlink" title="运输层 （network layer）"></a>运输层 （network layer）</h2><p>&emsp;&emsp;</p>]]></content>
      
      
      <categories>
          
          <category> 学记笔记 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络体系结构（四）</title>
      <link href="/archives/c87ac216.html"/>
      <url>/archives/c87ac216.html</url>
      
        <content type="html"><![CDATA[<h2 id="网络层-（network-layer）"><a href="#网络层-（network-layer）" class="headerlink" title="网络层 （network layer）"></a>网络层 （network layer）</h2><p>&emsp;&emsp;由于早期电信网的成功经验，有些人认为应该让网络层像电信网一样，两台主机通信前先建立连接(虚电路 Virtual Circuit)，然后沿着已建立的连接发送分组，网络负责<code>可靠交付</code>。但因特网却提出一种新的设计思路，因为电信网的终端(话机)非常简单，没有差错处理能力，因此电信网必须提供可靠交付。但因特网的终端是具有差错处理能力的计算机，所以在网络层只向上提供<code>简单灵活的、无连接的、尽最大努力交付的数据报服务</code>。网络在发送分组时不需要先建立连接，每一个分组(IP数据报)独立发送，也不进行编号，网络层不提供服务质量的承诺，所传分组可能出错、丢失、重复、失序或者交付时限。由于传输网络不提供端到端二点可靠服务就使网络中的路由器可以做的比较简单，而且价格低廉，如果主机种的进程间通信需要可靠服务，就由运输层负责(包括差错控制、流量控制等)。使网络造价大大降低，运行方式灵活，可以适应多种应用。</p><h3 id="虚拟互联网络"><a href="#虚拟互联网络" class="headerlink" title="虚拟互联网络"></a>虚拟互联网络</h3><p>&emsp;&emsp;如果要把全世界范围内的网络都互连起来，并且能够互相通信，没有一种单一的网络能适应所有用户的需求，另外随着技术不断发展也会有新的网络技术产生，所以将网络互相连接在一起需要使用一些<code>中间设备</code>，中间设备又称为<code>中间系统</code>或<code>中继系统(relay)</code>。根据设备所在的层次，可以有以下五种中间设备:</p><ul><li>物理层中继系统：转发器(repeater 中继器)、集线器 HUB;</li><li>数据链路层中继系统：网桥或桥接器(bridge)、交换机(switch);</li><li>网络层中继系统：路由器(router);</li><li>网桥和路由器的混合物：桥路器(brouter)、三层交换机;</li><li>网络层以上的中继设备： 网关(gateway);用网关在应用层面连接两个不兼容的系统。</li></ul><p>当中继系统是转发器或网桥等数据链路层以下的设备时，一般不称之为网络互连，仅仅是把一个网络扩大了，而着仍然是一个网络(局域网)。由于历史原因，许多有关TCP/IP的文献将网络层使用的路由器称为网关。网络互连都是指用路由器进行<code>网络互连</code>和<code>路由选择</code>。</p><h4 id="IP网概念"><a href="#IP网概念" class="headerlink" title="IP网概念"></a>IP网概念</h4><p><img src="https://cdn.nafx.top/post_cover/20230303183550.png" alt="IP网概念"><br>上图表示有许多计算机网络通过路由器进行互连，由于参加互连的计算机网络都使用相同的<code>网际协议IP(Internet Protocol)</code>，因此可以把互连起来的计算机网络看成一个巨大的虚拟互联网络(internet)。围殴为虚拟互连网络也就是逻辑互连网络，他的意思是互连起来的各种物理网络的异构型贝莱是客观存在的，但是我们利用协议IP就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络。这种使用协议IP的虚拟互连网络可简称为<code>IP网</code>。</p><h3 id="网际协议-IP"><a href="#网际协议-IP" class="headerlink" title="网际协议 IP"></a>网际协议 IP</h3><p><img src="https://cdn.nafx.top/post_cover/20230303181021.png" alt="网际协议IP及其配套协议"><br>&emsp;&emsp;网际协议IP是TCP/IP体系种两个最主要的协议之一，也是最重要的因特网标准协议之一，与IP协议配套使用的还有四个协议：</p><ul><li>地址解析协议 ARP(Address Resolution Protocol)</li><li>反向地址转换协议 RARP(Reverse Address Resolution Protocol)</li><li>网际控制报文协议 ICMP(Internet Control Message Protocol)</li><li>网际组管理协议 IGMP(Internet Group Management Protocol)</li></ul><p>&emsp;&emsp;但反向地址转换协议 RARP现在已经淘汰不使用了，由于网际协议IP是用来使互联的许多计算机网络能够进行通信，因此TCP/IP体系中的网络层常常被称为<code>网际层(Internet layer)</code>或<code>IP层</code>。</p><h4 id="IP地址及其表示方法"><a href="#IP地址及其表示方法" class="headerlink" title="IP地址及其表示方法"></a>IP地址及其表示方法</h4><p>&emsp;&emsp;我们因特网看成为一个单一的、抽象的网络。IP地址就是给每个连接在互联网上的主机(或路由器)的每一个<code>接口</code>分配一个在全世界范围<code>唯一的32位的标识符</code>。IP地址由互联网名字和数字分配机构<code>ICANN(Internet Corporation for Assigned Names and Numbers)</code>进行分配。北京计算机应用研究所于1993年6月4日从APNIC处获得了一个C类的IP地址。CNNIC以国家互联网络注册机构(NIR)的身份于1997年1月成为APNIC的联盟会员，成立了以CNNIC为召集单位的分配联盟，已为多家ISP提供IP地址。</p><p><img src="https://cdn.nafx.top/post_cover/20230304161529.png" alt="点分十进制记法"><br>&emsp;&emsp;在主机中，IP地址都是32位的二进制代码，为了提高可读性我们常每隔8位插入一个空格(实际在机器中没有)，为了我们方便书写和记忆，常用其等效的十进制数字表示，并且在每段数字之间加上一个小数点，这就叫做<code>点分十进制记法(dotted decimal notation)</code>。<br><img src="https://cdn.nafx.top/post_cover/20230304162213.png" alt="IP地址中的网络号和主机号字段"><br>&emsp;&emsp;我们给每个接口分配一个IP地址，其含义就是这个IP地址不但标志了这个主机(或路由器)，而且还标志了此接口所连接的网络。因此32位的IP地址采用两级接口，由两个字段组成。第一个字段是<code>网络号</code>，它标志这个主机(或路由器)所连接的网络。一个网络号在整个互联网范围内必须是唯一的。第二个字段是主机号，它标志着该主机。</p><h4 id="分类的IP地址"><a href="#分类的IP地址" class="headerlink" title="分类的IP地址"></a>分类的IP地址</h4><p>&emsp;&emsp;在互联网发展早期采用的是分类的IP地址，将32位的IP地址划分为若干类，如下图。<br><img src="https://cdn.nafx.top/post_cover/20230304164929.png" alt="分类的IP地址以及各类地址所占的比例"><br>一般不使用的特殊IP地址<br>|网络号|主机号|源地址使用|目的地址使用|代表意思|<br>|:-:|:-:|:-:|:-:|:-:|<br>|0|0|可以|不可|在本网络上的本主机|<br>|0|X|可以|不可|在本网络上主机号为X的主机|<br>|全1|全1|不可|可以|只在本网络上进行广播(各路由器均不转发)|<br>|Y|全1|不可|可以|对网络号为Y的网络上的所有主机进行广播|<br>|127|非全0或全1的任何数|可以|可以|用于本地软件环回测试|</p><p>分类IP地址优点：</p><ul><li>IP地址管理机构在分配IP地址是只需要分配网络号，剩下的主机号由单位自行分配，方便了IP地址的管理;</li><li>路由器仅根据目的主机所连接的网络号转发分组而不考虑目的主机号，这样就可以使路由表中的项目数大幅减小，从而减小了路由表所占的存储空间。</li></ul><h4 id="无分类编址CIDR"><a href="#无分类编址CIDR" class="headerlink" title="无分类编址CIDR"></a>无分类编址CIDR</h4><p>&emsp;&emsp;由于早期对IP地址资源的浪费和20世纪90年代互联网迅猛的发展，IP地址将在不久后枯竭，而且互联网主干网上的路由表中的项目急剧增长(从几千个增长到几万个)。为提高IP地址资源利用率，产生了<code>变长子网掩码VLSM(Variable Length Subnet Mask)</code>，后在VLAM的基础上又进一步研究出<code>无分类编制方法 CIDR(Classless Inter-Domain Routing)</code>。<br>&emsp;&emsp;CIDR消除了A类、B类和C类地址以及划分子网的概念，更加有效地分配IPv4的地址空间。CIDR采用变长的<code>网络前缀(network-prefix)</code>代替分类地址中的网络号子网号，剩下的后面部分仍然使主机号，有些文献也称之为<code>后缀(suffix)</code>。<br><img src="https://cdn.nafx.top/post_cover/20230305132426.png" alt="CIDR表示的IP地址"></p><h5 id="无分类的两级编址的记法"><a href="#无分类的两级编址的记法" class="headerlink" title="无分类的两级编址的记法"></a>无分类的两级编址的记法</h5><p>&emsp;&emsp;CIDR使用<code>斜线记法(slash notation)</code>或称CIDR记法，即在IP地址后面加上一个斜线”/“，然后协商网络前缀所占的位数(这个数值对应三级编址中子网掩码中1的个数)。例如:220.78.168.0/24</p><h5 id="CIDR地址块"><a href="#CIDR地址块" class="headerlink" title="CIDR地址块"></a>CIDR地址块</h5><p>&emsp;&emsp;CIDR把网络前缀都相同的连续的IP地址组成<code>CIDR地址块</code>，一个地址块包含的IP数目取决于网络前缀的位数。如128.14.32.0/20表示的地址块共有2^12个地址，起始地址是128.14.32.0同时也是地址块中<code>最小地址</code>，<code>最大地址</code>为128.14.47.255。全0和全1的主机号地址不使用。<br>&emsp;&emsp;128.14.32.0/20除了表示一个地址块，也表示一个网络前缀，还是这个地址块中主机号全为0的地址。<br>一些特殊的地址块</p><ul><li>前缀n=32，即32位IP地址都是前缀，没有主机号。这其实就是一个IP地址，这个特殊地址用于主机路由;</li><li>前缀n=31，这个地址块中只有两个IP地址，其主机号分别为0和1，这个地址块用于点对点链路;</li><li>前缀n=0，同时IP地址也全是0，即0.0.0.0/0。用于默认路由。</li></ul><h5 id="地址掩码"><a href="#地址掩码" class="headerlink" title="地址掩码"></a>地址掩码</h5><p>&emsp;&emsp;地址掩码常称为掩码，由一连串1和接着一连串0组成，1的个数就是网络前缀的长度。地址掩码又称为子网掩码。  </p><h4 id="路由聚合"><a href="#路由聚合" class="headerlink" title="路由聚合"></a>路由聚合</h4><p>&emsp;&emsp;一个CIDR地址块可以表示很多地址，这种地址的聚合常称之为<code>路由聚合(route aggregation)</code>，它使得路由表中的一个项目可以表示很多个原来的传统分类地址的路由。减小了路由器之间路由选择信息的交换，提高了整个互联网的性能。CIDR虽然不使用子网了，但仍然使用掩码这一名词(但不叫子网掩码)。路由聚合也称为构成<code>超网(supernetting)</code>。前缀长度不超过23位的CIDR地址块都包含了多个C类地址，这些C类地址合起来就构成了超网。CIDR的一个好处是可以更加有效的分配IPv4的地址空间，可以根据客户的需要分配适当大小的CIDR地址块。<br><img src="https://cdn.nafx.top/post_cover/CIDR%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86.png" alt="CIDR子网划分"><br>&emsp;&emsp;对于点对点链路构成的特殊网络现在也常常不分配IP地址，这种特殊网络叫做无编号网络[RFC 3021]或匿名网络。</p><h4 id="IP地址与MAC地址"><a href="#IP地址与MAC地址" class="headerlink" title="IP地址与MAC地址"></a>IP地址与MAC地址</h4><p>&emsp;&emsp;从层次的角度看，MAC地址是数据链路层使用的地址，是固化在网卡ROM中的物理地址，而IP地址是网络层和以上各层使用的地址，是软件实现的一种逻辑地址。<br><img src="https://cdn.nafx.top/post_cover/20230306125424.png" alt="IP地址和MAC地址"><br>&emsp;&emsp;在IP层抽象的互联网上只能看到IP数据报，虽然IP数据报要经过路由器转发，但源地址和目的IP地址始终不变，路由器只根据目的站的IP地址进行转发，数据报中间经过的路由器的IP地址并不出现在IP数据报的首部中。<br>&emsp;&emsp;在局域网的链路层只能看见MAC帧，传输过程中需走协议栈不断变更源MAC地址和目的MAC地址。MAC帧首部的这种变更在上面的IP上是看不见的，尽管互连在一起的网络的MAC地址体系各不相同，但IP层抽象的互联网屏蔽了下层这些很复杂的细节，只要在网络层上探讨问题就能够使用统一的、抽象的IP地址研究主机和主机或路由器间的通信。<br><img src="https://cdn.nafx.top/post_cover/20230306130631.png" alt="不同层次看IP地址和MAC地址"></p><h4 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h4><p>&emsp;&emsp;计算机在通信时使用了两个地址，分别是网络层的IP地址和数据链路层的MAC地址。通信时知道了主机或路由器的IP地址，需要找出其相应的MAC地址就使用了地址解析协议ARP。ARP是解决同一个局域网上的主机或路由器的的IP地址和MAC地址的映射问题。<br><img src="https://cdn.nafx.top/post_cover/20230306133042.png" alt="ARP协议"><br>&emsp;&emsp;<code>ARP协议请求</code>以<code>广播帧</code>形式发送，所有主机接收该帧；<code>ARP响应</code>以<code>单播帧</code>形式发送，除目标主机外，其他主机全部丢弃。</p><h5 id="ARP高速缓存"><a href="#ARP高速缓存" class="headerlink" title="ARP高速缓存"></a>ARP高速缓存</h5><p>&emsp;&emsp;每台主机都设有一个ARP高速缓存(ARP cache)，里面存有本局域网各主机和路由器的IP地址到MAC地址的映射表，存放最近获得的IP地址和MAC地址的绑定，以减少ARP广播的数量。实现方法是不论时收到ARP请求或是相应都互相记录下IP与MAC的映射存入表中。</p><h5 id="ARP报文格式"><a href="#ARP报文格式" class="headerlink" title="ARP报文格式"></a>ARP报文格式</h5><p>ARP协议是封装到MAC帧里的<br><img src="https://cdn.nafx.top/post_cover/20230306161542.png" alt="ARP报文格式"><br>当主机A欲向<strong>本局域网</strong>上的某个主机B发送IP数据报时。先在其ARP cache中查看有无主机B的IP地址。如果有就直接查出其对应的硬件地址，再将此硬件地址写入MAC的目的MAC地址，然后通过局域网将该MAC帧发送;如果没有，ARP进程会在本局域网上广播发送一个ARP请求分组，收到ARP响应后就将得到的目标主机MAC地址和IP地址的映射写入ARP cache然后通过局域网将该MAC帧发送。</p><h5 id="ARP协议注意问题"><a href="#ARP协议注意问题" class="headerlink" title="ARP协议注意问题"></a>ARP协议注意问题</h5><p>&emsp;&emsp;ARP协议不能穿透路由器，ARP时用于解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题，如果所要找的主机和源主机不在同一个局域网上，那么就要通过ARP找到一个位于本局域网上的某个路由器的硬件地址，然后把分局发送给这个路由器，让这个路由器把分组转发给下一个网络。从IP地址到硬件地址的解析是自动进行的，主机的用户对这种地址解析过程是不知道的。只要主机或路由器要和本网络上另一个已知IP地址的主机或路由器进行通信，协议ARP就会自动把这个IP地址解析为链路层所需要的MAC地址，然后插入到MAC帧中。(中间人攻击风险)</p><p>使用ARP的四种典型情况<br><img src="https://cdn.nafx.top/post_cover/20230306163912.png" alt="使用ARP的四种典型情况"></p><h4 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h4><p><img src="https://cdn.nafx.top/post_cover/20230306170944.png" alt="IP数据报格式"><br>IP数据报由首部和数据两部分组成，首部的前一部分是固定长度共20字节，固定部分后面是一些可选字段，其长度是可变的。</p><ul><li>版本: 占4位，指IP协议的版本，目前为4即IPv4。</li><li>首部长度: 占4位，可表示的最大数值是15个单位(一个单位4字节)，IP的首部最大长度是60字节，最小仅有固定部分20字节也就是对应值为0101。</li><li>区分服务: 占8位，指明期望获得哪种类型的服务。</li><li>总长度: 占16位，首部+数据的长度单位为字节，数据报的最大长度为65535字节，注意总长度与MTU的关系(以太网MTU为46~1500字节)。</li><li>标识: 占16位，与标志和片偏移字段与IP分片有关，IP数据报总长度超过MTU时，IP需要分片。标识是一个计数器，用来产生一个标识，所有IP分片的标识与原始IP数据报一致，便于接收方还原原始IP数据报。</li><li>标志: 占3位，最高位无意义，中间位DF(Don’t Fragment) DF=1时不允许分片(常用来探测路径最小MTU);DF=0允许分片。最低位MF(More Fragment) MF=1 后面还有分片,MF=0时这是最后一片。</li><li>片偏移: 占13位，分片后某片在原始IP数据报中的相对位置，以8字节为单位。</li><li>生存时间: 占8位，生存时间英文缩写为TTL(Time To Live)，表示数据报在网络中的寿命，由发出数据报的源点设置该字段，目的是为了防止无法交付的数据报无限制的在互联网中兜圈子而白白消耗网络资源，最初的设计以秒为单位，每经过一个路由器就前去数据报在路由器所消耗掉的一段时间(小于1s按1算)，当TTL减为0时就丢弃这个数据。随着技术进步就把TTL字段功能改为跳数限制，因此现在TTL的单位为跳数。若把TTL设为1就表示该条数据报只能在本局域网中传送。</li><li>协议: 占8位，表示该数据报文所携带的数据所使用的协议类型。以便使目的主机的IP层知道应将数据部分上交给哪个协议来处理。不同的协议有专门不同的协议号，常用如下。</li></ul><table><thead><tr><th align="center">协议名</th><th align="center">ICMP</th><th align="center">IGMP</th><th align="center">IP</th><th align="center">TCP</th><th align="center">EGP</th><th align="center">UDP</th><th align="center">IPv6</th><th align="center">ESP</th><th align="center">AH</th><th align="center">ICMP-IPv6</th><th align="center">OSPF</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">2</td><td align="center">4</td><td align="center">6</td><td align="center">8</td><td align="center">9</td><td align="center">17</td><td align="center">41</td><td align="center">50</td><td align="center">51</td><td align="center">58</td><td align="center">89</td></tr></tbody></table><ul><li>首部检验和（checksum）: 占16位用于校验数据报的首部，但不包括数据部分。数据报每经过一个路由器，首部的字段都可能发生变化（如TTL），所以需要重新校验。而数据部分不发生变化，所以不用重新生成校验值。为了进一步减小计算工作量，不采用复杂的CRC校验码，而采用简单的分16位序列的反码和校验。</li><li>源地址: 占32位，表示发送数据报的源IP地址。</li><li>目的地址: 占32位，表示接收数据报的目的IP地址。</li><li>可选字段: 该字段用于一些可选的报头设置，主要用于测试、调试和安全的目的。这些选项包括严格源路由（数据报必须经过指定的路由）、网际时间戳（经过每个路由器时的时间戳记录）和安全限制。</li><li>填充:由于可选字段中的长度不是固定的，使用若干个0填充该字段，可以保证整个报头的长度是 32 位的整数倍。</li><li>数据部分: 表示传输层的数据，如保存 TCP、UDP、ICMP 或 IGMP 的数据。数据部分的长度不固定。</li></ul><h4 id="IP层转发分组过程"><a href="#IP层转发分组过程" class="headerlink" title="IP层转发分组过程"></a>IP层转发分组过程</h4><h5 id="基于终点的转发"><a href="#基于终点的转发" class="headerlink" title="基于终点的转发"></a>基于终点的转发</h5><p>&emsp;&emsp;按目的主机号来制作路由表则所得出的路由表就会过于庞大，按主机所在的网络地址(前缀)制作路由表就可以使路由表大大简化。路由表没有给分组指明到某个网络的完整路径，路由表指出到某个网络应当先到某个路由器(即吓一跳路由器)，到达下一跳路由器后继续查找其路由表，ARP协议获取下一跳MAC地址封装成帧再交给下一跳，直到最后到达目的网络。</p><h5 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h5><p>&emsp;&emsp;使用CIDR时，路由表中的每个项目由网络前缀和下一跳地址组成，在查找路由表时可能会得到不止一个匹配结果。这时应当从匹配结果中选择具有最长网络前缀的路由这叫做<code>最长前缀匹配(longest-prefix matching)</code>。因为网络前缀越长，其地址块就越小，路由就越具体，最长前缀匹配又称为<code>最长匹配</code>或<code>最佳匹配</code>。</p><h5 id="特定主机路由"><a href="#特定主机路由" class="headerlink" title="特定主机路由"></a>特定主机路由</h5><p>&emsp;&emsp;互联网所有的分组转发都是基于目的主机所在的网络，但允许有这样的特例，即为特定的目的主机指明一个理由。采用特定主机路由可以使网络管理人员能更方便地<code>控制</code>网络和<code>测试</code>网络，同时也可在需要<code>考虑某种安全问题</code>时采用这种特定主机路由。</p><h5 id="默认路由-default-route"><a href="#默认路由-default-route" class="headerlink" title="默认路由(default route)"></a>默认路由(default route)</h5><p>&emsp;&emsp;路由器采用默认路由以减少路由表所占用的空间和搜索路由表所用的时间。末端网络(存根网络)也就是网络只用一个路由器和互联网连接，这种情况下使用默认路由(0.0.0.0)。</p><p>路由器分组转发流程<br><img src="https://cdn.nafx.top/post_cover/20230308124657.png" alt="路由器分组转发流程"></p><h4 id="网际控制报文协议ICMP-Internet-Control-Message-Protocol"><a href="#网际控制报文协议ICMP-Internet-Control-Message-Protocol" class="headerlink" title="网际控制报文协议ICMP(Internet Control Message Protocol)"></a>网际控制报文协议ICMP(Internet Control Message Protocol)</h4><p>&emsp;&emsp;为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了网际控制报文协议ICMP辅助IP协议工作。ICMP分担了IP的一部分功能：</p><ul><li>差错报告: 目的不可达、源站抑制、超时、参数问题、重定向;</li><li>查询: 回送请求/应答、地址掩码请求/应答、时间戳请求/应答;</li></ul><p>&emsp;&emsp;ICMP使主机或路由器报告差错情况和提供有关异常情况的报告，ICMP报文虽然是装在IP数据报中，作为其中的数据部分，看起来好像是高层协议，但实际是辅助IP协议工作的是网络层的协议。</p><p><img src="https://cdn.nafx.top/post_cover/20230308155216.png" alt="ICMP报文格式"></p><ul><li>类型: ICMP报文有两种类型，即差错报告报文和询问应答报文。</li><li>代码: 对类型进一步细化的说明</li><li>检验和: 对整个ICMP报文进行校验</li></ul><p><img src="https://cdn.nafx.top/post_cover/20230308161250.png" alt="几种常用的类型代码组合"></p><h5 id="ICMP差错报告报文"><a href="#ICMP差错报告报文" class="headerlink" title="ICMP差错报告报文"></a>ICMP差错报告报文</h5><p>&emsp;&emsp;ICMP差错报告报文共有四种</p><ul><li>终点不可达 包括目标主机没开机、目标主机中的进程没有开启、主机所在目标网络不可达等。</li><li>时间超过 TTL为0。</li><li>参数问题 当路由器或目的主机收到IP数据报的首部中有的字段值不正确时(首部检验和出错)，就丢弃该数据报并向源点发送参数问题报文。</li><li>改变路由(重定向) 找到了更好的路由</li></ul><p><img src="https://cdn.nafx.top/post_cover/20230308161532.png" alt="ICMP差错报告报文数据字段"><br>&emsp;&emsp;ICMP差错报告报文数据字段，是原始出错IP数据报的首部加上原始出错IP中的数据字段前8个字节。是为了告诉源IP数据报发送端，是哪个进程(端口)发送的IP数据报出错。</p><h5 id="不应发送ICMP差错报告报文的几种情况"><a href="#不应发送ICMP差错报告报文的几种情况" class="headerlink" title="不应发送ICMP差错报告报文的几种情况"></a>不应发送ICMP差错报告报文的几种情况</h5><ul><li>对封装到IP中的ICMP差错报告报文不再发送ICMP差错报告报文；</li><li>对第一个分片的数据报分片的所有后续数据报分片都不发送差错报告报文;</li><li>对具有多播地址的数据报都不发送差错报告报文;</li><li>对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送差错报告报文;</li></ul><h5 id="ICMP询问报文"><a href="#ICMP询问报文" class="headerlink" title="ICMP询问报文"></a>ICMP询问报文</h5><p>&emsp;&emsp;询问报文目前使用的有以下两种:</p><ul><li>回送请求或回送回答 ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。用来测试目的站是否可达以及了解其有关状态。请求type = 8, code = 0;回答type = 0, code = 0。(ping用的就是此ICMP报文)</li><li>时间戳请求或时间戳回答 在ICMP时间戳请求报文发出后就能够收到对方回应的ICMP时间戳回答报文，利用在报文中记录的时间戳发送方很容易计算出当前网络的往返时延。请求type = 13, code = 0;回答 type = 14, code = 0。</li></ul><h5 id="ICMP应用举例"><a href="#ICMP应用举例" class="headerlink" title="ICMP应用举例"></a>ICMP应用举例</h5><p>&emsp;&emsp;ICMP的一个重要应用就是分组网间探测PING(Packet InterNet Groper)，用来测试两台主机之间的连通性。PING使用了ICMP回送请求与回送回答报文。另外PING是应用层直接使用网络层ICMP的一个例子，它没有通过运输层的TCP或UDP。</p><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><h4 id="IPv6分组格式"><a href="#IPv6分组格式" class="headerlink" title="IPv6分组格式"></a>IPv6分组格式</h4><p>&emsp;&emsp;为了解决IP地址耗尽的根本措施就是采用具有更大地址空间的新版本IP，即IPv6.经过多年的研究和时延，2017年7月发布了IPv6的正式标准[RFC 8200, STD86]。IPv6 仍支持<code>无连接</code>的传送，但将<code>协议数据单元 PDU </code>称为分组，而不是 IPv4 的数据报。为方便起见，本书仍采用数据报这一名词。<br>IPv6 所引进的主要变化如下:</p><ul><li>更大的地址空间。 IPv6 把地址从IPv4 的32位增大到4倍，即增大到128位，使地址空间增大了2^96倍。这样大的地址空间在可预见的将来是不会用完的。</li><li>扩展的地址层次结构。 IPv6 由于地址空间很大，因此可以划分为更多的层次。</li><li>灵活的首部格式。 IPv6 数据报的首部和 IPv4 的并不兼容。 IPv6 定义了许多可选的扩展首部，不仅可提供比 IPv4 更多的功能，而且还可提高路由器的处理效率，这是因为路由器对扩展首部不进行处理（除逐跳扩展首部外）。</li><li>改进的选项。 IPv6 允许数据报包含有选项的控制信息，因而可以包含一些新的选项。但 IPv6 的首部长度是固定的，其选项放在有效载荷中。我们知道， IPv4 所规定的选项是固定不变的，其选项放在首部的可变部分。</li><li>允许协议继续扩充。这一点很重要，因为技术总是在不断地发展（如网络硬件的更新）而新的应用也还会出现。但我们知道， IPv4 的功能是固定不变的。</li><li>支持即插即用（即自动配置）。 因此 IPv6 不需要使用 DHCP。</li><li>支持资源的预分配。 IPv6 支持实时视像等要求保证一定的带宽和时延的应用。</li><li>IPv6 首部改为 8 字节对齐（即首部长度必须是 8 字节的整数倍）。原来的 IPv4 首部是 4 字节对齐。</li></ul><p><img src="https://cdn.nafx.top/post_cover/20230308213247.png" alt="具有多个可选扩展首部的 IPv6 数据报的一般形式"></p><p>IPv6 数据报由两大部分组成，即基本首部(base header)和后面的有效载荷(payload)。有效载荷也称为净负荷。有效载荷允许有零个或多个扩展首部(extension header)，再后面是数据部分。但请注意，所有的扩展首部并不属于 IPv6 数据报的首部。</p><p>与 IPv4 相比， IPv6 对首部中的某些字段进行了如下的更改：</p><ul><li>取消了首部长度字段，因为它的首部长度是固定的（40 字节）。</li><li>取消了服务类型字段，因为优先级和流标号字段实现了服务类型字段的功能。</li><li>取消了总长度字段，改用有效载荷长度字段。</li><li>取消了标识、标志和片偏移字段，因为这些功能已包含在分片扩展首部中。</li><li>把 TTL 字段改称为跳数限制字段，但作用是一样的（名称与作用更加一致）。</li><li>取消了协议字段，改用下一个首部字段。</li><li>取消了检验和字段，这样就加快了路由器处理数据报的速度。我们知道，在数据链路层对检测出有差错的帧就丢弃。在运输层，当使用 UDP 时，若检测出有差错的用户数据报就丢弃。当使用 TCP 时，对检测出有差错的报文段就重传，直到正确传送到目的进程为止。因此在网络层的差错检测可以精简掉。</li><li>取消了选项字段，而用扩展首部来实现选项功能。</li></ul><p>由于把首部中不必要的功能取消了，使得 IPv6 首部的字段数减少到只有 8 个（虽然首部长度增大了一倍）。下面解释 IPv6 基本首部中各字段的作用。<br><img src="https://cdn.nafx.top/post_cover/20230309140534.png" alt="IPv6 基本首部和有效载荷"></p><ol><li>版本(version) 占 4 位。它指明了协议的版本，对 IPv6 该字段是 6。</li><li>通信量类(traffic class) 占 8 位。这是为了区分不同的 IPv6 数据报的类别或优先级，和IPv4的区分服务字段的作用相似，目前正在进行不同的通信量类性能的实验。</li><li>流标号(flow label) 占 20 位。 IPv6 的一个新的机制是支持资源预分配，并且允许路由器把每一个数据报与一个给定的资源分配相联系。 IPv6 提出流(flow)的抽象概念。所谓“流”就是互联网络上从特定源点到特定终点（单播或多播）的一系列数据报（如实时音频或视频传输），而在这个“流”所经过的路径上的路由器都保证指明的服务质量。所有属于同一个流的数据报都具有同样的流标号。因此，流标号对实时音频/视频数据的传送特别有用。对于传统的电子邮件或非实时数据，流标号则没有用处，把它置为 0 即可。</li><li>有效载荷长度(payload length) 占 16 位。它指明 IPv6 数据报除基本首部以外的字节数（所有扩展首部都算在有效载荷之内）。这个字段的最大值是 64 KB（65535 字节）。</li><li>下一个首部(next header) 占 8 位。它相当于 IPv4 的协议字段或可选字段。当 IPv6 数据报没有扩展首部时，下一个首部字段的作用和 IPv4 的协议字段一样，它的值指出了基本首部后面的数据应交付 IP 层上面的哪一个高层协议（例如： 6或 17 分别表示应交付运输层 TCP 或 UDP）;当出现扩展首部时，下一个首部字段的值就标识后面第一个扩展首部的类型。</li><li>跳数限制(hop limit) 占 8 位。用来防止数据报在网络中无限期地存在。源点在每个数据报发出时即设定某个跳数限制（最大为 255 跳）。每个路由器在转发数据报时，要先把跳数限制字段中的值减 1。当跳数限制的值为零时，就要把这个数据报丢弃。</li><li>源地址 占 128 位。是数据报的发送端的 IP 地址。</li><li>目的地址 占 128 位。是数据报的接收端的 IP 地址。</li></ol><p>IPv6的拓展首部有以下六种:<br>1.逐跳选项 2.路由选择 3.分片 4.鉴别 5.封装安全有效载荷 6.目的站选项<br>每一个扩展首部都由若干字段组成，他们的长度也各不同，但所有的拓展首部的第一个字段都是8位的下一个首部字段。此字段的值指出了在该扩展首部后面的扩展首部是什么。当使用多个拓展首部时应按以上顺序先后出现。 IPv4 的数据报如果在其首部中使用了选项，那么沿着数据报传送的路径上的每一个路由器都必须对这些选项一一进行检查，这就降低了路由器处理数据报的速度。IPv6把原来IPv4首部中的选项功能都放在拓展首部中，数据报若使用了拓展首部在其基本首部的<code>下一个首部</code>字段就会指出在有效载荷字段中使用了何种拓展首部，所有拓展首部的第一个字段都是<code>下一个首部</code>，这就使得路由器能迅速判断待转发的IPv6数据报有无需要本路由器处理的选项。</p><h4 id="IPv6地址"><a href="#IPv6地址" class="headerlink" title="IPv6地址"></a>IPv6地址</h4><p>一个IPv6数据报的目的地址可以是以下三种基本类型地址之一:</p><ul><li>单播(unicast) 单播就是传统的点对点通信;</li><li>多播(multicast) 多播是一点对多点的通信，<em>数据报发送到一组计算机中的每一个</em>。 IPv6 没有采用广播的术语，而是将广播看作多播的一个特例。</li><li>任播(anycast) 这是 IPv6 增加的一种类型。 任播的终点是一组计算机，但<em>数据报只交付其中的一个</em>，通常是按照路由算法得出的距离最近的一个。</li></ul><h4 id="地址编写规范"><a href="#地址编写规范" class="headerlink" title="地址编写规范"></a>地址编写规范</h4><p>&emsp;&emsp;由于IPv6使用128位地址，为了使地址再简洁些，IPv6使用冒号十六进制记法(colon hexadecimal notation 简写为 colon hex)，就是把每个16位的值用十六进制值表示，各值之间用冒号分隔。</p><p>另外用这种方法表示的地址还有三种压缩的方法:</p><ul><li>每组地址0开头可以省略;</li><li>每组连续多个0可以用一个0表示;</li><li>连续多组0信息可以用双冒号表示(零压缩，但双冒号只能用一次)</li></ul><p><img src="https://cdn.nafx.top/post_cover/20230309150215.png" alt="地址压缩例子"></p><h4 id="IPv6地址分类"><a href="#IPv6地址分类" class="headerlink" title="IPv6地址分类"></a>IPv6地址分类</h4><p><img src="https://cdn.nafx.top/post_cover/20230309150631.png" alt="IPv6地址分类情况"><br><img src="https://cdn.nafx.top/post_cover/20230309160120.png" alt="IPv6地址分类"></p><h5 id="单播地址"><a href="#单播地址" class="headerlink" title="单播地址"></a>单播地址</h5><p><img src="https://cdn.nafx.top/post_cover/20230309151850.png" alt="单播地址"><br>三级结构划分法<br>全球路由选择前缀: 48位，前三位为001，第一级地址，分配给ISP等机构，相当于IPV4的网络号。<br>子网标识: 16位，第二级地址，ISP等机构创建自己的子网。<br>接口ID： 64位，第三级地址，指明主机或路由器单个的网络接口，相当于IPv4的主机号。除组播地址外，格式前缀空间001~111，必须有位接口ID。可以将各种接口的硬件地址直接进行编码，只需提取出最后64位就可以得到硬件地址，不需要ARP进行地址解析。</p><h5 id="聚合全局单播地址"><a href="#聚合全局单播地址" class="headerlink" title="聚合全局单播地址"></a>聚合全局单播地址</h5><p><img src="https://cdn.nafx.top/post_cover/20230309152846.png" alt="聚合全局单播地址"><br>聚合全局单播地址(Aggregate Global Unicast Addresses)又称为AGUA地址，设备上配置的公网IP地址。起始地址为2000:0000:0000:0000:0000:0000:0000:0000结束地址为3FFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF 因为前三位001二进制不能动，相当于网络位。<br>其中又分三种:</p><ul><li>主机分配的: 2001::/16,目前实际用于IPv6因特网运作的;</li><li>设备使用的: 2002::/16,用于实现6-to-4隧道(过渡节点保留);</li><li>测试: 3FFE::/16 早期用于6bone测试目的的前缀;</li></ul><h5 id="本地链路单播地址"><a href="#本地链路单播地址" class="headerlink" title="本地链路单播地址"></a>本地链路单播地址</h5><p><img src="https://cdn.nafx.top/post_cover/20230309152957.png" alt="本地链路地址"><br>本地链路地址(link-local unicast address)是在一个节点启用IPv6，启动时节点的每个接口自动生成的。在本链路上路由表中看到的下一跳都是对端的本地链路地址，不是公网IP地址。可以作为路由表中的下一跳地址，路由器与路由器之间使用。没有申请到公网IP地址时，实现路由器设备之间的地址配置通信。相当于IPv4中的169.254.0.0/16。当需要把分组发往单一链路的设备而不希望该分组被转发到此链路范围以外的地方时可以使用这种特殊地址，这类地址占IPv6地址总数的1/1024。</p><h5 id="本地站点单播地址"><a href="#本地站点单播地址" class="headerlink" title="本地站点单播地址"></a>本地站点单播地址</h5><p><img src="https://cdn.nafx.top/post_cover/20230309153909.png" alt="本地站点单播地址"><br>本地站点单播地址(site-local unicast address)也称为私有IPv6地址，相当于IPv4的专用地址，在单位或机构内使用，并没有连接到互联网上。这类地址占IPv6地址总数的1/1024。</p><h5 id="其他地址"><a href="#其他地址" class="headerlink" title="其他地址"></a>其他地址</h5><ul><li>组播地址 IPv6没有广播地址，以组播地址替代，前缀: FF00::/8，功能和IPv4一样，这类地址占总地址数的1.256;</li><li>未指明地址 这是16字节全0的地址，可缩写为<code>::</code>，这个地址不能用作目的地址，而只能将某台主机当作源地址使用，条件是这台主机还有没配置到一个标准的IP地址。这类地址仅此一个;</li><li>环回地址 IPv6的环回地址是<code>0:0:0:0:0:0:0:1</code>,可缩写为<code>::1</code>,和IPv4的环回地址一样，这类地址仅此一个;</li></ul><h4 id="从IPv4向IPv6过渡"><a href="#从IPv4向IPv6过渡" class="headerlink" title="从IPv4向IPv6过渡"></a>从IPv4向IPv6过渡</h4><p>&emsp;&emsp;互联网规模太大，向IPv6过渡只能采用逐步演进的办法，同时还要使新安装的IPv6系统向后兼容，也就是说IPv6系统必须能够接收和转发IPv4的分组，并且能为IPv4分组选择路由。下面是两种过渡策略，即双协议栈和隧道技术。</p><h5 id="双协议栈"><a href="#双协议栈" class="headerlink" title="双协议栈"></a>双协议栈</h5><p>&emsp;&emsp;双协议栈(dual stack)是指在完全过渡到IPv6之前，使一部分主机或路由器同时装有IPv4和IPv6这两种协议栈。在和IPv6主机通讯时采用IPv6地址，而和IPv4主机通信时采用IPv4地址。通过域名系统DNS查询解决决定，要是返回IPv6就用IPv6地址，返回IPv4就用IPv4地址。不过因为要装上两套协议开销较大。</p><h5 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h5><p>&emsp;&emsp;向 IPv6 过渡的另一种方法是隧道技术(tunneling)。下图给出了隧道技术的工作原理。这种方法的要点就是在 IPv6 数据报要进入 IPv4 网络时，把 IPv6 数据报封装成为 IPv4数据报。现在整个的 IPv6 数据报变成了 IPv4 数据报的数据部分。这样的 IPv4 数据报从路由器 B 经过路由器 C 和 D，传送到 E，而原来的 IPv6 数据报就好像在 IPv4 网络的隧道中传输，什么都没有变化。当 IPv4 数据报离开 IPv4 网络中的隧道时，再把数据部分（即原来的IPv6 数据报）交给主机的 IPv6 协议栈。图中的一条粗线表示在 IPv4 网络中好像有一个从 B到 E 的“IPv6 隧道”，路由器 B 是隧道的入口而 E 是出口。请注意，在隧道中传送的数据报的源地址是 B 而目的地址是 E。<br><img src="https://cdn.nafx.top/post_cover/20230310112057.png" alt="隧道技术"><br>要使双协议栈的主机知道 IPv4 数据报里面封装的数据是一个 IPv6 数据报，就必须把IPv4 首部的协议字段的值设置为 41（41 表示数据报的数据部分是 IPv6 数据报）。</p><h4 id="ICMPv6"><a href="#ICMPv6" class="headerlink" title="ICMPv6"></a>ICMPv6</h4><p>&emsp;&emsp;IPv6也不保证数据报的可靠交付，因为互联网中的路由器可能会丢弃数据报。因此IPv6也需要使用ICMP来反馈一些差错信息。新版本称为ICMPv6，它比ICMPv4 要复杂得多。地址解析协议 ARP 和网际组管理协议 IGMP 的功能都已被合并到 ICMPv6中（下图）。<br><img src="https://cdn.nafx.top/post_cover/20230310122141.png" alt="新旧版本中的网络层的比较"><br>ICMPv6 是面向报文的协议，它利用报文来报告差错，获取信息，探测邻站或管理多播通信。 ICMPv6 还增加了几个定义报文功能及含义的其他协议。在对 ICMPv6 报文进行归类时，不同的文献和 RFC 文档使用了不同的策略，有的把其中的一些报文定义为 ICMPv6 报文，而把另一些报文定义为邻站发现 ND (Neighbor-Discovery)报文或多播听众交付 MLD(Multicast Listener Delivery)报文。其实所有这些报文都应当是 ICMPv6 报文，只是功能和作用不同而已。因此我们把这些报文都列入 ICMPv6 的不同类别。使用这种分类方法的原因是所有这些报文都具有相同的格式，并且所有报文类型都由 ICMPv6 协议处理。其实，像 ND和 MLD 这样的协议都是运行在 ICMPv6 协议之下的。基于这样的考虑，可把 ICMPv6 报文分类如下图所示。请注意，邻站发现报文和组成员关系报文分别是在 ND 协议和 MLD 协议的控制下进行发送和接收的。</p><p>ICMPv6是作为IPv6报文的拓展封装到报文里面，在下一个首部字段的值为58指明数据部分是ICMPv6。<br><img src="https://cdn.nafx.top/post_cover/20230310122359.png" alt="ICMPv6格式"><br><img src="https://cdn.nafx.top/post_cover/20230310123107.png" alt="ICMPv6消息类型"><br><img src="https://cdn.nafx.top/post_cover/20230310131632.png" alt="MAC地址转换为IPv6实验"></p><h3 id="互联网的路由选择协议"><a href="#互联网的路由选择协议" class="headerlink" title="互联网的路由选择协议"></a>互联网的路由选择协议</h3><h4 id="理想的路由算法"><a href="#理想的路由算法" class="headerlink" title="理想的路由算法"></a>理想的路由算法</h4><p>&emsp;&emsp;路由选择协议的核心就是路由选择算法，一个理想的理由选择算法应具有如下的一些特点:</p><ul><li>算法必须是正确的和完整的，这里正确是指沿着各路由表所指引的路由，分组一定能够最终稿到达目的网络和目的主机。</li><li>算法在计算上应简单。路由选择的计算不应使网络通信量增加太多额外开销。</li><li>算法应能适应通信量和网络拓扑的变化，要有自适应性。当网络中的通信量发生变化时，算法能自适应地改变路由以均衡各链路的负载。或当某些节点、链路发生故障不工作时，算法也能及时地改变路由。有时称这种自适应性为稳健性(robustness)。</li><li>算法应具有稳定性 在网络通信量和网络拓扑相对稳定的情况下，路由算法应收敛于一个可以接受的解，不应使得出的路由不停地变化。</li><li>算法应是公平的 路由选择算法应对所有用户都是平等的。(除少数优先级高的用户)</li><li>算法应是最佳的 路由选择算法应能够找出最好的路由，使得分组平均时延最小而网络吞吐量最大。对于某些网络，网络的可靠性有时要比最小的分组平均时延或最大吞吐量更重要，因此所谓最佳也只能是相对于某种一种特定要求下得出的较为合理的选择而已。</li></ul><p>&emsp;&emsp;从路由算法的自适应性可以分为两大类，即静态路由选择策略与动态路由选择策略。</p><ul><li>静态路由选择策略也叫做非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化，对于简单的小网络完全可以采用静态路由选择，人工配置每一条路由。</li><li>动态路由选择策略也叫做自适应路由选择，其特点是能较好地适应网络的变化，但实现起来较为复杂，开销也比较大。动态路由选择适用于较复杂的大网络。</li></ul><h4 id="分层次的路由选择协议"><a href="#分层次的路由选择协议" class="headerlink" title="分层次的路由选择协议"></a>分层次的路由选择协议</h4><p>&emsp;&emsp;互联网采用的路由选择协议主要是自适应的(即动态的)、分布式路由选择协议。互联网规模非常大，如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大，处理起来也太花时间。而所有这些路由器之间交换路由信息所需的带宽就会使互联网的通信链路饱和。此外许多单位不愿外接了解自己单位网络的布局细节和本部门所采用的路由选择协议，但同时还希望连接到互联网上。为此可以把整个互联网划分为许多较小的<strong>自治系统(autonomous system)<strong>一般记为</strong>AS</strong>。自治系统AS是在单一技术管理下的许多网络，IP地址以及路由器，这些路由器使用一种自治系统内部的路由选择协议和共同的度量(跳数、带宽、时延、吞吐量等指标)。现在对自治系统AS的定义是强调尽管一个AS使用了多种内部路由选择协议和度量，但重要的是一个每个AS对其他AS表现出的是一个单一的和一致的路由选择策略。这样互联网就把路由选择协议划分为两大类，即:</p><ol><li>内部网关协议<code>IGP(Inner Gateway Protocol) </code>即在一个自治系统内部使用的路由选择协议，目前这类路由选择协议使用的最多的是<code>RIP</code>和<code>OSPF</code>。</li><li>外部网关协议<code>EGP(External Gateway Protocol)</code>若源主机和目的主机处在不同的自治系统中，就需要使用一种协议将路由选择信息传递到另一个自治系统中，这种协议就是外部网关协议，目前使用的最多的是<code>BGP-4</code>。</li></ol><p><img src="https://cdn.nafx.top/post_cover/20230310162228.png" alt="自治系统和内/外部网关协议"></p><ul><li>自治系统之间的路由选择也叫做<code>域间路由选择(interdomain routing)</code>。</li><li>在自治系统内部的路由选择叫做<code>域内路由选择(intradomain routing)</code>。</li></ul><h5 id="内部网关协议RIP"><a href="#内部网关协议RIP" class="headerlink" title="内部网关协议RIP"></a>内部网关协议RIP</h5><p>&emsp;&emsp;<code>RIP(Routing Information Protocol)</code>是内部网关协议<strong>IGP</strong>中最先得到广泛使用的协议，它的中文译名是<strong>路由信息协议</strong>。<strong>RIP是一种分布式的基于距离向量的路由选择协议</strong>，其最大优点是简单。网络中运行RIP路由器都要维护从它自己到每一个目的网络的距离记录。<br>&emsp;&emsp;对距离的定义为:从一路由器到直接连接的网络距离定义为1，从一路由器到非直接连接的网络的距离定义为所经过的路由器加1。RIP的距离也称为<code>跳数(hop count)</code>。RIP认为好的路由就是它通过的网络数目(路由器数目)少，即距离短。RIP允许一条路径最多只能包含15个路由器，因此距离等于16时即相当于不可达。可见RIP只适用于小型互联网。RIP选择一个具有最少路由器的路由，哪怕还存在另一条高速低时延但路由器较多的路由。<br>&emsp;&emsp;RIP协议三个特点:</p><ul><li>和谁交换信息？<br>仅和相邻路由器交换信息。</li><li>交换什么信息？<br>交换的信息是当前本路由器所知道的全部信息，即自己完整的路由表。</li><li>什么时候交换？<br>按固定的时间间隔交换路由信息，例如每隔30秒。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。网络中的主机虽然也运行RIP协议，但只被动地接收路由器发来的路由信息。</li></ul><p>&emsp;&emsp;路由器刚开始工作时路由表是空的，然后路由器就得出到直接连接的几个网络的距离(定义为1)，然后每个路由器也只和相邻路由器交换并更新路由信息。经过若干次更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。RIP路由表项包括目的网络、距离以及下一跳。在一般情况下RIP协议可以收敛(自治系统中所有的结点都得到正确的路由选择信息的过程)且收敛较快。</p><h6 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h6><p>&emsp;&emsp;路由表更新的原则就是找出每个目的网络的最短距离，这钟更新算法又称为<strong>距离向量算法</strong>。距离向量算法的基础就是Bellman-Ford算法，这种算法的要点是:<br>假设X是结点A到B的最短路径上的一个节点，若把路径A-&gt;B拆成两端路径A-&gt;X和X-&gt;B，则每一段路径也都分别是结点A到X和结点X到B的最短路径。换句话说我到目的地的最小距离等于我到邻居距离与邻居到目的地最小距离之和(存在一个或多个邻居)的最小值。<br>对于每一个相邻路由器发送过来的RIP报文执行以下步骤:<br><img src="https://cdn.nafx.top/post_cover/20230312120722.png" alt="距离向量算法流程"><br>若3分钟还没有收到相邻路由器的更新路由表，就把此相邻路由器标记为不可达路由器，即把距离置为16。</p><h6 id="RIPv2报文格式"><a href="#RIPv2报文格式" class="headerlink" title="RIPv2报文格式"></a>RIPv2报文格式</h6><p>RIP协议实际属于应用层协议，封装在UDP中， 端口520。<br><img src="https://cdn.nafx.top/post_cover/RIPv2%E5%8D%8F%E8%AE%AE.png" alt="RIPv2报文格式"></p><p>&emsp;&emsp;RIP协议特点是好消息传播的快，坏消息传播的慢，当网络出现故障时，要经过比较长的时间(例如数分钟)才能将此消息传送到所有的路由器，使更新过程收敛时间过长。另外由于路由器之间交换的是完整的路由表，所以随着网络规模的扩大开销增加，因此RIP限制了网络规模，它能使用的最大距离为15。协议的优点就是实现简单，开销较小。</p><h5 id="内部网关协议OSPF"><a href="#内部网关协议OSPF" class="headerlink" title="内部网关协议OSPF"></a>内部网关协议OSPF</h5><h6 id="开放最短路径优先OSPF"><a href="#开放最短路径优先OSPF" class="headerlink" title="开放最短路径优先OSPF"></a>开放最短路径优先OSPF</h6><p>&emsp;&emsp;这个协议的名字是<code>开放最短路径优先(Open Shortest Path First)</code>是为了克服RIP的缺点在1989年开发出来的，OSPF的原理很简单但实现起来却较复杂。<strong>开放</strong>表明OSPF协议不受某一家厂商控制而是公开发表的。<strong>最短路径优先</strong>是因为使用了Dijkstra提出的最短路径算法SPF。OSPF只是个协议的名字，并不表示其他路由选择协议不是最短路径优先，OSPF最主要的特征就是使用**链路状态协议(link state protocol)**。以累计链路开销作为路由参考，信息传递与路由计算分离。OSPF的三个要点是:</p><ol><li>和谁交换信息？<br>使用 <strong>洪泛法(flooding)</strong> 向本自治系统中所有路由器发送信息(通过所有端口向向所有仙林的路由器发送信息)。</li><li>交换什么信息？<br>发送的信息就是与本路由器相邻的所有路由器的<strong>链路状态</strong>(就是说明本路由器都和哪些路由器相邻，以及该链路的度量metric)，但这只是路由器所知道的部分信息。</li><li>什么时候交换信息？<br>只有当链路状态发生变化或每隔一旦时间如30分钟，路由器才用洪泛法向所有路由器发送此信息。</li></ol><p>&emsp;&emsp;所有的路由器最终都能建立一个链路状态数据库(link-state database)。这个数据库实际上就是全网的拓扑结构图，他在全网范围内是一致的(者称为数据链路状态数据库的同步)。OSPF的链路状态数据库能较快的进行更新，使各个路由器能及时更新其路由表，OSPF的更新过程收敛的快是其重要的优点。</p><h6 id="OSPF的区域"><a href="#OSPF的区域" class="headerlink" title="OSPF的区域"></a>OSPF的区域</h6><p>&emsp;&emsp;为了使OSPF能够用于规模很大的网络，OSPF将一个自治系统再划分为若干个更小的范围，叫做区域(area)。每一个区域都有一个32位的区域标识符(用点分十进制表示)。区域也不能太大，在一个区域内的路由器最好不超过200个。<br>&emsp;&emsp;划分区域的好处就是将洪泛法交换链路状态信息的范围局限于每一个区域，减少了网络上的通信量。同一个区域内的路由器只知道本区域的完整网络拓扑结构，不知道其他区域的网络拓朴。上层的区域叫做<strong>主干区域(backbone area)</strong> ，其标识符规定为0.0.0.0，主干区域的作用是用来连通其他区域的。<br><img src="https://cdn.nafx.top/post_cover/20230313124132.png" alt="OSPF划分区域"></p><h6 id="OSPF几个特点"><a href="#OSPF几个特点" class="headerlink" title="OSPF几个特点"></a>OSPF几个特点</h6><ul><li>OSPF不用UDP而是直接用IP数据报传送。OSPF构成的数据报很短，可以较少路由信息的通信量。数据报短的另一个好处是不必将长的数据报分片传送。</li><li>OSPF对不同的链路可根据IP分组的不同服务类型TOS而设置成不同的代价，对于不同类型的业务计算出不同的路由。</li><li>如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径，实现多路径间的负载均衡(load banlancing)。</li><li>所有在OSPF路由器之间交换的分组都具有鉴别的功能，保证了仅在可信赖的路由器之间交换链路状态信息。</li><li>支持可变长度的子网划分和无分类的标志CIDR。</li><li>每一个链路状态都嗲上一个32位的序号，序号越大状态越新。 </li><li>与网络规模无关，里尤其的链路状态只涉及到与相邻路由器的联通状态，因而与整个互联网的规模无直接关系，当互联网规模很大时，OSPF协议要比距离向量协议RIP好得多。</li></ul><h6 id="OSPF报文格式"><a href="#OSPF报文格式" class="headerlink" title="OSPF报文格式"></a>OSPF报文格式</h6><p><img src="https://cdn.nafx.top/post_cover/20230313130558.png" alt="OSPF报文格式"></p><p><img src="https://cdn.nafx.top/post_cover/20230313132815.png" alt="OSPF各字段说明"><br>OSPF共有五种类型的分组分别是:</p><ol><li>类型1，问候(Hello)分组，用来发现和维持邻站可达性,设置参数metric、mask、area_id、router_id等。</li><li>类型2，数据库表述(Database Description)分组，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。</li><li>类型3，链路状态请求(Link state Request)分组，向对方请求发送某些链路状态项目的详细信息。</li><li>类型4，链路状态更新(Link state Update)分组，用洪泛法对全网更新链路状态，路由器使用这种分组将其链路状态通知给邻站。该分组共用五种不同的链路状态。</li><li>类型5，链路状态确认(Link state Acknowledgement)分组，对链路更新分组的确认，向最早发送更新的路由器确认，称为可靠的洪泛法。</li></ol><p>&emsp;&emsp;OSPF规定每隔一段时间，如30分钟，要率先那一次数据库中的链路状态。OSPF没有坏消息传播的慢的问题，其相应网络变化的时间小于100ms。</p><h6 id="指定路由器"><a href="#指定路由器" class="headerlink" title="指定路由器"></a>指定路由器</h6><p>&emsp;&emsp;若N个路由器连接在一个以太网上，则每个路由器要向其他(N-1)个路由器发送链路状态信息，因而要有N(N-1)个链路状态要在这个以太网上传送。OSPF协议对这种多点接入的局域网采用了<strong>指定路由器(designated router)</strong> 的方法，使广播的信息量大大减小。指定的路由器代表局域网上所有的链路向连接到该网络上的各路由器发送状态信息。<br><img src="https://cdn.nafx.top/post_cover/20230313134843.png" alt="指定路由器"><br>DR和BDR是通过发HELLO包选举产生的。</p><h5 id="外部网关协议BGP"><a href="#外部网关协议BGP" class="headerlink" title="外部网关协议BGP"></a>外部网关协议BGP</h5><p>动态路由协议分类:</p><ul><li>IGP 工作在同一个AS内(RIP、OSPF)，为AS内的主机提供路由信息交换。</li><li>EGP 工作在AS与AS之间(BGP)，在AS之间他提供无环路的路由信息交换。</li></ul><p>&emsp;&emsp;外部网关协议(或边界网关协议)BGP(Border Gateway Protocol)是一种增强的距离矢量路由协议，拥有丰富的策略控制技术。BGP是不同自治系统的路由器之间交换路由信息的协议。互联网的规模太大，不同自治系统所用的度量不同，当一条路径通过几个不同AS时，计算出有意义的代价时不太可能的，比较合理的做法是在AS之间交换可达性信息。另外自治系统之间的路由必须考虑有关策略(控制路由)，包括政治、安全或经济方面的考虑。BGP寻找一条能够到达目的网络且比较好的路由(不能兜圈子)，不是寻找一条最佳路由。BGP采用TCP协议，目的端口号为179源端口号随意，这种TCP连接又称为半永久性连接(即双方交换完信息仍保持着连接状态)。域间路由协议稳定性要高，所以要用TCP协议保证信息可靠，</p><h6 id="BGP的特点"><a href="#BGP的特点" class="headerlink" title="BGP的特点"></a>BGP的特点</h6><p>&emsp;&emsp;为了使AS之间能够做路由信息的交换，每个AS要选择至少一个路由器作为该自治系统的<code>BGP发言人</code>，和相邻AS的BGP发言人交换路由信息。两个BGP发言人都是通过一个共享网络连接在一起的。</p><ul><li>和谁交换信息？<br>与邻居AS的BGP发言人交换信息。</li><li>交换什么信息?<br>交换网络可达性信息，即到达某个网络所要经过的一系列AS(增量更新，只发送更新的路由)。</li><li>什么时候交换？<br>网络拓朴发生变化时，更新有变化的部分。</li></ul><h6 id="BGP路由"><a href="#BGP路由" class="headerlink" title="BGP路由"></a>BGP路由</h6><p>&emsp;&emsp;当两个边界路由器（例如图中的R1和R2）进行通信时，必须先建立TCP连接，这种TCP连接又称为半永久性连接（即双方交换完信息后仍然保持着连接状态）。像R1 和R2之间的这种连接称为eBGP连接(e表示外部external)。现在，边界路由器R1可通过eBGP向对等端R2发送BGP路由<code>X,AS1,R1</code>，意思是“从R1经AS1可到达X”。这样通过eBGP连接，AS2中的边界路由器R2就知道了到达AS1中的前缀X的BGP路由。<br><img src="https://cdn.nafx.top/post_cover/20230313211256.png" alt="AS之间的eBGP连接和内部的IBGP连接"><br>&emsp;&emsp;但是，仅有边界路由器R2知道“到AS1的前缀X的BGP路由”是远远不够的。边界路由器R2应当把获得的BGP路由，再转发给AS内部的其他路由器。为此，协议BGP规定，在AS内部，两个路由器之间还需要建立iBGP（i表示内部internal），iBGP也使用TCP连接传送BGP报文。图(b)中表示边界路由器R2在三个iBGP连接上，向AS2内部的其他三个路由器转发自己收到的BGP路由。至此，AS2内的所有路由器都知道了这条BGP路由信息。由此可见，协议BGP并非仅运行在AS之间，而且也要运行在AS的内部。AS中的路由器，除了运行协议BGP外，还必须运行内部网关协议。但注意BGP并没有根据路由算法发现AS内部路由，BGP协议是用来解决在众多AS之间的路由选择问题。协议BGP规定，在一个AS内部所有的iBGP必须是全连通的。即使两个路由器之间没有物理连接，但它们之间仍然有iBGP连接。<br><img src="https://cdn.nafx.top/post_cover/20230313211606.png" alt="在AS内路由器之间的物理连接与iBGP连接"></p><h6 id="BGP路由通告原则"><a href="#BGP路由通告原则" class="headerlink" title="BGP路由通告原则"></a>BGP路由通告原则</h6><ul><li>只将<strong>最优路由</strong>发布给对等体。</li><li>只发送更新的BGP路由。</li><li>从eBGP邻居学到的路由，通告给所有BGP邻居(iBGP/eBGP)。</li><li>从iBGP邻居学到的路由，不通告给其他iBGP邻居(水平分割原则)，避免环路。</li><li>从iBGP邻居学到的路由，是否通告给eBGP邻居取决于BGP同步规则。</li></ul><h6 id="BGP路由格式"><a href="#BGP路由格式" class="headerlink" title="BGP路由格式"></a>BGP路由格式</h6><p><img src="https://cdn.nafx.top/post_cover/20230314132835.png" alt="BGP路由格式"></p><h6 id="三种不同的自治系统"><a href="#三种不同的自治系统" class="headerlink" title="三种不同的自治系统"></a>三种不同的自治系统</h6><p>&emsp;&emsp;互联网中自治系统AS的数量非常之多，其连接图也是相当复杂的，但归纳起来，可以把AS划分为三大类即末梢AS(stub AS)、穿越AS(transit AS)和对等AS(peering AS)。<br><img src="https://cdn.nafx.top/post_cover/20230314134015.png" alt="三种不同的自治系统"></p><ul><li>穿越AS: 高速通信干线的主干AS，其任务就是为其他的AS有偿转发分组。</li><li>末梢AS: 多归属AS，不允许其他AS穿透访问。</li><li>对等AS: 事先协商的两个AS，彼此之间的发送或接收分组不收费。</li></ul><h6 id="BGP路由选择方式"><a href="#BGP路由选择方式" class="headerlink" title="BGP路由选择方式"></a>BGP路由选择方式</h6><p>&emsp;&emsp;BGP路由选择方式又称路由选择策略，从一个AS到另一个AS的前缀X如果只有一条BGP路由，那么就不存在BGP路由选择的问题，因为这时BGP路由唯一。但如果到前缀X有两条或更多的BGP路由可供选择，那么就应根据以下原则，按这里给出的先后顺序选择一条较好的BGP路由。(有13条之多，课本列出4条)</p><ul><li>首先选择**本地偏好(LOCAL-PREFerence)**值最高的路由，本地偏好也称为本地优先，从本AS开始的、到同一个前缀的不同BGP路由中，挑选一个偏好值最高的路由(默认100)，只能在本AS内传递。这可由路由器管理员根据政治或经济上的策略来设置。</li><li>选择具有AS跳数最小的路由，跳数最小是以AS为单位，但不一定最佳。</li><li>使用热土豆路由选择算法，如果前两种方法都无法选择最好的路由，那么就要在进入BGP路由的AS执行热土豆路由选择算法。需要使用内部网关协议(RIP、OSPF)让分组经过最少的转发次数离开本AS。</li><li>选择路由器BGP标识符的数值最小的路由，以上方法都无法找出最好的BGP路由时，可以使用BGP标识符来选择路由，在BGP进行交互的报文中，其首部有一4字节的字段，叫佐BGP标识符，记为BGP ID，这个字段被赋予一个无符号整数作为运行BGP的路由器的唯一标识符。具有多个接口的路由器有多个IP地址。BGP ID就是用该路由器的IP地址中数值最大的那个。</li></ul><h6 id="BGP的四种报文"><a href="#BGP的四种报文" class="headerlink" title="BGP的四种报文"></a>BGP的四种报文</h6><ol><li>OPEN (打开)报文，与相邻的另一个BGP发言者建立关系，使通信初始化;</li><li>UPDATE (更新)报文，通告某一路由的信息，以及列出要撤销的多条路由;</li><li>KEEPALIVE (保活)报文，用来周期性地证与对等端的连通性。</li><li>NOTIFICATION (通知)报文，用来发送检测到的差错。</li></ol><p><img src="https://cdn.nafx.top/post_cover/20230314144327.png" alt="BGP报文用TCP报文传送"></p><p>对于通用首部：</p><ul><li>标记: 用检查BGP对等体的同步信息是否完整，以及用于BGP验证的计算(鉴别)。一般为32个十六进制F。</li><li>长度: 整个BGP报文的长度，单位字节，最小为19，最大4096。</li><li>类型: 1~4，分别对应四种类型的BGP报文。</li></ul><h4 id="路由器的构成"><a href="#路由器的构成" class="headerlink" title="路由器的构成"></a>路由器的构成</h4><p>&emsp;&emsp;路由器是一种具有多个输入输出端口的专用计算机，连通不同的网络，其任务是转发分组(转发给下一跳的网络)，直到该分组到达终点为止。</p><p><img src="https://cdn.nafx.top/post_cover/20230314151743.png" alt="典型的路由器结构"></p><p>&emsp;&emsp;整个路由器的结构可划分为两大部分: 路由选择部分和分组转发部分。</p><ul><li>路由选择部分(软件实现): 也称控制部分或控制层面，核心构件是路由选择处理机。路由选择处理机的任务是根据所选定的路由选择协议构造出路由表，并和相邻路由器交换路由信息，并不断地更新和维护路由表。  </li><li>分组转发部分(硬件实现):也称数据部分或数据层面，它由三部分组成: 交换结构、一组输入端口和一组输出端口(这里的端口就是硬件接口)。</li></ul><p>&emsp;&emsp;路由器如果收到交换路由信息的分组，就交给路由选择处理机；如果收到数据分组，则依照转发表转发分组。<br>&emsp;&emsp;关于路由选择(routing)和转发(forwarding)是有区别的，转发就是路由器根据转发表把收到的IP数据报从路由器合适的端口转发出去。转发表是从路由表得出的，转发仅仅涉及一个路由器。而路由选择则设计很多路由器，路由表则是许多路由器协同工作的结果。这些路由器按照路由算法得到的关于网络拓朴的变化情况，动态地改变所选择的路由。将装发表和路由表用不同的数据结构实现会带来一些好处，在转发分组时，转发表的结构应当是查找过程最优化，但路由表则需要对网络拓朴变化的计算优化。路由表总是用软件实现，但转发表可以用特殊的硬件实现。</p><h5 id="输入端口"><a href="#输入端口" class="headerlink" title="输入端口"></a>输入端口</h5><p><img src="https://cdn.nafx.top/post_cover/20230314183456.png" alt="输入端口对线路上收到分组的处理"><br>&emsp;&emsp;输入端口中的查找和转发功能在路由器的交换功能中是最重要的，为了使交换功能分散化，往往把复制的转发表放在每一个输入端口中。路由选择处理机负责对各转发表的副本进行更新。这些副本常称为<strong>影子副本(shadow copy)</strong> 分散化交换可以避免在路由器中的某一点上出现瓶颈。<br>&emsp;&emsp;当一个分组正在查找转发表时，后面有紧跟着从这个输入端口收到另一个分组，这个后到的分组就就必须在队列中排队等待，因而产生了一定的时延。</p><h5 id="输出端口"><a href="#输出端口" class="headerlink" title="输出端口"></a>输出端口</h5><p><img src="https://cdn.nafx.top/post_cover/20230314183724.png" alt="输出端口对线路上收到分组的处理"><br>&emsp;&emsp;若路由器处理分组的速率赶不上分组进入队列的速率，则队列的储存空间最终必定减小到零，这就是后面再进入队列的分组由于没有储存空间而只能被丢弃。路由器中的输入或输出队列产生益处时造成分组丢失的重要原因。当然设备或线路出故障也可能使分组丢失。</p><h5 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h5><p>&emsp;&emsp;交换结构是路由器的关键构建，正是这个交换结构把分组从一个输入端口转移到某个合适的输出端口。实现这样的交换有多种方法，下面给出了三种常见的交换方法。<br><img src="https://cdn.nafx.top/post_cover/20230314185503.png" alt="三种常用的交换方法"></p><h3 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h3><p>&emsp;&emsp;因为现在许多应用需要一个远点发送到多个终点，即一对多的通信如实时信息的交付(如新闻、股市行情、在线直播等)、软件更新、交互式会议等。随着互联网用户数目的急剧增加，以及多媒体通讯的开展，有更多的业务需要多播来支持。<br>&emsp;&emsp;传统的点对点应用以单个用户为单位提供服务，不同的用户与服务提供端的通信数据存在差异。而新型点到多点的应用以一组用户为单位提供服务，同组用户与服务提供端的通信数据无差异。与单播相比，多播可以大大节约网络资源。<br><img src="https://cdn.nafx.top/post_cover/4b9891ba81020a3754b24730efe4882.jpg" alt="单播与多播的比较"><br>&emsp;&emsp;使用多播方式向属于同一个多播组的90个成员传送节目时，视频服务器只需要把视频分组当作多播数据报来发送，并且只需要发送一次。路由器R1在转发分组时需要把收到的分组复制成3个副本，分别向下面路由器各转发一个副本。当分组到达局域网时，由于局域网具有硬件多播的功能，因此不需要复制分组，在局域网上的多播组成员都能收到这个视频分组。在互联网范围的多播要靠路由器来实现，这些里尤其必须则增加一些能够识别多播是数据报的软件。能够运行多播协议的路由器称为多播路由器。多博路由器当然亦可以转发普通的单播IP数据报。使用多播方式部署点到多点应用无重复流量，节省设备与带宽资源，安全性高，有偿性有保障。但由于大部分多播协议是基于UDP(面向非连接的，不可靠的)的，所以多播也是尽力而为的，而且没有拥塞控制机制，还可能会造成报文重复和报文失序。</p><h4 id="多播IP地址"><a href="#多播IP地址" class="headerlink" title="多播IP地址"></a>多播IP地址</h4><p>&emsp;&emsp;在互联网上进行多播就叫做IP多播。IP多播所传送的分组需要使用多播IP地址。显然，这个多播数据报的目的地址一定不能写入这台主机的 IP 地址。这是因为在同一时间可能有成千上万台主机加入到同一个多播组。多播数据报不可能在其首部写入这么多主机的 IP 地址。因此，在多播数据报的目的地址写入的是一个多播组标志符，然后设法让加入到这个多播组的主机的 IP 地址与多播组的标识符关联起来。<br>&emsp;&emsp;实际上多播组的标识符就是 IP 地址中的D类地址。D类地址的前4位是1110，因此D类地址范围为：224.0.0.0 ~ 239.255.255.255。我们使用每一个D类IP地址标识一个多播组。这样，D类地址一共可以标识2^28个多播组，也就是说，在同一时间允许有超过2.6亿的多播组在互联网上运行。多播数据报也是“尽最大努力交付”，不保证一定能够交付多播组内的所有成员。因此，多播数据报与一般的IP数据报的区别就是它使用D类IP地址作为目的地址，并且首部中的协议字段值是2，表明它使用的是网际组管理协议(IGMP)。<br>&emsp;&emsp;显然，多播地址只能用于目的地址，而不能用于源地址。此外，对多播数据报不产生ICMP(网际控制报文协议)差错报文。因此，若在 ping 命令后面键入多播地址，将永远不会收到响应。<br><img src="https://cdn.nafx.top/post_cover/20230315103004.png" alt="多播IP地址"><br>周所周知的部分多播地址。<br><img src="https://cdn.nafx.top/post_cover/20230315110801.png" alt="周所周知的部分多播地址"><br>IP多播常见模型分为ASM模型和SSM模型。<br><img src="https://cdn.nafx.top/post_cover/20230315110322.png" alt="多播模型"></p><h4 id="在局域网上进行硬件多播"><a href="#在局域网上进行硬件多播" class="headerlink" title="在局域网上进行硬件多播"></a>在局域网上进行硬件多播</h4><p>&emsp;&emsp;以太网MAC地址字段中第一字节的最低位为1时即为多播地址，IANA只拿出2^23个地址即01-00-5E-00-00-00到01-00-5E-FF-FF-FF的地址作为以太网多播地址，前25位固定不变只有后23位可用作多播。但D类IP地址可供分配的有28位,这28位中有后23位才映射以太网多播地址中的后23位，因此是多对(32对1)一的映射关系。(后面IP层再判断是否为发往本机的多播帧)<br><img src="https://cdn.nafx.top/post_cover/20230315144834.png" alt="D类IP地址与以太网多播地址的映射关系"></p><h4 id="多播的两种协议"><a href="#多播的两种协议" class="headerlink" title="多播的两种协议"></a>多播的两种协议</h4><p>&emsp;&emsp;连接在局域网上的多播路由器必须和互联网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成员，这就需要<strong>多播路由选择协议</strong>，多播路由选择协议必须在点对点路由选择协议的基础上才能实现。多播转发必须动态适应多播组成员的变化(网络拓补并未发生变化)。多播路由器在转发多播数据报时，不仅仅根据多播数据报中的目的地址，而是还要考虑这个多播数据报从什么地方来和要到什么地方去。多播数据报可由没有加入多播组的主机发出，也可以通过没有组成员接入的网络。<br>&emsp;&emsp;此外接收端本地需要一个协议进行成员的管理，<strong>网际组管理协议IGMP(Internet Group Management Protocol)</strong> 是让链接在本地的局域网上的多播路由器知道本局域网上有否有主机参加或退出了某个多播组。仅在本地网络范围内有效。<br><img src="https://cdn.nafx.top/post_cover/20230315145716.png" alt="多播的两种协议"></p><h5 id="网际组管理协议IGMP"><a href="#网际组管理协议IGMP" class="headerlink" title="网际组管理协议IGMP"></a>网际组管理协议IGMP</h5><p>&emsp;&emsp;和网际控制报文协议ICMP相似，IGMP使用IP数据报传递其报文(即IGMP报文加上IP首部构成IP数据报)，但它也向IP提供服务。因此我们不把IGMP看成是一个单独的协议，而是属于整个网际协议IP的一个组成部分。<br>&emsp;&emsp;IGMP是运行在最后一跳路由器和用户之间的协议。在IP主机和与其直接相邻的多播路由器之间建立、维护多播关系。多播路由器通过IGMP协议了解每个接口连接的网段上是否存在多播接收者，如果有组播路由器将数据报转发到这个网段，否则不转发。</p><p>&emsp;&emsp;从概念上讲， IGMP 的工作可分为两个阶段。</p><ul><li>第一阶段：当某台主机加入新的多播组时，该主机应向多播组的多播地址发送一个IGMP 报文，声明自己要成为该组的成员。本地的多播路由器收到 IGMP 报文后，还要利用多播路由选择协议把这种组成员关系转发给互联网上的其他多播路由器。</li><li>第二阶段：组成员关系是动态的。本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。只要有一台主机对某个组响应，那么多播路由器就认为这个组是活跃的。但一个组在经过几次的探询后仍然没有一台主机响应，多播路由器就认为本网络上的主机已经都离开了这个组，因此也就不再把这个组的成员关系转发给其他的多播路由器。</li></ul><p>&emsp;&emsp;IGMP为了避免了多播控制信息给网络增加大量的开销采用了如下一些具体措施：</p><ol><li>在主机和多播路由器之间的所有通信都是使用 IP 多播。只要有可能，携带 IGMP报文的数据报都用硬件多播来传送。因此在支持硬件多播的网络上，没有参加 IP 多播的主机不会收到 IGMP 报文。</li><li>多播路由器在探询组成员关系时，只需要对所有的组发送一个请求信息的询问报文，而不需要对每一个组发送一个询问报文（虽然也允许对一个特定组发送询问报文）。认的询问速率是每 125 秒发送一次（通信量并不太大）。</li><li>当同一个网络上连接有几个多播路由器时，它们能够迅速和有效地选择其中的一个来探询主机的成员关系。因此，网络上多个多播路由器并不会引起 IGMP 通信量的增大。</li><li>在 IGMP 的询问报文中有一个数值 N，它指明一个最长响应时间（默认值为 10秒）。当收到询问时，主机在 0 到 N 之间随机选择发送响应所需经过的时延。因此，若一台主机同时参加了几个多播组，则主机对每一个多播组选择不同的随机数。对应于最小时延的响应最先发送。</li><li>同一个组内的每一台主机都要监听响应，只要有本组的其他主机先发送了响应，自己就可以不再发送响应了。这样就抑制了不必要的通信量。</li></ol><h5 id="多播路由选择协议"><a href="#多播路由选择协议" class="headerlink" title="多播路由选择协议"></a>多播路由选择协议</h5><p>&emsp;&emsp;虽然在TCP/IP中IP多播协议已成为建议标准，但多播路由选择协议（用来在多播路由器之间传播路由信息）尚未标准化。多播路由选择实际上就是管理和维护多播路由，建立从源到多个接收端的无环数据传输路径，构建多播分发树。<br><img src="https://cdn.nafx.top/post_cover/20230317091755.png" alt="多播路由选择协议"><br>域内使用的多播路由选择协议:</p><ul><li>协议无关多播-密集模式协议 PIM-DIM(Protocol Independent Multicast-Dense Mode)<br>适用于组成员的分布非常集中的情况，不使用核心路由器而是用洪泛方式转发数据报。采用Push方式，假设网络的每个子网至少有一个组播接收点，信息扩散至所有节点，采用扩散、剪枝和嫁接来维护多播分发树(SPT)。</li><li>协议无关多播-系数模式协议 PIM-SM(Protocol Independent Multicast-Sparse Mode)<br>适用于组成员非常分散、大规模网络的情况。采用Pull方式，多播信息被拉入网络中的接收点。假设多播数据不被需求，除非又加入申请，否则不会传播给接收者。</li><li>链路状态协议 MOSPF(Multicast extensions to OSPF)<br>是单播路由选择协议OSPF的一个扩充，适用于一个机构内。MOSPF使用多播链路状态路由选择创建出基于源点的多播转发树。</li></ul><h5 id="反向路径广播-RPB"><a href="#反向路径广播-RPB" class="headerlink" title="反向路径广播 RPB"></a>反向路径广播 RPB</h5><p>&emsp;&emsp;适用于组成员密集的情况，一开始路由器转发多播数据报使用洪泛的方法(广播)，为了避免兜圈子，采用了反向路径广播 RPB(Reverse Path Broadcasting)的策略。RPB的要点是没一个路由器收到一个多播数据报时先检查数据报是否是从源点经最路径传送来的。进行这种检查很容易，只要从本路由器寻找到源点的最短路径上（之所以叫做反向路径，因为在计算最短路径时是把源点当作终点）的第一个路由器是否就是刚才把多播数据报送来的路由器。若是，就向所有其他方向转发刚才收到的多播数据报（但进入的方向除外），否则就丢弃而不转发。如果本路由器有好几个相邻路由器都处在到源点的最短路径上（也就是说，存在几条同样长度的最短路径），那么只能选择一条最短路径，选择的准则就是看这几条最短路径中的相邻路由器谁的 IP 地址最小。<br><img src="https://cdn.nafx.top/post_cover/20230317094105.png" alt="反向路径广播和剪除"><br>&emsp;&emsp;如果在多播转发树上的某个路由器发现它的下游树枝（即叶节点方向）已没有该多播组的成员，就应把它和下游的树枝一起剪除。例如，在图中虚线椭圆表示剪除的部分。当某个树枝有新增加的组成员时，可以再接入到多播转发树上。</p><h5 id="隧道技术-tunneling"><a href="#隧道技术-tunneling" class="headerlink" title="隧道技术 tunneling"></a>隧道技术 tunneling</h5><p>&emsp;&emsp;隧道技术适用于多播组的位置在地理上很分散的情况。例如在下图中，网 1 和网 2 都支持多播。现在网 1 中的主机向网 2 中的一些主机进行多播。但路由器 R1 和 R2 之间的网络并不支持多播，因而 R1 和 R2 不能按多播地址转发数据报。为此，路由器 R1 就对多播数据报进行再次封装，即再加上普通数据报首部，使之成为向单一目的站发送的单播(unicast)数据报，然后通过“隧道” (tunnel)从 R1 发送到 R2。<br><img src="https://cdn.nafx.top/post_cover/20230317095316.png" alt="隧道技术在多播中的应用"><br>&emsp;&emsp;单播数据报到达路由器 R2 后，再由路由器 R2 剥去其首部，使它又恢复成原来的多播数据报，继续向多个目的站转发。这一点和英吉利海峡隧道运送汽车的情况相似。英吉利海峡隧道不允许汽车在隧道中行驶。但是，可以把汽车放置在隧道中行驶的电气火车上来通过隧道。过了隧道后，汽车又可以继续在公路上行驶。这种使用隧道技术传送数据报又叫做 IP中的 IP (IP-in-IP)。</p><h5 id="基于核心的发现技术"><a href="#基于核心的发现技术" class="headerlink" title="基于核心的发现技术"></a>基于核心的发现技术</h5><p>&emsp;&emsp;这种方法对于多播组的大小在较大范围内变化时都适合。这种方法是对每一个多播组 G 指定一个核心(core)路由器，给出它的 IP 单播地址。核心路由器按照前面讲过的方法创建出对应于多播组 G 的转发树。如果有一个路由器 R1 向这个核心路由器发送数据报，那么它在途中经过的每一个路由器都要检查其内容。当数据报到达参加了多播组 G 的路由器 R2 时， R2 就处理这个数据报。如果 R1 发出的是一个多播数据报，其目的地址是 G 的组地址， R2 就向多播组 G 的成员转发这个多播数据报。如果 R1 发出的数据报是一个请求加入多播组 G 的数据报， R2 就把这个信息加到它的路由中，并用隧道技术向R1 转发每一个多播数据报的一个副本。这样，参加到多播组 G 的路由器就从核心向外增多了，扩大了多播转发树的覆盖范围。</p><h3 id="虚拟专用网-VPN"><a href="#虚拟专用网-VPN" class="headerlink" title="虚拟专用网 VPN"></a>虚拟专用网 VPN</h3><h4 id="私有IP地址"><a href="#私有IP地址" class="headerlink" title="私有IP地址"></a>私有IP地址</h4><p>&emsp;&emsp;由于IP地址的紧缺，一个机构能申请到的IP地址往往小于机构所拥有的主机。而且考虑到互联网并不安全，一个机构内并不需要把所有的主机介入到外部互联网，在许多情况下，还是和本机构内其他主机通信。假定在机构内的计算机通信也采用TCP/IP协议，那么在机构内就可以由本机构自行分配仅在本机构内有效的IP地址(本地地址)。<br>&emsp;&emsp;为结局这一问题RFC1918指明了一些<code>专用地址(private address)</code>，这些地址只能用于机构内部通信。在互联网中的所有路由器对目的地址是专用地址的数据报一律并不进行转发。<br><img src="https://cdn.nafx.top/post_cover/20230318164009.png" alt="本地地址"><br>采用这样的专用IP地址的互连网络称为<strong>专用互联网</strong>或<strong>本地互联网</strong>或简称为<strong>专用网</strong>。专用IP地址也叫做可重用地址(reusable address)。但有时一个很大的机构有许多部门分布范围很广(在世界各地)，而在每一个地点都有自己的专用网。假定这些分布在不同地点的专用网需要经常进行通信。这时，可以有两种方法：<br>（1）第一种方法是租用电信公司的通信线路为本机构专用。这种方法的好处是简单方便，但线路的租金太高。<br>（2）第二种方法是利用公用的因特网作为本机构各专用网之间的通信载体，这样的专用网又称为虚拟专用网<code>VPN (Virtual PrivateNetwork)</code>。<br>&emsp;&emsp;之所以称为“专用网”是因为这种网络是为本机构的主机用于机构内部的通信，而不是用于和网络外非本机构的主机通信。如果专用网不同网点之间的通信必须经过公用的因特网，但又有保密的要求，<strong>那么所有通过因特网传送的数据都必须加密</strong>。“虚拟”表示“好像是”，但实际上并不是，因为现在并没有使用专线，而VPN只是在效果上和真正的专用网一样。专用表示用户可以定制最符合自身需求的网络，用于内部通信，一个机构要构建自己的VPN就必须为它的每一个场所购买专门的硬件和软件，并进行配置，使每一个场所的VPN系统都知道其他场所的地址。一般使用IP隧道技术实现虚拟专用网。<br><img src="https://cdn.nafx.top/post_cover/20230319143142.png" alt="隧道技术实现虚拟专用网"><br>&emsp;&emsp;在隧道的两端通过封装以及解封装技术在公网上建立一条数据通道，使用这条数据通道对数据进行传输。隧道是由隧道协议构建形成的。<br><img src="https://cdn.nafx.top/post_cover/20230322122826.png" alt="常用隧道协议"><br>&emsp;&emsp;由同一机构内部网络所构成的虚拟专用网VPN又称为**内联网(intranet)<strong>，有时一个机构的VPN需要有些些外部结构参加进来这样的VPN就称为</strong>外联网(extranet)<strong>。内联网和外联网都采用了互联网技术，即都是基于TCP/IP协议的。还有一种类型的VPN就是个人对机构的</strong>远程接入VPN(remote access VPN)**，主要解决员工外地办公问题。<br><img src="https://cdn.nafx.top/post_cover/20230319144814.png" alt="远程接入VPN"></p><h3 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h3><h4 id="什么是NAT"><a href="#什么是NAT" class="headerlink" title="什么是NAT"></a>什么是NAT</h4><p>&emsp;&emsp;在专用网上使用专用地址的主机如果想要和互联网上的主机通信(不需要加密)，因为很难申请到全球IP地址，所以采用<strong>网络地址转换NAT(Nets Address Translation)</strong> 。NAT是指通过专用网络地址转换为公用地址，从而对外隐藏内部管理的IP地址，它使得整个专用网只需要一个全球IP就可以访问互联网，由于专用网IP地址是可以重用的，所以NAT大大节省了IP地址的消耗。此方法是1994年提出的，这种方法需要在专用网（私网IP）连接到因特网（公网IP）的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址（公网IP地址）。这样，所有使用本地地址（私网IP地址）的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和因特网连接。</p><h4 id="NAT工作过程"><a href="#NAT工作过程" class="headerlink" title="NAT工作过程"></a>NAT工作过程</h4><p>&emsp;&emsp;内部主机与外部主机通信时，在NAT路由器上发生了两次地址转换。离开专用网时，替换源地址，将内部地址替换为全球地址。进入专用网时替换目的地址，将全球地址替换为内部地址。<br><img src="https://cdn.nafx.top/post_cover/20230322160737.png" alt="NAT工作过程"></p><h5 id="多对多方式"><a href="#多对多方式" class="headerlink" title="多对多方式"></a>多对多方式</h5><p>&emsp;&emsp;当NAT路由器具有N个全球IP地址时，专用网内最多可以同时有N台主机接入到互联网。这样就可以使专用网内较多的数量的主机轮流使用NAT路由器有限数量的全球IP地址。通过NAT路由器的通信必须由专用网内的主机发起，专用网内部的主机不能充当服务器。</p><h5 id="一对多方式"><a href="#一对多方式" class="headerlink" title="一对多方式"></a>一对多方式</h5><p>&emsp;&emsp;为了有效利用NAT路由器上的全球IP地址，常用的NAT转换表常利用运输层的端口号。多个拥有本地地址的主机公用NAT路由器上的一个全球IP地址，使用端口号的NAT叫做<strong>网络地址与端口号转换 NAPT(Network Address and Port Translation)</strong> 相对的不适用端口号的NAT就叫做传统NAT。<br><img src="https://cdn.nafx.top/post_cover/20230322161757.png" alt="网络地址与端口号转换"></p><h5 id="静态NAT"><a href="#静态NAT" class="headerlink" title="静态NAT"></a>静态NAT</h5><p>&emsp;&emsp;为内网某台服务器指定一个固定转换的公网IP(一对一的)。对节约公网IP没有太大意义，外面主机可以使用这个共有IP访问服务器资源。</p><h3 id="多协议标签交换-MPLS"><a href="#多协议标签交换-MPLS" class="headerlink" title="多协议标签交换 MPLS"></a>多协议标签交换 MPLS</h3><p>&emsp;&emsp;三层转发(forwarding)过程:需要解封装，获取三层地址(软件实现，速度慢)，根据目的IP地址查找路由表并获取下一跳硬件地址，封装成帧后发送至下一跳(硬件实现速度快)流量工程方面有缺陷。而二层交换(switch)直接用硬件转发，速度快。<strong>多协议标签交换 MPLS(MultiProtocol Lable Switching)</strong> 技术就是使用二层技术实现三层数据报的交换，来提高路由器分组转发速度。</p><h4 id="MPLS原理"><a href="#MPLS原理" class="headerlink" title="MPLS原理"></a>MPLS原理</h4><p>&emsp;&emsp;MPLS就是在MPLS域的入口处给每一个IP数据报打上固定长度的标签，然后对打上标签的IP数据报用硬件进行转发，称为标签交换。这样在转发时就不需要上升到第三层查找转发表，而是根据标签在第二层(数据链路层)用硬件进行转发。MPLS可使用多种链路层协议，如PPP、以太网、ATM、帧中继等。<br><img src="https://cdn.nafx.top/post_cover/20230322174621.png" alt="MPLS协议基本原理"><br>&emsp;&emsp;MPLS域(MPLS domain)是指该域中有许多彼此相邻的路由器，且所有的路由器都是支持MPLS技术的**标签交换路由器LSR(Label Switching Router)**。LSR同时具有标签交换和路由选择这两种功能，标签交换是为了快速转发，但在这之前LSR需要使用路由选择共呢个构造转发表。</p><h4 id="MPLS基本工作过程"><a href="#MPLS基本工作过程" class="headerlink" title="MPLS基本工作过程"></a>MPLS基本工作过程</h4><ul><li>首先采用<strong>标签分配协议LDP(Label Distribution Protocol)</strong> 交换报文，生成<strong>标签交换路径LSP(Label Switched Path)(单向)</strong> 。</li><li>当IP数据报进入<strong>MPLS域</strong> 时，<strong>MPLS入口节点(ingress node)</strong> 给它打上标签(实际就是插入一个MPLS首部)，并按照转发表把它转发给下一个LSR。给IP数据报打标签的过程叫做分类，严格的<strong>第三层(网络层)分类</strong> 只是用了IP首部中的字段，如源IP地址和目的IP地址等。大多数运营商实现了<strong>第四层(运输层)分类</strong> ，除了检查IP首部外还要检查TCP或UDP首部中的协议端口号。还有些运营商则实现了第五层(应用层)分类，更进一步地检查数据报的内部并考虑其有效载荷。</li><li>分组每经过一个LSR，LSR就要做两件事，一是转发;二是更换新的标签，即把如标签更换为出标签，这叫做标签对换(label swapping)。标签仅在两个LSR路由器之间才有意义。</li><li>当IP数据报离开MPLS域时，MPLS出口节点把MPLS的标签去除，并将IP数据报交付给非MPLS的主机或路由器，以后就按照普通方法发进行转发。</li></ul><p>注意，MPLS需依赖IGP协议(OSPF、RIP等)。</p><h4 id="MPLS结构"><a href="#MPLS结构" class="headerlink" title="MPLS结构"></a>MPLS结构</h4><p><img src="https://cdn.nafx.top/post_cover/20230323094408.png" alt="MPLS结构"></p><h4 id="转发等价类-FEC"><a href="#转发等价类-FEC" class="headerlink" title="转发等价类 FEC"></a>转发等价类 FEC</h4><p>&emsp;&emsp;MPLS有个很重要的概念就是<strong>转发等价类 FEC(Forwarding Equivalence Class)</strong> ，所谓FEC就是路由器按照同样的方式对待IP数据报的集合。按照同样方式对待表示从同样接口转发到同样的下一跳地址，并且具有同样服务类别和同样丢弃优先级等。划分FEC的方法不受什么限制，都是由网络管理员来控制。属于同样的FEC的IP数据报都指派同样的标签，FEC和标签是一一对应的关系。<br>FEC的例子: 目的IP地址与某一个特定IP地址的前缀匹配的IP数据报、所有源地址和目的地址都相同的IP数据报、具有某种服务质量需求的IP数据报。<br>网络管理员采用自定义的FEC就可以更好的管理网络资源。这种负载均衡的做法也称为<strong>流量工程 TE(Traffic Engineering)</strong> 或<strong>通信量工程</strong>。</p><h4 id="MPLS报文格式"><a href="#MPLS报文格式" class="headerlink" title="MPLS报文格式"></a>MPLS报文格式</h4><p>&emsp;&emsp;从层次的角度看，MPLS首部处于第二层和第三层之间。 给IP数据报打上标签实际上就是在以太网帧的首部和IP数据报的首部之间插入4字节的MPLS首部(可插入多个标签)。<br><img src="https://cdn.nafx.top/post_cover/MPLS%E9%A6%96%E9%83%A8.png" alt="MPLS报文格式"><br>MPLS首部一共包括以下四个字段32bit:</p><ul><li>标签 占20位，因此理论上讲最多可以有2^20个标签也就是说可以最多容纳2^20个流(即1048576个流)。</li><li>实验 占3位，目前保留用于实验Qos。</li><li>BOS栈底位 占1位，S(Stack)表示栈，可以给一个分组压多层标签，最后一个标签的BOS位置1，当处理到这层，分组则为普通的IP数据报分组。</li><li>生存时间TTL 占8位，最大255，通常在加标签时直接复制普通IP分组中的TTL，用来防止MPLS分组在MPLS域中兜圈子。</li></ul><h4 id="多层标签"><a href="#多层标签" class="headerlink" title="多层标签"></a>多层标签</h4><p><img src="https://cdn.nafx.top/post_cover/20230323102643.png" alt="MPLS多层标签"></p><h3 id="软件定义网络-SDN"><a href="#软件定义网络-SDN" class="headerlink" title="软件定义网络 SDN"></a>软件定义网络 SDN</h3><p>&emsp;&emsp;相对稳定的网络架构设计及系统运维难以应对日益多变的网络应用与业务，上层应用需要在规模扩展、服务能力上要求更大的灵活性，难以以客户为中心的引用服务。<br><img src="https://cdn.nafx.top/post_cover/20230323105852.png" alt="软件定义网络SDN"><br><img src="https://cdn.nafx.top/post_cover/20230323110043.png" alt="SDN网络架构"></p>]]></content>
      
      
      <categories>
          
          <category> 学记笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络体系结构（三）</title>
      <link href="/archives/7f57db73.html"/>
      <url>/archives/7f57db73.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据链路层（data-link-layer）"><a href="#数据链路层（data-link-layer）" class="headerlink" title="数据链路层（data link layer）"></a>数据链路层（data link layer）</h2><p>数据链路层使用的信道主要有以下两种类型:</p><h3 id="点对点信道的数据链路层"><a href="#点对点信道的数据链路层" class="headerlink" title="点对点信道的数据链路层"></a>点对点信道的数据链路层</h3><p>&emsp;&emsp;这种信道使用一对一的通信方式，最常用的协议就是<code>点对点协议 PPP(Point to Point Protocol)</code>。在通信线路质量较差的年代，在数据链路层使用必须使用可靠的传输协议，比如思科私有协议<code>高级数据链路控制 HDLC(High-level Data Link Control)</code>在当时就比较流行。而随着通信线路质量的提升，对于点对点通信的链路简单的PPP协议就是更好的选择了。现在互联网的数据链路层使用的最多的就是<code>PPP协议</code>和<code>CSMA/CD协议</code>(也就是使用拨号入网或者使用以太网入网)。</p><p><img src="https://cdn.nafx.top/post_cover/20221013184043.png" alt="用户到ISP的链路使用PPP协议"></p><h4 id="PPP-协议应满足的需求"><a href="#PPP-协议应满足的需求" class="headerlink" title="PPP 协议应满足的需求"></a>PPP 协议应满足的需求</h4><ul><li>简单 国际互联网工程任务组（The Internet Engineering Task Force，简称 IETF）在设计互联网体系结构时把其中最复杂的部分放在TCP协议中，而网际协议IP则相对简单提供不可靠的数据报服务，这种情况下数据链路层没有必要提供比IP协议更多的功能，因此简单首要的要求。总之接收方每收到一个帧就进行CRC校验，如果正确就收下这个帧，反之就丢弃这个帧，其他什么也不做。</li><li>封装成帧 必须规定特殊的字符作为帧定界符，以便接收端从收到的比特流中能准确的找出帧的开始和结束位置。</li><li>透明性 必须保证数据传输的透明性，也就是说如果数据中碰巧出现和帧定界符一样的比特组合要采取有效措施解决,不管什么形式的比特组合都必须能正确传送。</li><li>多种网络层协议 必须能够在同一条物理链路上同时支持多种网络层协议（如IP和IPX等）的运行。</li><li>多种类型链路 能够在多种类型的链路上运行，例如串行的或并行的、同步的或异步的、低速的或高速的、电或者光通信、交换的（动态的）和非交换的（静态的）点对点链路。</li><li>差错检测(CRC) 必须能够对接收方收到的帧进行检测，并立即丢弃有差错的帧。在链路层进行差错检测不是为了保证可靠传输，而是防止已出现差错的无用帧浪费网络资源。</li><li>检测连接状态 能够及时（不超过几分钟）检测出一条链路是处于正常工作状态，还是已经出了故障。</li><li>最大传送单元 必须对每一种类型的点对点链路设置MTU的标准默认值，这样做是为了促进各种实现间的互操作性，如果高层协议发送的分组过长超过MTU的数值，PPP就要丢弃这样的帧，并返回差错。需要强调的是MTU是数据链路层可以载荷的<code>数据部分</code>的的最大长度，而不是帧的总长度。</li><li>网络层地址协商 PPP协议必须提供一种机制使通信的两纥网络层（例如两个IP层）的实体能够通过协商知道或能配置彼此的网络层地址。</li><li>数据压缩协商</li></ul><p>在TCP/IP协议簇中，可靠传输由运输层的TCP协议负责，因此数据链路层的PPP协议不需要纠错，不需要设置序号，也不需要进行流量控制。PPP协议不支持多点线路，只支持点对点的链路通信，此外PPP协议只支持全双工链路。</p><h4 id="PPP协议的组成"><a href="#PPP协议的组成" class="headerlink" title="PPP协议的组成"></a>PPP协议的组成</h4><p>PPP协议有三个组成部分：</p><ul><li><p>封装方法 PPP协议要包含一个将IP数据报封装成串行链路的方法。既要支持异步链路（无奇偶校验的8比特数据），也要支持面向比特的同步链路。IP数据报在PPP帧中就是其信息部分，这个信息部分的长度受最大传送单元MTU的限制。</p></li><li><p>链路控制协议（LCP，Link Control Protocol）用来定义建立、配置和测试数据链路链接的协议。通信双方可以协商一些选项。</p></li><li><p>网络控制协议（NCP，Network Control Protocol）PPP包含了一套NCP，每个NCP协议支持不同的网络层协议，例如IP、OSI的网络层、DECnet、AppleTalk等，实现向上兼容。</p></li></ul><h4 id="PPP协议的帧格式"><a href="#PPP协议的帧格式" class="headerlink" title="PPP协议的帧格式"></a>PPP协议的帧格式</h4><p><img src="https://cdn.nafx.top/post_cover/20200508180628772.webp" alt="PPP协议的帧格式"><br>PPP帧的首部和尾部分别为四个字段和两个字段。<br>F字段：标志字段，规定为0x7E（十六进制下的7E），二进制表示为01111110，表示PPP数据帧的开始和结束。<br>A字段：规定为0xFF，二进制表示为11111111，没有任何意义，预留使用。<br>C字段：规定为0x03，二进制表示为00000011，没有任何意义，预留使用。<br>协议字段：<br>0x0021：信息字段为IP数据报。<br>0xC021：信息字段为PPP链路控制数据 LCP。<br>0x8021：信息字段为网络控制数据 NCP。<br>信息字段：长度可变，但不超过 1500 字节。<br>FCS字段：2 个字节，使用 CRC 的帧检验序列。</p><p>如果在信息字段中出现和标志字段一样的比特组合时（0x7E-F字段），就需要采取一些措施使像标志字段一样的比特组合不能出现在信息字段中，一般有异步传输和同步传输两种方法：</p><ul><li>异步传输：字节填充<br>对信息字段内出现标志字段的组合时，使用转义字符(0x7D)进行字节填充。<br>(0x7E) -&gt; (0x7D,0x5E)<br>(0x7D) -&gt; (0x7D,0x5D)<br>ASCII码的控制字符，即数值小于(0x20)的字符，在字符前前增加0x7D，并对该字符的编码加以改变。如：<br>(0x03) -&gt; (0x7D,0x23)<br>由于在发送端进行了字节填充，因此链路上传送的信息字节数就超过了原来的信息字节数，接收端在收到数据后再进行与发送端字节填充相反的变换就可以正确地恢复出原来信息。</li><li>同步传输：零比特填充<br>PPP协议在用SONET/SDH链路时使用同步传输，这种情况下使用零比特填充的方法实现透明传输(通常硬件实现，但也可以软件实现，只是会慢些)<br>在发送端，同步传输通过硬件或者软件扫描整个信息字段。对于五个连续的1，在后面填入一个0，避免六个连续的1的出现。在接收端，先找到标志字段 F 以确定一个帧的边界，再用硬件扫描整个信息字段，每当发现 5 个连续 1 时，就把这 5 个连续 1 后的一个 0 删除，以还原成原来的信息比特流。<br><img src="https://cdn.nafx.top/post_cover/20200508181445894.webp" alt="零比特填充"></li></ul><h4 id="PPP协议的工作状态"><a href="#PPP协议的工作状态" class="headerlink" title="PPP协议的工作状态"></a>PPP协议的工作状态</h4><ul><li>用户拨号接入 ISP 后，就建立了一条从<code>用户PC</code>到<code>ISP</code>的<strong>物理连接</strong>。</li><li>用户PC向ISP发送一系列的链路控制协议<code>LCP分组（封装成多个 PPP 帧）</code>。</li><li>LCP连接鉴别成功后这些分组及其响应选择了将要使用的一些 PPP 参数进行NCP配置协商，网络控制协议<code>NCP</code>给新接入的用户PC分配一个临时IP，建立<code>NCP链路</code>，可以开始通信,使PC机称为因特网上的一个主机。</li><li>用户通信完毕，NCP 释放<code>网络层连接</code>，收回临时IP。然后LCP释放<code>数据链路层连接</code>。最后释放<code>物理层连接</code>。</li></ul><p>由上可见，从设备无链路开始，到先建立物理链路，再建立链路控制协议 LCP 链路，经过鉴别后再建立网络控制协议NCP链路，然后才能交换数据<br>PPP不再是纯粹的<code>数据链路层</code>协议，还包含了<code>物理层</code>和<code>网络层</code>的内容。</p><p><img src="https://cdn.nafx.top/post_cover/PPP%E5%8D%8F%E8%AE%AE%E7%8A%B6%E6%80%81%E5%9B%BE.png" alt="PPP协议状态图"></p><h4 id="PPP协议的应用"><a href="#PPP协议的应用" class="headerlink" title="PPP协议的应用"></a>PPP协议的应用</h4><p>家庭拨号上网就是通过PPP在用户端和运营商的接入服务器之间建立通信链路。目前，宽带接入正在成为取代拨号上网的趋势，在宽带接入技术日新月异的今天，PPP也衍生出新的应用。典型的应用是在ADSL接入方式当中，PPP与其他的协议共同派生出了符合宽带接入要求的新的协议，如PPPoE（PPP over Ethernet），PPPoA（PPP over ATM）。</p><h3 id="广播信道的数据链路层"><a href="#广播信道的数据链路层" class="headerlink" title="广播信道的数据链路层"></a>广播信道的数据链路层</h3><p>&emsp;&emsp;这种信道使用一对多的广播通信方式，广播信道上连接的主机很多必须使用专用的共享通信协议来协调这些主机的数据发送，局域网技术使用的就是广播信道，可以从一个站点可很方便地访问全网，局域网上的主机可共享连接局域网上的各种硬件和软件资源。而且局域网技术便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。提高了系统的可靠性、可用性和生存性。局域网技术在计算机网络中占有非常重要的地位。<br>局域网的主要优点：</p><ol><li>具有广播功能，从一个站点可以很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源</li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变</li><li>提高了系统的可靠性，可用性和生存性</li></ol><p>&emsp;&emsp;共享信道要着重考虑的一个问题是如何使众多用户能合理而方便的共享通信媒体资源。若多个设备在共享的广播信道上同时发送数据，则会造成彼此干扰，导致发送失败。在技术上有两种解决方法：</p><ul><li><p>静态划分信道<br>频分复用，时分复用，波分复用，码分复用等。用户只要分配到了信道就不会和其他用户发生冲突，但划分信道的方法代价较高，不适合局域网使用。</p></li><li><p>动态媒体接入控制（多点接入）<br>随机接入（主要被以太网采用CSMA/CD）<br>受控接入，如多点线路探寻，或轮询（如<code>令牌环</code>目前已不被采用）</p></li></ul><h4 id="以太网（Ethernet）"><a href="#以太网（Ethernet）" class="headerlink" title="以太网（Ethernet）"></a>以太网（Ethernet）</h4><p>&emsp;&emsp;以太网是应用最广泛的局域网通讯方式，同时也是一种协议，取代了其他局域网技术如<code>令牌环</code>、<code>FDDI</code>和<code>ARCNET</code>。以太网协议定义了一系列软件和硬件标准，从而将不同的计算机设备连接在一起。以太网设备组网的基本元素有交换机、路由器、集线器、光纤和普通网线以及以太网协议和通讯规则。</p><h5 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h5><blockquote><p>来源参考自 Ethernet: The Definitive Guide (O’Reilly Media, 2014) 、计算机网络（第6版）谢希仁和相关百科。</p></blockquote><p>&emsp;&emsp;1972年末在哈佛大学获得博士学位的Bob Metcalfe毕业后前往美国施乐(Xerox)公司的Palo Alto研究中心工作，当他到研究中心时看到那里的研究人员已经设计并建造出后来称为个人计算机的机器，但这些机器都是孤零零的，他便运用帮助Abramson工作获得的知识与同事David Boggs 设计并实现了第一个局域网。也就是以太网的原型，在当时被称为<code>Alto Aloha Network</code>，该网络将实验中心的服务器激光打印机等设备连接在了一起，网络接口的信号时钟来自Alto的系统时钟，并使用无源电缆作为总线传送数据帧，当时的局域网数据传输速率达到了 2.94 Mb/s。<br>&emsp;&emsp;1973年Metcalfe 将名称改为<code>以太网(Ethernet)</code>，意在明确指出不只是研究中心的Altos该系统可以支持任何计算机，并且性能远超世界上第一个无线资料网络ALOHA系统，并选择曾在历史上亚里士多德假想的传播电磁波的物质以太(Ether)来命名。<br>&emsp;&emsp;1976年Metcalfe和Boggs发表了他们的以太网里程碑论文[METC76],直到1980年9月DEC公司、英特尔(Intel)公司和施乐(Xerox)公司联合提出了10 Mb/s以太网规约的第一个版本 <code>DIX V1</code>(DIX是三个公司名称的缩写)。1982年又修改为第二版规约也就是最后的版本，即<code>DIX Ethernet V2</code>,并将其提交给<code>IEEE 802</code>工作组,成为世界上第一个局域网产品的规约。<br>&emsp;&emsp;1983年经IEEEE成员修改并通过后，IEEE 802委员会的802.3工作组制定了第一个IEEE的以太网标准 <code>IEEE 802.3[W-IEEE802.3]</code>成为了正式标准，虽然Ethernet规范和IEEE 802.3规范并不完全相同有很小的差别，但一般认为Ethernet和正IEEE 802.3是兼容的。但在当时有关厂商在商业上的激烈竞争，IEEE 802委员会并未形成一个统一的“最佳的”局域网标准，而是被迫制定了几个不同的局域网标准，如<code>IEEE 802.4令牌总线网(Token-Bus)</code>和<code>IEEE 802.5令牌环网(Token-Ring)</code>等。为了使数据链路层能更好地适应多种局域网标准，802委员会就将局域网的数据链路层拆成两个子层：</p><ul><li>逻辑链路控制LLC（Logical Link Control） 子层</li><li>媒体接入控制MAC（Medium Access Control ）子层<br><img src="https://cdn.nafx.top/post_cover/20221013144352.png" alt="局域网对LLC子层使透明的"><br>与接入到传输媒体有关的内容都放在<code>MAC子层</code>，而<code>LLC子层</code>与传输媒体无关。<br>&emsp;&emsp;到了20世纪90年底啊后，以太网在局域网市场中已取得了垄断地位，并且几乎成为了局域网的代名词。由于TCP/IP体系经常使用的局域网是DIX Ethernet V2而不是802.3标准中的几种局域网，因此现在802委员会制定的逻辑链路子层LLC（即802.2标准）的作用已经不大了，后面很多厂商生产的网络适配器上就仅装有MAC协议而没有LLC协议。</li></ul><h5 id="简化通信的两种措施"><a href="#简化通信的两种措施" class="headerlink" title="简化通信的两种措施"></a>简化通信的两种措施</h5><p>为了通信的简便，以太网采取了两种重要的措施：</p><ol><li>第一是采用较为灵活的<code>无连接</code>的工作方式，即不必建立连接就可以直接发送数据，适配器对发送的数据帧<code>不进行编号，也不要求对方发回确认</code>。这样做可以使以太网工作起来非常简单，而局域网信道的质量很好，因通信质量不好产生差错的概率是很小的。因此，<code>以太网提供的服务是尽最大努力的交付</code>，即<code>不可靠的交付</code>。当目的站收到有差错的帧（例如CRC查出差错），就把帧抛弃，其他什么也不做。对有差错的帧是否需要重传则由高层决定。例如，如果高层使用TCP协议，那么TCP就会发现丢失了一些数据。于是经过一定时间后，TCP就把这些数据重新给以太网进行重传。但以太网并不知道这是帧重传，而是当做新的数据帧来发送。</li><li>第二是以太网发送的数据都使用曼彻斯特（Manchester）编码的信号，我们知道，二进制基带数字信号通常就是高低电压交替出现的信号，使用这种信号的最大问题就是当出现一长串的连1或者连0时，接收端就无法从收到的比特流中提取比特同步信号，而曼彻斯特编码方法就是把每一个码元再分成两个相等的间隔。码元1是在前一个间隔为低电压而后一个为高电压，码元0正相反（也可采用相反的约定），但是曼彻斯特编码也有缺点，就是所占的频带宽度比原始的基带信号增加了一倍（每秒传送的码元数加倍了）<br><img src="https://cdn.nafx.top/post_cover/20221014223923.png" alt="曼彻斯特（Manchester）编码"></li></ol><h5 id="计算机如何连接到局域网"><a href="#计算机如何连接到局域网" class="headerlink" title="计算机如何连接到局域网"></a>计算机如何连接到局域网</h5><p>&emsp;&emsp;计算机与外界局域网的连接是通过<code>通信适配器(adapter)</code>，适配器包含了数据链路层和物理层两层的功能，原本适配器本来是插在主板上的一块网络接口板，这种接口板又称为<code>网络接口卡NIC(Network Interface Card)</code>或简称为<code>网卡</code>。由于现在计算机主板上都已经嵌入了这种适配器，已经不再使用单独的网卡了（除非主板集成的网卡不满足使用需求加装PEIE等接口的扩展网卡），因此多使用适配器这个更准确的术语。<br>&emsp;&emsp;适配器上装有处理器和储存器(包括RAM和ROM)。适配器和局域网之间的通信是通过电缆或者双绞线以串行的方式进行的，而适配器和计算机之间通信则是通过计算机主板上的I/O总线以并行方式进行的。因此适配器的一个重要功能就是<code>进行数据串行传输和并行传输的转换</code>。还由于网络上的数据率和计算机总线上的数据率不同，因此适配器中还必须有<code>对数据进行缓存</code>的存储芯片。在主板上插入适配器后还应该<code>把该适配器的驱动程序安装在计算机的操作系统</code>中，驱动程序会告诉适配器从存储器上的什么位置把多长的数据块发送到局域网，或者应当在存储器的什么位置上把局域送过来的数据块存储下来。另外适配器还要<code>实现以太网的协议</code>。<br>&emsp;&emsp;适配器接收和发送各种帧时不使用计算机的CPU，这时CPU可以处理其他任务，如果接收到了有差错的帧，那么直接丢弃；如果接收到了正确的帧，那么会通过中断通知CPU，并交付协议栈中的网络层。当计算机发送IP数据报时，就由协议栈把IP数据报交给适配器封装成帧，然后发送到局域网中。<br><img src="https://cdn.nafx.top/post_cover/20221013160929.png" alt="计算机通过适配器和局域网进行通信"></p><blockquote><p>这里要注意计算机的硬件地址(MAC地址)就在适配器的ROM中，而计算机的软件地址(IP地址)在计算机的存储器中。</p></blockquote><p>&emsp;&emsp;局域网中<code>硬件地址</code>又称<code>物理地址</code>或<code>MAC地址</code>(因为这种地址用在MAC帧中)。<code>IEEE 802标准</code>为局域网规定了一种48位的全球标识符，就是写在在<code>通信适配器(网卡)</code>的<code>ROM</code>中的地址,严格来说应该叫局域网中每个站的”名字”或标识符，如果局域网上的主机或者路由器安装有多个适配器，那这样的主机就有多个”地址”，这种48位的”地址”应当是每个接口的标识符。<br>&emsp;&emsp;最早在指定局域网地址标准时为了减少不必要的开销人们觉得用两个字节(16位)表示地址就够了，但是由于局域网的飞速发展很快16位就不够了，于是IEEE 802规定MAC地址段可采用6字节(48位)或2字节(16位)这两种中的一种，现在IEEE的注册管理机构RA(Registration Authority)是局域网全球地址的法定管理机构，负责向厂家分配地址字段的前三个字节（即高位24位），凡事要生产局域网适配器的厂家都必须向IEEE购买这三个字节构成的<code>组织唯一标识符OUI(Organizationally Unique Identifier)</code>，通常也叫做公司标识符。地址字段中的后三个字节（地位24位）由厂家自行指派，称为<code>扩展标识符(Extended Identifier)</code>，必须保证生产出的适配器没有重复地址。一个地址块可以生成2^24个不同的地址。这种48位地址称为<code>MAC-48</code>，它的通用名称是<code>EUI-48</code>。EUI表示Extended Unique Identifier即扩展的唯一标识符，MAC地址实际上就是适配器地址或适配器标识符EUI-48。当适配器嵌入或插入每台计算机后也就成为了这台计算机的MAC地址了。<br><img src="https://cdn.nafx.top/post_cover/20230302115619.png" alt="MAC地址"><br>IEEE规定地址字段的第一字节的最低位为<code>I/G (Individual / Group)</code>位,I/G 位为0时地址字段表示<code>单个站地址</code>，I/G 位为1时表示<code>组地址</code>，用来进行<code>多播</code>，但是IEEE制订的二进制EUI－48地址就有两种不同的记法：一种记法是802.5和802.6采用的标准，这种记法将最高位写在最左边。另外一种记法是802.3和802.4采用的标准。这种记法将每一个字节的高比特位写在最右边。同时考虑到并不是所有的厂商都愿意向IEEE的RA购买机构唯一标志符OUI，因此，IEEE将地址字段的第一字节的最低第2位规定成为<code>G/L（Global/Local）位</code>，0表示这个地址为<code>全球管理</code>(即可以保证全球没有重复的地址)，值为1表示为<code>本地管理</code>，这时用户可以任意分配网络上的地址。但是应当指出的是，以太网几乎不理会这个G/L位。</p><p>&emsp;&emsp;适配器有过滤功能，当适配器每从网络上收到一个MAC帧后就先用硬件检查MAC帧中的目的地址，如果是发往本站的帧就收下，否则就将此帧丢弃，这样做就不浪费主机的资源，这里“发往本站的帧”包括以下三种:</p><ol><li>单播 (unicast) 帧（一对一），即收到的帧的MAC地址与本站的硬件地址相同。</li><li>广播 (broadcast) 帧（一对全体），即发送给本局域网上所有站点的帧(MAC地址全为1)。</li><li>多播 (multicast) 帧（一对多），即发送给本局域网上一部分站点的帧。</li></ol><p>&emsp;&emsp;以太网适配器还可以设置一种特殊的工作方式，即<code>混杂方式(promiscuous mode)</code>。工作在这种方式的适配器只要”听到”有帧在以太网上传输就都悄悄接收下来，不管这些帧是要发往那个站。这样做实际上是“窃听”其他站点的通信而不中断其他站点的通信，网络上的黑客常利用这种方法非法获取用户的口令。同时网络维护管理人员也需要用这种方法监视分析以太网流量，找出提高网络性能的具体措施，<code>嗅探器(sniffer)</code>就是用了设置为混杂方式的适配器。<br>&emsp;&emsp;常见的以太网MAC帧格式有两种标准，一种是DIX Ethernet V2标准(即以太网V2标准)，另一种则是IEEE的802.3标准。实际上使用最多的也是下图的以太网V2标准，图中假定网络层使用额是IP协议，实际上使用其他协议也是可以的。<br><img src="https://cdn.nafx.top/post_cover/20221015173038.png" alt="以太网V2的MAC帧格式"><br>&emsp;&emsp;以太网V2的MAC帧由五个字段组成，前两个字段是6个字节长的目的地址和源地址，第三个字段是2字节长的类型字段，用来标志上一层使用的是什么协议，以便把收到的MAC帧的数据上交给上一层的这个协议，例如当此字段的指为0x0800时就表示上层使用的时IP数据报。第四个字段是数据字段，其长度在46到1500字节之间。最后一个字段是4字节的帧校验序列FCS(使用CRC检验)。这里要指出，在帧首部并没有一个帧长度，那么MAC子层又怎样知道从接收到的以太网帧中取出多少字节的数据交付上一层协议呢？曼彻斯特编码的一个重要特点就是：在曼彻斯特编码的每一个码元（不管码元是0还是1）的正中间一定有一次电压的转换，当发送方把一个以太网帧发送完毕后，就不再发送其他码元了。因此，发送方网络适配器的接口上的电压也就不再变化了，这样接收方就可以很容易地找到以太网帧的结束位置，在这个位置往前数4字节（FCS），就能确定数据字段的结束位置。<br>&emsp;&emsp;当数据字段的长度小于46字节时，应在数据字段的后面加入整数字节的填充字段，以保证以太网的MAC帧长度不少于64字节，我们应当注意到，MAC帧的首部并没有指出数据字段的长度是多少。在有填充字段的情况下，接收端的MAC子层在剥去首部和尾部后就把数据字段和填充字段一起交给上层协议。现在的问题是上层协议如何知道填充字段的长度呢？（IP协议应当丢弃没有用处的填充字段）。可见，上层协议必须具有识别有效的数据长度的功能。我们知道，上层使用IP协议时，其首部有一个总长度字段，因此总长度加上填充字段的长度，应当等于MAC数据帧数据字段的长度。例如，当IP数据报的总长度为42字节时，填充字段共有4字节。当MAC帧把46字节的数据上交给IP层后，IP层就把其中最后4字节的填充字段丢弃。<br>&emsp;&emsp;从上面的MAC帧图片看出，在传输媒体上实际传输的要比MAC帧还多8个字节。这是因为当一个站在刚开始接收MAC帧时，由于适配器的时钟尚未与到达的比特流达成同步，因此MAC帧最前面的若干位就无法接收，结果使整个MAC帧变成无用的帧。为了接收端迅速实现位同步，由MAC子层向下传到物理层时还要在帧的前面插入8字节（由硬件生成），它由两个字段构成。第一个字段是7个字节的<code>前同步码</code>(1和0交替码)，用来迅速实现MAC帧的比特同步使接收端的适配器能迅速调整其时钟频率，第二个字段是<code>帧开始定界符</code>，定义为10101011，前6位的作用和前同步码一样，最后两个连续的1告诉接收端适配器后面的信息就是MAC帧，MAC帧的FCS字段检验范围不包括前同步码和帧开始定界符。<br>&emsp;&emsp;还需注意，在以太网上传送数据时是以帧为单位传输，以太网在传输帧时，各帧之间还必须有一定的间隙。因此，接收端只要找到帧开始定界符，其后面的连续到达的比特流就都属于同一个MAC帧。可见以太网不需要使用帧结束定界符，也不需要使用字节插入来保证透明传输。<br>IEEE规定凡是出现下列情况之一的即为无效的MAC帧：</p><ul><li>帧的长度不是整数个字节;</li><li>用收到的帧检验序列FCS查出有差错;</li><li>数据字段的长度不在46 - 1500字节之间（MAC帧首尾部共有18字节所以有效的MAC帧长度为64 - 1518字节之间）;<br>对于检查出的无效MAC帧就简单地丢弃，以太网不负责重传丢弃的帧。<br>循环冗余检验CRC是一种检错方法，而帧检验序列FCS是添加在数据后面的冗余码。</li></ul><h5 id="标准以太网（传统以太网）"><a href="#标准以太网（传统以太网）" class="headerlink" title="标准以太网（传统以太网）"></a>标准以太网（传统以太网）</h5><p>&emsp;&emsp;标准以太网即早期的以太网，其传输速率为10Mb/s，最初使用同轴电缆作为传输介质（总线拓扑）将许多计算机都连接到一根总线上，当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件（那个时代普遍认为有源器件不可靠，无源的电缆线才是最可靠的）。后来又开发了基于双绞线的以太网规范（这个时段一般使用集线器作为连接设备），再后来为了提高传输距离又诞生了光纤以太网规范。此种以太网的组网方式非常灵活，既可以使用粗、细缆组成总线网络，也可以使用双绞线组成星状网络，还可以同时使用同轴电缆和双绞线组成混合网络。这些网络都符合<code>IEEE 802.3</code>标准。<br>&emsp;&emsp;总线的特点是：当一台计算机发送数据时，总线上的所有计算机都能检测到这个数据，这就是广播通信方式。但我们并不总是要在局域网上进行一对多的广播通信，为了在总线上实现一对一的通信，可以使每一台计算机的适配器拥有一个与其他适配器都不同的地址，在发送数据帧时，在帧首部写明接收站的地址，仅当数据帧中的目的地址与适配器ROM中的存放的硬件地址一致时，该适配器才能接收这个帧，对于不是发送给自己的就丢弃，就实现了一对一通信。</p><p><img src="https://cdn.nafx.top/post_cover/20221014203508.png" alt="总线传输"><br>50Ω的匹配电阻吸收信号，防止信号反射干扰，在总线上的每一个工作的计算机都能检测到B发送的数据信号，但由于只有计算机D的地址与数据帧首部写入的地址一致，因此只有D才接收这个数据帧，其他所有计算机都检测到不是发送给他们的数据帧，因此就丢弃这个数据帧而不能够接受下来，在具有广播特性的总线上实现了一对一的通信。</p><p>&emsp;&emsp;经典以太网是采用<code>CSMA/CD</code>的方式来传输数据，所谓<code>CSMA/CD（Carrier Sense Multiple Access/collision detection，带有冲突检测的载波侦听多路存取）</code>协议是IEEE 802.3使用的一种媒体访问控制方法，它基本思想是：所有节点都共享网络传输信道，节点在发送数据之前，首先检测信道是否空闲，如果信道空闲则发送，否则就等待；在发送出信息后，再对冲突进行检测，当发现冲突时，则取消发送。这样做的优点是：原理比较简单，技术上易实现，网络中各工作站处于平等地位，不需集中控制，不提供优先级控制。但在网络负载增大时，发送时间增长，发送效率急剧下降。<br>&emsp;&emsp;碰撞检测就是计算机边发送数据边检测信道上的信号大小，当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大(互相叠加)，当检测到信号电压摆动值超过一定门限值时就认为总线上至少有两个站在同时发送数据，表明发生了碰撞。所谓碰撞就是发生了冲突，因此碰撞检测也称为冲突检测。每一个正在发送数据的站一旦发现总线上出现了碰撞，就要立即停止发送，免得浪费网络资源，然后等待一段<code>随机时间</code>（二进制指数类型退避算法）后再次发送。发生碰撞之后，发送端需发送干扰信号<code>强化碰撞</code>通知其他所有节点。</p><p><img src="https://cdn.nafx.top/post_cover/20230301230340.png" alt="二进制指数类型退避算法"></p><p>&emsp;&emsp;以太网端到端往返时延RTT或2τ(传统10Mbit/s以太网采用51.2μs为争用期长度)称为<code>争用期</code>，或<code>碰撞窗口</code>。经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。对于10Mbit/s以太网，在争用期内可发送512bit，也即64字节，也就是以太网在发送数据时，若前64字节没有发生冲突，则后续的数据就不会发生冲突。因此以太网最小有效帧长度为64字节，小于64字节的帧一般都是由于冲突而异常的无效帧。</p><p>求最小帧长：<br><img src="https://cdn.nafx.top/post_cover/20230301231216.png" alt="求最小帧长"></p><p>使用CSMA/CD协议的以太网不能进行全双工通信而只能进行双向交替(半双工)通信，每个站在发送数据后的一小段时间内都存在着遭遇碰撞的可能性，这种发送的不确定性使整个以太网的平均数据量远小于以太网的最高数据率。</p><p>以太网MAC帧发送流程图<br><img src="https://cdn.nafx.top/post_cover/20230301232008.png" alt="以太网MAC帧发送流程图"></p><p>IEEE 802.3中规定的一些传统以太网物理层标准如下。</p><ul><li>10 Base-2(802.3a)、10Base-5(802.3)：这两个规范都是在使用阻抗为50Ω同轴电缆作为传输介质的总线型拓扑结构网络，基于CSMA / CD流程,且采用基调传输模式的曼彻斯特编码。两者主要区别在于10Base-5使用粗同轴电缆，而10Base-2使用细同轴电缆，它们之间的最大单段距离为500m和185m。</li><li>10Broad36(802.3b)：这是在IEEE 802.3中唯一针对宽带系统（如有线广播，有线电视）的规范，在采用阻抗为75Ω同轴电缆的总线型拓扑结构网络中使用，它也采用几代传输模式的曼彻斯特编码，最大的段距离为3.6km。</li><li>10Base-T(802.3i)：该规范应用于使用双绞线作为传输介质的星型拓扑网络中，是当时以太局域网中应用最广泛的以太网规范。它也采用基带传输模式的曼彻斯特编码，最大段距离为100m。</li><li>10Base-F(IEEE 802.3j)：该规范使用光纤作为传输介质，包括10Base-FL、10Base-FB和10Base-FP三种字规范，均采用基带传输模式的曼彻斯特编码，但设计用途上各不相同。</li><li>10Base-FL：设计用于当时的光纤中继器间连接(FOIRL, Fiober OpticInterRepeater Link)协议协同工作，其目的就是替代FOIRL，与FOIRL协同时单段光纤段距离为1000m，纯10Base-FL段距离为2000m。</li><li>10Base-FB：用于光纤骨干网(Fiber-Backbone)中同步信令的传输，用于将其他网段通过中继器连接到本地网络，单段光纤段距离为2000m。这个协议是用于集线器、交换机、光纤中继器间的连接的。</li><li>10Base-FP：用于连接无源光纤(Fiber-Passive)器件的以太网子规范，可以无需中继器即可连接大量用户（通过集线器、交换机）组成星型拓扑网络，单段光纤段距离为500m。该协议用于用户与集线器和交换机间的链接。</li></ul><p>这些规范名称是有含义的,其名称格式：&lt;传输速率(Mbps)&gt;&lt;传输模式(Base表示基带传输 Broad表示宽带传输)&gt;&lt;最大段长度(基准单位为100m)&gt;。<br>如10Base-5，即使10Mbps速率，基带传输，介质最长为500米。</p><h5 id="快速以太网"><a href="#快速以太网" class="headerlink" title="快速以太网"></a>快速以太网</h5><p>&emsp;&emsp;速率达到或超过100Mb/s的以太网称为高速以太网(即1Gb/s)，100Mb/s的<code>快速以太网(Fast Ethernet)</code>是由10Mbps标准发展而来的，其协议标准为1995年4月发布的<code>IEEE 802.3u(100Base-T)</code>。IEEE 802.3u标准基本保持了标准局域网的规定，包括帧格式、接口、介质访问控制方法，在MAC子层仍采用了在IEEE 802.3标准中的CSMA/CD作为介质访问控制协议，并保留了MAC和LLC帧格式。但是为了实现100Mbps的传输速率，在物理层做了一些重要的改进：如采用更高效的4B/5B编码而不是曼彻斯特编码。<br>快速以太网也定义了几种因介质不同的规范，有100Base-TX、100Base-T4、100Base-FX。其命名和上述提到的也类似，不同在于TX表示两对芯线双绞线、T4表示四对芯线双绞线，FX表示两条光纤,具体如下：</p><ul><li>100 Base-TX(802.3u)：该规范采用两对芯线的双绞线电缆（5类、超5类屏蔽或非屏蔽双绞线对于非屏蔽双绞线，规范只使用四对芯线中的两对，另外两对没有使用），其中一对用于发送，另一对用于接收。该标准直接取代10Base-T和10Base-2规范。使用RJ-45或DB9接口，节点与集线器的最大距离为100m，支持全双工,线缆又有直通线和交叉线，直通线（级间连接，如PC到集线器、交换机，交换机到路由器等）两端同时使用TIA/EIA-568B标准，而交叉线（同级连接，如PC到PC）则是两端各使用A和B标准。</li><li>100 Base-T4(802.3u)：该标准是用来向下兼容早前安装的3类、4类非屏蔽双绞线（当然也支持5类及以上线）的，但它要使用双绞线中所有的8根芯线，这也就是T4的含义。它采用半双工交换方式，在4对芯线中，3对用于一起发送数据，第4对用于冲突检测（为了实现100Mbps传输速率）,使用R-45连接器，最大网段长度为100m，在100Base-T4中，原来的1、3和2、6两对芯线与100Base-TX一样，仍只能采用半双工传输，但另外两对芯线可以全双工传输。另外，100Base-T4规范采用的是8B/6T编码法，而不是其他快速以太网规范的4B/5B编码。</li><li>100Base-FX(802.3u)：使用一对单模或多模光纤，一路用于发送数据，一路用于接收数据；最大网段长度为200m(使用单模光纤时可达2000m)，支持全双工。此种网络主要用于搭建主千网，以提升主干网络传输速率。<ol><li>多模光纤，纤芯为62.5/125μm，采用基于LED的收发器将波长为820nm的光信号发送到光线上。当连在两个设置为全双工模式的交换机端口之间时，最大段距离有2km。</li><li>单模光纤，纤芯为9/125μm，采用基于激光的收发器将波长1300nm的光信号发送到光线上。单模光纤损耗小，较多模而言能传输更远的距离。</li></ol></li></ul><h5 id="千兆以太网"><a href="#千兆以太网" class="headerlink" title="千兆以太网"></a>千兆以太网</h5><p>&emsp;&emsp;吉比特以太网，<code>千兆以太网(GigabitEthernet)</code>也称为吉比特以太网。1995年11月，IEEE 802.3工作组委任一个高速研究组，以研究将快速以太网速率增至1000Mb/s的可行性和方法。1996年6月，IEEE标准委员会批准了千兆以太网方案授权申请，随后IEE 802.3工作组成立了EEE 802.3z工作委员会，1997年IEEE通过了吉比特以太网的标准<code>802.3z</code>，目前售出的各种计算机的以太网接口基本都是1Gb/s的，传统的10Mb/s和100Mb/s都已经退出了舞台，该规范基本保留了原有的以太网帧结构，同时也支持CSMA/CD介质访问控制技术，所以完全向下兼容，原有的以太网可以方便的升级到千兆以太网。该标准的主要规定如下：</p><ol><li><p>速率为1Gb/s下的全双工/半双工两种工作方式。</p></li><li><p>使用802.3规定的以太网帧格式、CSMA/CD技术。</p></li><li><p>在半双工方式下使用CSMA/CD协议(全双工方式不需要使用)。</p></li><li><p>向下兼容10Base-T和100Base-T技术。<br>工作组为千兆以太网制定了一系列物理层标准，其中常用的标准如下(吉比特以太网物理层使用两种成熟技术，一种来自现有以太网，另一种则是美国国家标准协会ANSI制定的<code>光纤通道FC (Fibre Channel)</code>)。</p></li></ol><ul><li><p>1000 Base-SX (802.3z)：波长为850nm，使用芯径62.5/125μm多模光纤、50/125μm多模光纤。其中使用62.5/125μm多模光纤的最大传输距离为220m，使用50/125μm多模光纤的最大传输距离为500米。采用8B/10B编码方式。此标准主要应用于建筑物中同一层的短距离主于网。</p></li><li><p>1000 Base-LX (802.3z)：LX代表长波长，波长为1270nm-1355nm，使用芯径62.5μm多模光纤、50μm多模光纤和9μm单模光纤。其中使用多模光纤的最大传输距离为550m，使用单模光纤的最大传输距离为3千米，采用8B/10B编码方式，此标准主要应用于校园主干网。</p></li><li><p>1000 Base-CX (802.3z)：采用150Ω平衡屏蔽双绞线(STP)为传输介质，9芯D型连接器连接电缆（DB-9连接器），最大传输距离为25m，数据编码法为8B/10B，适用于数据中心主干交换机和主服务器之间的短距离连接。</p></li><li><p>1000 Base-T (802.3ab)：采用5类、超5类、6类、7类双绞线的全部四对芯线作为传输介质，采用PAM5编码方式，最大传输距离为100m。全部四对芯线都可以同时进行全双工数据收发，所以同级设备也无需制作交叉线。这是企业局域网最常用的千兆以太网标准，这种被最广泛安装的LAN（Local Area Network）结构上提供1000Mbps的速度。</p></li></ul><p>&emsp;&emsp;千兆以太网采用光纤作为上行链路，用于楼宇间的连接，原本被作为一种交换技术设计，之后被广泛应用于服务器的连接和主干网中。如今，千兆以太网已成为主流的网络技术，无论是大型企业还是中小型企业，在组建网络时都会把千兆以太网作为首选高速网络技术。除了上述提到的IEEE发布的规范，在工业应用里还有非正式标准形式但广泛应用的千兆以太网规范：1000Base-LH、1000Base-ZX、1000Base-LX10、1000Base-BX10、1000Base-TX。因此，在千兆以太网中加起来一共有“九”种规范，根据采用的传输介质类型，总体上分为基于光纤和基于双绞线的两大类。</p><h5 id="万兆以太网"><a href="#万兆以太网" class="headerlink" title="万兆以太网"></a>万兆以太网</h5><p>&emsp;&emsp;<code>万兆以太网(10 Gigabit Ethernet)</code>也称为10吉比特以太网，是继千兆以太网之后产生的高速以太网。在千兆以太网的IEEE 802.3z规范通过后不久，IEEEE成立了高速研究组（High Speed Study Group，HssG)，主要致力于10GE的研究。10GE的帧格式与之前的10Mb/s、100Mb/s和1000Mb/s以太网的帧格式完全相同，并保留了802.3标准规定的以太网最小帧长和最大帧长，使用户将已有以太网进行升级时仍能和较低速率的以太网方便的通信。但由于10GE仅工作在全双工方式，因此不存在争用的问题，当然也不需要使用CSMA/CD协议，这就使10GE的传输距离大大提高了(因为不再受必须进行碰撞检测的限制)。常用的物理层规范如下：</p><ul><li>10G Base-SR (802.3ae)：SR表示” Short Reach”(短距离)，10GBae-SR仅用于短距离连接，该规范支持编码方式为64B/66B的短波(850nm)多模光纤，有效传输距离为2m~300m。10GBase-SR具有最低成本、最低电源消耗和最小的光纤模块等优势。</li><li>10G Base-LR (802.3ae)：LR表示“Long Reach”(长距离)，10 G Base-LR主要用于长距离连接，该规范支持编码方式为64B/66B的长波(1310nm)单模光纤，有效传输距离为2m~10km，最高可达25km。</li><li>10G Base-ER (802.3ae)：ER表示“ Extended Reach”(超长距离，10G Base-ER支持超长波（1550nm)单模光纤，有效传输距离为2m~40km。</li><li>10G Base-CX4 (802.3ak)：10GBase-CX4规范不是利用单个铜线链路传送万兆数据，而是使用4台发送器和4台接收器用4对双芯同轴电缆来传送万兆数据，并以差分方式运行在同轴电缆上，每台设备利用8B/10B编码，以每信道3.125GHz的波特率传送2.5Gb/s的数据。这需要在每条电缆组的总共8条双同轴信道的每个方向上有4组差分线缆对。另外，与可在现场端接的5类、超5类双绞线不同，CX4线缆需要在工厂端接，因此客户必须指定线缆长度。线缆越长一般直径就越大。10GBase-CX4的主要优势就是低电源消耗、低成本、低响应延时，但是接口模块比SPF+的大。</li><li>10G Base-T (802.3an)：10GBase-T沿用1000Base-T的传输方式，仍然采用四个差分对同时双向传输，全双工，但传输的总速率高达10Gbps，每对线的速率高达2.5Gbps。在编码方面，不是采用原来1000Base-T的PAM-5，而是采用了PAM-16编码方式。使用6类双绞线最大传输距离位55m，使用6a类双绞线时最大传输距离为100m。</li></ul><h5 id="扩展的以太网"><a href="#扩展的以太网" class="headerlink" title="扩展的以太网"></a>扩展的以太网</h5><h6 id="使用集线器在物理层扩展以太网"><a href="#使用集线器在物理层扩展以太网" class="headerlink" title="使用集线器在物理层扩展以太网"></a>使用集线器在物理层扩展以太网</h6><p><img src="https://cdn.nafx.top/post_cover/20230302121517.png" alt="集线器扩展以太网"><br>优点：</p><ul><li>使原来属于不同碰撞域的以太网能跨碰撞域通信；</li><li>扩大了以太网覆盖的物理范围；</li></ul><p>缺点：</p><ul><li>碰撞域增大了，但总的吞吐量并未提高；</li><li>如果不同的碰撞域使用不同的数据率就不能用集线器将他们互连起来。<br>集线器在物理层上扩展以太网后是同一个冲突域，同一个广播域。</li></ul><h6 id="在数据链路层扩展以太网"><a href="#在数据链路层扩展以太网" class="headerlink" title="在数据链路层扩展以太网"></a>在数据链路层扩展以太网</h6><p>扩展以太网更常用的方法是在数据链路层进行，早期使用网桥，现在使用以太网交换机。</p><ul><li>网桥和交换机工作在数据链路层可以识别帧；</li><li>他根据MAC帧的目的地址对收到的帧进行转发和过滤；</li><li>网桥收到一个帧不是向所有的接口转发此帧，而是先检查此帧的目的mac地址，然后再确定转发到哪个接口或丢弃；</li><li>可以隔离碰撞域。 </li></ul><p>以太网交换机的特点：</p><ul><li>接口数量多</li><li>全双工工作 接口与一台主机或另一个交换机相连，工作在全双工模式</li><li>具有并行性 能同时连接多对接口，使多对主机能同时通信</li><li>传输无冲突 相互通信的主机都是独占传输媒体，无碰撞的传输数据</li><li>接口存储器 接口有存储器，能在输出端口繁忙时把到来的帧进行缓存</li><li>能即插即用 其内部的帧交换表是通过自学习算法自动地逐渐建立起来的</li><li>转发速率高 采用专用的交换结构芯片，采用硬件方式转发，转发效率比采用软件转发的网桥快很多。</li></ul><p>交换机的交换方式</p><ul><li>存储转发方式： 数据帧先缓存，验证正确性(CRC),正确转发，错误丢弃。延迟大，可靠性高，支持不同速率的端口交换。</li><li>直通方式： 检查数据帧的目的MAC地址后立即转发，延迟小，可靠性低，不支持不同速率的端口交换，有可能转发一些无效的帧。</li></ul><p>交换机自学习和转发帧的流程图<br><img src="https://cdn.nafx.top/post_cover/20230302124047.png" alt="交换机自学习和转发帧的流程图"><br>交换机每个接口都是一个冲突域，但所有端口是同一个广播域。</p><h5 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h5><p>&emsp;&emsp;虚拟局域网将单一的广播域隔离出来增加网络的安全性，虚拟局域网VLAN(Virtual LAN)是一些局域网网段构成的与物理位置无关的逻辑组，这些组有共需求。每一个VLAN的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪个VLAN。虚拟局域网技术由以太网交换机实现，该技术其实只是给局域网用户提供的一种服务，而不是一种新型局域网。<br>IEEE 802.3ac标准定义了以太网的帧格式的拓展，以支持虚拟局域网，该协议允许在以太网的帧格式中插入一个4字节的标识符，称为VLAN标记，用来指明发送该帧的计算机属于哪一个虚拟局域网。插入VLAN标记的帧称为<code>802.1Q帧</code>或<code>带标记的以太网帧</code>。</p><p><img src="https://cdn.nafx.top/post_cover/20230302184911.png" alt="802.1Q帧"></p><p>VLAN的优点：</p><ul><li>便于网络管理，具有相似需求的用户共享一个VLAN；</li><li>增强网络的安全性，敏感用户与普通用户隔离；</li><li>减少了不必要的网络流量；</li><li>限制了广播报文的洪泛，抑制广播风暴；</li><li>减少网络拓扑变更成本；</li><li>减低计算机CPU的开销；</li></ul><p>虚拟局域网划分方法：</p><ul><li>基于交换机端口划分 最简单、也是最常用的方法。属于在第一层划分局域网的方法。缺点是用户移动位置固定。</li><li>基于计算机的MAC地址划分 属于在第二层划分局域网的方法，用户位置可以改变。缺点是需要输入和管理大量的MAC地址。</li><li>基于协议划分 根据以太网帧的第三个字段类型字段确定该类型的协议属于哪一个虚拟互联网，也属于在第二层划分虚拟互联网的方法。</li><li>基于IP地址划分 属于在第三层划分虚拟互联网的方法，根据以太网帧的第三个字段类型和IP分组首部中的源IP地址字段确定该IP分组属于哪一个虚拟局域网。</li><li>基于应用层划分 根据高层应用或者服务、或者他们的组合划分虚拟局域网。</li></ul><h5 id="使用以太网进行宽带接入"><a href="#使用以太网进行宽带接入" class="headerlink" title="使用以太网进行宽带接入"></a>使用以太网进行宽带接入</h5><p>&emsp;&emsp;现在人们也在使用以太网进行宽带接入因特网，为此IEEE在2001年初成立了802.3EFM(EFM表示“Ethernet in the First mile”)工作组，专门研究高速以太网的宽带接入问题。然而以太网的帧格式中并没有用户名字段，也没有让用户键入密码来鉴别用户身份的过程，于是就有人想法子把数据链路层的两个成功的协议结合起来，即把PPP协议中的PPP帧再封装到以太网中来运输，这就是1999年公布的<code>PPPoE(PPP over Ethernet)</code>，现在的光纤宽带接入FTTx都要使用PPPoE的方式。<br><img src="https://cdn.nafx.top/post_cover/20221016113635.png" alt="PPPoE协议报文结构图"></p>]]></content>
      
      
      <categories>
          
          <category> 学记笔记 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络体系结构（二）</title>
      <link href="/archives/32497821.html"/>
      <url>/archives/32497821.html</url>
      
        <content type="html"><![CDATA[<h2 id="关于物理层的传输媒体"><a href="#关于物理层的传输媒体" class="headerlink" title="关于物理层的传输媒体"></a>关于物理层的传输媒体</h2><p>&emsp;&emsp;<code>传输媒体</code>作为计算机网络体系结构的第0层，它是数据传输系统中在发送器和接收器之间的物理通路，也称为<code>传输介质</code>或者<code>传输媒介</code>。传输媒体可以分为两大类，即<code>导向传输媒体</code>和<code>非导向传输媒体</code>。在导向传输媒体中电磁波被导向沿着固体媒体（铜线或光纤）传播，而非导向传输媒体就是指自由空间，在非导向传输媒体中电磁波的传输常称为无线传播。网络传输媒介的质量的好坏会影响数据传输的质量，包括速率、数据丢包等。</p><h3 id="常见的导向传输媒体有以下几种"><a href="#常见的导向传输媒体有以下几种" class="headerlink" title="常见的导向传输媒体有以下几种"></a>常见的导向传输媒体有以下几种</h3><h4 id="1-双绞线"><a href="#1-双绞线" class="headerlink" title="1. 双绞线"></a>1. 双绞线</h4><p>&emsp;&emsp;双绞线也成为双扭线，它的结构简单就是把两根互相绝缘的铜导线并排放在一起，然后用规则的方法绞合（twist）起来就构成了双绞线。绞合可减少对相邻导线的电磁干扰。现在以太网基本上也都是使用各种类型的双绞线电缆进行连接的。如<code>无屏蔽双绞线UTP(Unshielded Twisted Pair)</code>、<code>屏蔽双绞线STP(Shielded Twisted Pair)</code>，如果对整条双绞线电缆进行屏蔽则标记为x/UTP(x为F(Foiled)表明采用铝箔屏蔽层，x为S(braid Screen)表明采用铜编制层，x为SF，则表明在铝箔屏蔽层外边再加上金属编织层进行屏蔽)。更好的办法是给电缆中的每一对双绞线都加上铝箔屏蔽层（记为FTP或U/FTP，U表明对整条电缆不另增加屏蔽层）。如果在此基础上再对整条电缆添加屏蔽层，则有F/FTP（整条电缆再加上铝箔屏蔽层）或S/FTP（整条电缆再加上金属编制层进行屏蔽）。所有的屏蔽双绞线都必须有接地线。下图c表示5类线具有比3类线更高的绞合度（3类线的绞合长度是7.5-10cm，而5类线的绞合长度则是0.6-0.85cm）。绞合度越高的双绞线能够用越高的数据率传输数据。下图d所示的是三种10GBASE-T电缆，在抗干扰能力上，U/FTP比F/UTP好，而F/FTP则是最好的。<br><img src="https://cdn.nafx.top/post_cover/%E5%87%A0%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8F%8C%E7%BB%9E%E7%BA%BF.png" alt="几种不同的双绞线"></p><h5 id="常用的常用双绞线的类别，带宽和典型应用表"><a href="#常用的常用双绞线的类别，带宽和典型应用表" class="headerlink" title="常用的常用双绞线的类别，带宽和典型应用表"></a>常用的常用双绞线的类别，带宽和典型应用表</h5><table><thead><tr><th>绞合线类别</th><th>带宽</th><th>线缆特点</th><th>典型应用</th></tr></thead><tbody><tr><td>3</td><td>16MHz</td><td>2对4芯双绞线</td><td>模拟电话：传统以太网（10Mbit/s）</td></tr><tr><td>5</td><td>100MHz</td><td>与3类线相比增加了绞合度</td><td>传输速率100Mbit/s（距离100m）</td></tr><tr><td>5E（超5类）</td><td>125MHz</td><td>与5类相比衰减更小</td><td>传输速率1Gbit/s（距离100m）</td></tr><tr><td>6</td><td>250MHz</td><td>改善了串扰等性能，可使用屏蔽双绞线</td><td>传输距离10Gbit/s（距离35-55m）</td></tr><tr><td>6A</td><td>500MHz</td><td>改善了串扰等性能，可使用屏蔽双绞线</td><td>传输速率10Gbit/s（距离100m）</td></tr><tr><td>7</td><td>600MHz</td><td>必须使用屏蔽双绞线</td><td>传输速率超过了10Gbit/s，距离100m</td></tr><tr><td>8</td><td>2000MHz</td><td>必须使用屏蔽双绞线</td><td>传输速率25Gbit/s或40Gbit/s，距离30m</td></tr></tbody></table><p>&emsp;&emsp;不论使用那种类型的双绞线，衰减都随频率的升高而增大，使用更粗的导线可以减小衰减，但增大了重量和成本。信号应该有足够大的振幅，以便在噪声干扰下能够在接收端正确的被检测出来。双绞线的最高速率还与数字信号的编码方式有很大的关系。</p><h4 id="2-同轴电缆"><a href="#2-同轴电缆" class="headerlink" title="2.同轴电缆"></a>2.同轴电缆</h4><p>&emsp;&emsp;同轴电缆由内导体铜质芯线(单股实心线或多股绞合线)，绝缘层，网状编织的外导体屏蔽层以及绝缘保护套层所组成。由于外导体屏蔽层的作用，同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。目前同轴电缆主要用在有线电视网的居民小区中。目前高质量的同轴电缆的带宽已接近1GHz。<br><img src="https://cdn.nafx.top/post_cover/%E5%90%8C%E8%BD%B4%E7%94%B5%E7%BC%86%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="同轴电缆的结构"></p><h4 id="3-光缆"><a href="#3-光缆" class="headerlink" title="3.光缆"></a>3.光缆</h4><p>&emsp;&emsp;光纤是光纤通信的传输媒体。在发送端有光源，可以采用发光二极管或半导体激光器，它们在电脉冲的作用下能产生出光脉冲。在接收端利用光电二极管做成光检测器，在检测到光脉冲时可还原出电脉冲。有光脉冲相当于1，没有光脉冲相当于0。由于可见光的频率非常高，约为10^8 MHz的量级，因此一个光纤通信系统的传输带宽远远大于目前其他各种传输媒体的带宽。<br>&emsp;&emsp;光纤有多模光纤和单模光纤之分(多条不同角度入射的光线在一条光纤中传输称为多模光纤，现在多模光纤已很少使用了)，单模光纤的衰耗较小，过去在2.5Gbit/s的高速率下可以传输数十公里而不需要中继器，现在随着光纤制造工艺的不断进步单根光纤的传播速率已经提高到10Gbit/s甚至40Gbit/s了，如果采用密集波分复用技术，例如160的波分复用那么一根光纤的传输速率就可以达到1.6Tbit/s。<br>&emsp;&emsp;光纤不仅具有通信容量非常大的优点，而且传输损耗小、抗雷电和电磁干扰性能好、无串音干扰、保密性好、体积小、重量轻。现在光纤已经成为一种非常普及的传输媒体。</p><h3 id="非导向传输媒体"><a href="#非导向传输媒体" class="headerlink" title="非导向传输媒体"></a>非导向传输媒体</h3><p>&emsp;&emsp;非导向传输媒体实际上就是利用自由空间来传播电磁波，目前利用无线信道进行信息传输是在运动中通信的唯一手段。无线传输可使用的频段很广例如:</p><ol><li>短波波段: 即高频通信主要靠电离层的反射，通信距离远。但电离层的不稳定所产生的衰落现象以及电离层反射产生的多径效应使得通信质量较差。</li><li>微波波段: 微波的频率范围为300MHz-300GHz（波长1m-1mm），但主要使用2GHz-40GHz的频率范围。微波在空间主要是直线传播，由于地球表面是个曲面，因此其传播距离受到限制，一般只有50km左右。但若采用100m高的天线塔，则传播距离可增大到100km。微波会穿透电离层而进入宇宙空间，因此它不像短波那样可以经电离层反射传播到地面上很远的地方。卫星通信实际上也是一种微波接力通信，其频带很宽，通信容量很大，信号所受到的干扰较小，通信比较稳定，但信号的传播时延较大。</li></ol><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><p><img src="https://cdn.nafx.top/post_cover/%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8.png" alt="信道复用"></p><p>&emsp;&emsp;复用（multiplexing）是通信技术中的基本概念，可以使多个用户共同使用一个共享信道来进行通信减少经济成本，下面介绍一些常见的复用技术。</p><h3 id="FDM"><a href="#FDM" class="headerlink" title="FDM"></a>FDM</h3><p>最基本的复用就是<code>频分复用 FDM（Frequency Division Multiplexing）</code>是给每个信号分配唯一的载波频率并通过单一媒体来传输多个信号的方法。频分复用的的各路信号在同样的时间占用不用的带宽资源。组合多个信号的硬件称为复用器，分离这些信号的硬件称为分用器。</p><h3 id="FDMA"><a href="#FDMA" class="headerlink" title="FDMA"></a>FDMA</h3><p><code>FDMA（Frequency Division Multiple Access）</code>频分复用多址简称为频分多址,强调这种复用信道可以让多个用户(可以在不用的地点)使用不同频率的信道接入到复用信道。</p><h3 id="TDM"><a href="#TDM" class="headerlink" title="TDM"></a>TDM</h3><p><code>TDM（Time Division Multiplexing）</code>时分复用,把多个信号复用到单个硬件传输信道，它允许每个信号在一个很短的时隙使用信道，接着的时隙再让下一个信号使用，时分复用是将时间划分为一段段等长的时分复用帧（即TDM帧）。每一路信号在每一个TDM帧中占用固定序号的时隙。每一路信号所占用的时隙周期性地出现（其周期就是TDM帧的长度）。因此TDM信号也称为等时（isochronous）信号。时分复用的所有用户是在不同的时间占用同样的频带宽度，更适合于数字信号的传输。</p><h3 id="TDMA"><a href="#TDMA" class="headerlink" title="TDMA"></a>TDMA</h3><p><code>TDMA（Time Division Multiple Access）</code>时分复用多址，简称为时分多址，和FDMA中的MA一样强调多址，这种信道可以让多个用户（可以在不同地点）在不同时隙接入到复用信道。</p><p><img src="https://cdn.nafx.top/post_cover/%E9%A2%91%E5%88%86%E5%A4%8D%E7%94%A8%E5%92%8C%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8.png" alt="频分复用和时分复用"></p><h3 id="STDM"><a href="#STDM" class="headerlink" title="STDM"></a>STDM</h3><p><code>STDM（Statistic TDM）</code>统计时分复用，是一种改进的时分复用，能明显的提高信道的利用率。STDM帧不是固定分配时隙，而是按需动态分配时隙。在输出线路上，某一个用户所占用的时隙并不是周期性的出现的，因此又称为异步时分复用，而普通的时分复用称为同步时分复用。<br><img src="https://cdn.nafx.top/post_cover/%E7%BB%9F%E8%AE%A1%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8.png" alt="统计时分复用"><br>每一个STDM帧中的时隙数小于连接在集中器上的用户数,各用户有了数据就随时发往集中器的输入缓存，然后集中器按顺序依次扫描输入缓存，把缓存中的输入数据放入STDM帧中。对没有数据的缓存就跳过去。当一个帧的数据放满了，就发送出去。</p><h3 id="WDM"><a href="#WDM" class="headerlink" title="WDM"></a>WDM</h3><p><code>WDM (Wavelength Division Multiplexing)</code>波分复用就是光的频分复用，借用传统的载波电话的频分复用的概念，就能做到使用一根光纤来同时传输多个频率很接近的光载波信号。这样就使光纤的传输能力可成倍地提高。由于光载波的频率很高，因此习惯上用波长而不用频率来表示所使用的光载波。<br><img src="https://cdn.nafx.top/post_cover/%E6%B3%A2%E5%88%86%E5%A4%8D%E7%94%A8.png" alt="波分复用"></p><h3 id="DWDM"><a href="#DWDM" class="headerlink" title="DWDM"></a>DWDM</h3><p><code>DWDM (Dense WDM)</code>密集波分复用，是波分复用的一种具体表现形式，DWDM的波长很小，不到2nm，甚至小于0.8nm。因此现在可以把几十路甚至一百多路的光载波信号复用到一根光纤中传输，现在人们谈论的WDM几乎全是DWDM系统。</p><h3 id="CDM"><a href="#CDM" class="headerlink" title="CDM"></a>CDM</h3><p><code>CDM（Code Division Multiplexing）</code>码分复用，码分复用最初用于军事通信，因为这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。当码分复用信道为多个不同地址的用户所共享时，就称为<code>码分多址CDMA（Code Division Multiple Access）</code>每个用户可以在同样的时间使用同样的频带进行通信，由于个用户使用经过特殊挑选的不用码型各用户间不会造成干扰，<br>每个站被指派一个<code>唯一</code>的m bit的码片序列，如果要发送比特1就发送自己的码片序列，如果要发送比特0就发送该码片序列的二进制反码。CDMA系统的一个重要特点就是这种体制给每一个站分配的码片序列不仅各不相同，并且还必须相互<code>正交(orthogonal)</code>就是向量S和T点的规格化<code>内积(Inner Product)</code>都是0，向量S和各站码片反码的向量内积也是0，另外任何一个码片向量和该码片向量自己的规格化内积都是1和该码片反码的向量内积是-1。在使用的系统中是使用伪随机序列。</p><h2 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h2><p>&emsp;&emsp;用户要连接到互联网就必须先连接到某个ISP，以便获得上网所需的IP地址，在初期用户都是利用电话的用户线通过调制解调器连接到ISP的。但从电话的用户线介入到互联网的速率最高只能达到56kbit/s。后面人们就认为只要接入互联网的速率远大于56kbit/s就是宽带，后来美国联邦通信委员会FCC认位只要双向速率之和超过200kbit/s就是宽带。后面宽带的标准也不断提高，2015年1月，FCC又对宽带进行了重新定义，将原定的宽带下行速率调整至25Mbit/s，原定的上行速率调整至3Mbit/s。<br>&emsp;&emsp;从宽带接入的媒体来看可以划分为两大类，一类是有线宽带接入，而另一类是无线宽带接入。</p><h3 id="ADSL技术"><a href="#ADSL技术" class="headerlink" title="ADSL技术"></a>ADSL技术</h3><p>&emsp;&emsp;<code>非对称数字用户线ADSL（Asymmetric Digital Subscriber Line）</code>技术是用数字技术对现有模拟电话的用户线进行改造，使它能够承受宽带数字业务。虽然标准模拟电话信号的频带被限制在300 ~ 3400Hz内，但用户线本身实际可以通过1MHz频率的信号，ADSL技术把0~4kHz低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给上网用户使用。由于用户当时上网主要是从互联网下载各种文档，而向互联网发送的信息量一般都不太大，因此ADSL的下行（从ISP到用户）带宽都远远大于上行（从用户到ISP）带宽。<code>“非对称”</code>由此得出。<br>&emsp;&emsp;这种接入的缺点是对用户线的质量有较高的要求，ADSL的传输距离取决于数据率和用户线的线径（用户线越细，信号传输时的衰减就越大），ADSL所能得到的最高数据率传输速率还与实际的用户线上的信噪比密切相关，线路噪声越大宽带接入的速度就越低。而ADSL最大的好处就是可以利用现在电话网中的用户线，而不用重新布线。<br><img src="https://cdn.nafx.top/post_cover/3efc328b9e78754c898974935b6d9c4.jpg" alt="DMT技术频谱分布"><br>&emsp;&emsp;ADSL在用户线（铜线）的两端各安装一个ADSL调制解调器。这种调制解调器的实现方案有多种。我国采用的方案是离散多音调DMT（Discrete Multi-Tone）调制技术。DMT调制技术采用频分复用的方法，把40kHz以上一直到1.1MHz的高端频谱划分为许多子信道，其中25个子信道用于上行信道，而249个子信道用于下行信道，并使用不同的载波（即不同的音调）进行数字调制。这种做法相当于在一对用户线上使用许多小的调制解调器并行地传送数据。由于用户线的具体条件往往相差很大（距离，线径，受到相邻用户线的干扰程度等都不同），因此ADSL采用自适应调制技术使用户线能够传送尽可能高的数据率。ADSL不能保证固定的数据率。<br><img src="https://cdn.nafx.top/post_cover/ADSL%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%84%E6%88%90.png" alt="ADSL接入网组成"><br>&emsp;&emsp;基于ADSL的接入网由以下三大部分组成：数字用户线接入复用器DSLAM（DSL Access Multiplexer），用户线和用户家中的一些设备。数字用户线接入复用器包括许多ADSL调制解调器。ADSL调制解调器又称为接入端接单元ATU（Access Termination Unit）。由于ADSL调制解调器必须成对使用，因此在电话端局（或远端站）和用户家中所用的ADSL调制解调器分别记为ATU-C（C代表端局（Central Office））和ATU-R（R代表远端（Remote））。用户电话通过电话分离器（Splitter）和ATU-R连在一起，经用户线到端局，并再次经过一个电话分离器把电话连到本地电话交换机。电话分离器是无源的，它利用低通滤波器将电话信号与数字信号分开。将电话分离器做成无源的是为了在停电时不影响传统电话的使用。一个DSLAM可支持多达500-1000个用户。</p><h3 id="光纤同轴混合网-HFC网"><a href="#光纤同轴混合网-HFC网" class="headerlink" title="光纤同轴混合网(HFC网)"></a>光纤同轴混合网(HFC网)</h3><p>&emsp;&emsp;光纤同轴混合网（HFC网，HFC是Hybrid Fiber Coax）是在目前覆盖面很广的有线电视网的基础上开发的一种居民宽带接入网，除可传送电视节目外，还能提供电话，数据和其他宽带交互型业务。最早的有线电视网是树形拓扑结构的同轴电缆网络，采用了模拟技术的频分复用对电视节目进行单向广播传播。后经有线电视网改造，变成了现在的光纤同轴混合网（HFC网）。为了提高可靠性和信号的质量，HFC网把原来有线电视网中的同轴电缆主干部分改换成光纤吗，光纤的头端连接到光纤节点（fiber node）在光纤节点光信号被转换为电信号，然后通过同轴电缆传送到每个用户家庭。从头端到用户家庭所需的放大器数目也就减少到仅4-5个。连接到一个光纤节点的典型用户数是500左右，但不超过2000。<br><img src="https://cdn.nafx.top/post_cover/HFC%E7%BD%91.png" alt="HFC网"><br>&emsp;&emsp;原来的有线电视网最高传输频率是450MHz，并且仅用于电视信号的下行传输。但现在的HFC网具有双向传输功能，而且扩展了传输频带，根据有线电视频率配置标准GB/T 17786-1999目前我国HFC网的频带划分如下图。<br><img src="https://cdn.nafx.top/post_cover/HFC%E7%BD%91%E9%A2%91%E5%B8%A6.png" alt="HFC网频带划分"><br>&emsp;&emsp;并且要使现有的模拟电视机能够接收数字电视信号，需要把一个叫做<code>机顶盒(set-top box)</code>的设备连接在同轴电缆和用户的电视机之间。还需要增加一个为HFC网使用的<code>电缆调制解调器(cable modem)</code>解决共享信道中可能出现的冲突问题，电缆调制解调器可以做成一个单独的设备也可以做成内置式的安装在电视机的机顶盒里。<br>&emsp;&emsp;HFC的优点是覆盖面很广，并且带宽也很高，缺点是必须对现有单向传输的有线电缆进行改造，使其变成可以双向通信的电缆，用户家需要增加一个机顶盒。此外为解决信号传输时的衰减问题，在有线电缆中每隔一定距离就要加一个放大器，大量放大器的接入使整个网络的可靠性下降。我国利用HFC接入互联网并未得到普遍使用。</p><h3 id="FTTx技术"><a href="#FTTx技术" class="headerlink" title="FTTx技术"></a>FTTx技术</h3><p>&emsp;&emsp;FTTx是一种实现宽带居民接入网的方案，代表多种宽带光纤接入方式。FTTx是解决宽带接入最理想的方案，因为光纤可传送的数据率很高，并且通讯质量最好，现在我国宽带接入的主流已经是光纤接入了。</p><p>FTTx表示Fiber To The…（光纤到…），如：<br>光纤到户FTTH（Fiber To The Home）：光纤一直铺设到用户家庭。<br>光纤到小区FTTZ（Fiber To The Zone）：光纤铺设到小区。<br>光纤到大楼FTTB（Fiber To The Building）：光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。<br>光纤到路边FTTC（Fiber To The Curb）：光纤铺到路边，从路边到各用户可使用星形结构双绞线作为传输媒体。<br>光纤到桌面FTTD（Fiber To The Desk）：光纤接入到用户桌面。</p><p>&emsp;&emsp;一个家庭用户远远用不了一根光纤的通信容量。为了有效的利用光纤资源，在光纤和广大用户之间，还需要铺设一端中间的转换装置即<code>光配线网ODN（Optical Distribution Network）</code>，使得数十个家庭用户能够共享一根光纤干线。如下图是现在广泛使用的无源光配线网的示意图。“无源”表明在光配线网中无须配备电源，因此基本上不用维护，运营成本和管理成本都很低。无源光配线网常称为<code>无源光网络PON（Passive Optical Network）</code><br><img src="https://cdn.nafx.top/post_cover/%E6%97%A0%E6%BA%90%E5%85%89%E9%85%8D%E7%BA%BF%E7%BD%91%E7%BB%84%E6%88%90.png" alt="无源光配线网组成"></p><p>&emsp;&emsp;<code>光线路终端OLT（Optical Line Terminal）</code>是连接到光纤干线的终端设备。OLT把收到的下行数据发往无源的1:N<code>光分路器（splitter）</code>，然后用广播方式向所有用户端的<code>光网络单元ONU（Optical Network Unit）</code>发送。典型的光分路器使用分路比是1:32每个ONU根据特有的标识只接收发送给自己的数据，然后转换为电信号发往用户家中。<br>&emsp;&emsp;OLT则给各ONU分配适当的光功率。当ONU发送上行数据时，先把电信号转换为光信号，光分路器把各ONU发来的上行数据汇总后，以TDMA方式发往OLT，而发送时间和长度都由OLT集中控制，以便有序地共享光纤主干。光配线网采用波分复用，上行和下行分别使用不同的波长。</p><p>&emsp;&emsp;无源光网络PON的种类很多，主流的有以下两种。</p><ul><li>以太网无源光网络EPON（Ethernet PON）。EPON在链路层使用以太网协议，利用PON的拓扑结构实现了以太网的接入。优点是：与现有以太网兼容性好，成本低，扩展性强，管理方便。</li><li>吉比特无源光网络GPON（Gigabit PON）。GPON采用通用封装方法GEM（Generic Encapsulation Method），可承载多业务，对各种业务类型都能够提供服务质量保证，总体性比EPON好。GPON成本稍高。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学记笔记 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络体系结构（一）</title>
      <link href="/archives/25f94f9.html"/>
      <url>/archives/25f94f9.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;两个计算机要想相互通信必须高度协调工作，这种“协调”比较复杂，因此需要分层，也就是分而治之的方法，将庞大而复杂的问题转化为若干个较小的易于研究和解决的局部问题。</p><p>&emsp;&emsp;最早因为市场上不同公司都使用自己的标准，使用同一个公司生产的设备可以容易的互联成网，但如果购买了其他公司的产品就很难互相连通，为了解决这个问题国际标准化组织ISO于1977年成立了专本的机构研究该问题，不久后便提出了一个试图使各种计算机在世界范围内互联成网的标准框架，即<code>开放系统互连基本参考模型 OSI/RM (Open Systems Interconnection Reference Model)</code>，简称<code>OSI模型</code>,此模型是个抽象的概念（排除和互联无关的部分，仅考虑和互联有关的部分），在1983年形成了正式文件即<code>ISO 7498</code>国际标准，也就是所谓的七层协议的体系结构。</p><p>&emsp;&emsp;到了20世纪90年代初期，虽然整套的OSI国际标准都已经制定出来了，但由于基于TCP/IP的互联网已抢先在全世界覆盖了相当大的范围，同时却几乎找不到什么厂家生产出符合OSI标准的商用产品。一般来说网络技术和设备只有符合国际标准才能大范围地获得工程上的应用，但现在情况却反过来了。得到最广泛应用的不是法律上的国际标准<code>OSI</code>，而是非国际标准的因特网 (Internet) 的通信协议<code>TCP/IP</code>，这样<code>TCP/IP</code>协议便被称为事实上的国际标准，<code>TCP/IP</code>协议也就是所谓的四层协议的体系结构。</p><h2 id="五层协议的体系结构"><a href="#五层协议的体系结构" class="headerlink" title="五层协议的体系结构"></a>五层协议的体系结构</h2><p>关于协议分层的好处这里单独说明下：</p><ol><li>各层之间相互独立：某一层并不需要知道它的下一层是如何实现的，仅需要知道该层通过层间的接口所提供的服务，由于每层只实现一种相对独立的功能，因而可以将一个复杂问题分解。</li><li>灵活性好：当任何一层发生变化时只要层间接口关系保持不变，则上下各层均不受影响。</li><li>结构上可分割：各层都可以采用最合适的技术来实现。</li><li>易于实现和维护：因为整个的系统已被分解为若干个相对独立的子系统，所以使得实现和调试更容易。</li><li>促进标准化工作：每一层的功能及其所提供的服务都已有了精确的说明。</li></ol><p><img src="https://cdn.nafx.top/post_cover/NetworkArchitecture.jpg" alt="计算机网络体系结构"></p><p>&emsp;&emsp;我们把计算机网络的各层及其协议的集合称为网络的<code>体系结构(architecture)</code>,也就是说计算机网络的体系结构就是这个计算机网络及其构件所应完成的功能的精确定义。而这些功能究竟是用什么硬件或软件完成的则是一个<code>实现（implementation）</code>问题。换句话来说<code>体系结构是抽象的，而实现是具体的，是真正在运行的计算机硬件和软件</code>。</p><p>&emsp;&emsp;OSI的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用。已经非常广泛应用的TCP/IP则不同，TCP/IP是一个四层的体系结构，不过从本质上讲它只有最上面三层，因为最下面的网络接口层和一般的通信链路在功能上并没有什么差别，因此在学习计算机网络原理时折中采用一种有五层协议的体系结构。</p><h3 id="应用层（application-layer）"><a href="#应用层（application-layer）" class="headerlink" title="应用层（application layer）"></a>应用层（application layer）</h3><p>&emsp;&emsp;应用层是体系结构中的最高层直接为用户的应用进程提供服务，应用层的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是<code>应用进程（process 指主机中正在运行的程序）</code>间通信和交互的规则。互联网中应用层协议很多，如支持万维网应用的HTTP协议、支持电子邮件的SMTP协议、支持文件传送的FTP协议等等，应用层交互数据的单元称为<code>报文（message）</code>。</p><p>&emsp;&emsp;需要说明的是五层协议中的应用层实际包含了OSI标准的应用层、表示层、会话层三层的功能。</p><ul><li>其中会话层的功能是通信管理，负责建立和断开通信链接（数据的逻辑通路）并管理下其下的层。</li><li>表示层的功能是将设备固有的数据格式和网络标准数据格式的转换，比如将收到的数据转换成图像、声音格式等。</li><li>应用层则单独是针对特定应用的协议。</li></ul><h3 id="运输层（transport-layer）"><a href="#运输层（transport-layer）" class="headerlink" title="运输层（transport layer）"></a>运输层（transport layer）</h3><p>&emsp;&emsp;运输层由操作系统支持，它的任务就是负责向两个主机进程之间的通信提供通用的数据传输服务，确保数据可靠的传送到目标地址。由于一个主机可同时运行多个进程，因此为满足多个进程通信运输层有<code>复用</code>和<code>分用</code>的功能(复用就是多个应用层进程同时使用下面运输层的服务，分用则是运输层把收到的信息分别交付上面应用层中相应的进程)。运输层主要使用以下两种协议：</p><ul><li><code>传输控制协议 TCP (Transmission Control Protocol)</code> 提供面向连接的、可靠的数据传输服务，其数据传输的单元是<code>报文段（segment）</code>。</li><li><code>用户数据协议 UDP (User Datagram Protocol)</code> 提供无连接的、尽最大努力(bset-effort)的数据传输服务(不提供数据传输的可靠性)，其数据传输的单元是<code>用户数据报</code>。</li></ul><p>一般来说，TCP对应的是可靠性要求高的应用，而UDP对应的则是可靠性要求低、传输经济的应用。 TCP支持的应用协议主要有：Telnet、FTP、SMTP等； UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）等。</p><h3 id="网络层-（network-layer）"><a href="#网络层-（network-layer）" class="headerlink" title="网络层 （network layer）"></a>网络层 （network layer）</h3><p>&emsp;&emsp;网络层由操作系统支持，它负责为分组交换网上不同的主机提供通信服务，在发送数据时网络层把运输层产生的<code>报文段(segment)</code>或<code>用户数据报</code>封装成<code>分组</code>或<code>包(packet)</code>进行传送，在目前用的TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做<code>IP数据报</code>，或简称为<code>数据报(datagram)</code>。其传输的数据单元称为<code>数据包</code>。<br>&emsp;&emsp;网络层的另一个任务就是提供地址管理和路由选择功能，使源主机运输层所传下来的分组能够通过网络中的路由器找到目的主机。<br><img src="https://cdn.nafx.top/post_cover/20221017164910.png" alt="网络层提供服务"></p><h3 id="数据链路层（data-link-layer）"><a href="#数据链路层（data-link-layer）" class="headerlink" title="数据链路层（data link layer）"></a>数据链路层（data link layer）</h3><p>&emsp;&emsp;链路层由设备硬件和驱动程序支持常简称为链路层，属于计算机网络的低层，任务是在两个相邻节点间(主机和路由间或路由间)传送和识别数据帧(链路层将网络层交下来的IP数据报组装成<code>数据帧(framing)</code>发送到<code>链路(到相邻结点的物理线路)</code>上，以及把收到的帧中的数据取出并上交给网络层，在链路上“透明”地传送帧中的数据)，每一帧包括数据和必要的控制信息(如同步信息，地址信息，差错控制等)。</p><p><img src="https://cdn.nafx.top/post_cover/20221013163039.png" alt="数据链路层的地位"></p><p>&emsp;&emsp;数据链路层的协议有许多种，这取决于系统选用的硬件设备等，但有<code>三个基本的问题</code>是共同的。</p><ol><li><p>封装成帧： 就是在一段数据的前后分别添加首部和尾部，接收端在收到物理层上交的比特流后就能根据首部和尾部的标记识别出帧的开始和结束。一个帧的帧长等于数据部分的长度加上帧首部和尾部的长度。首部尾部的一个重要作用就是进行帧定界，此外还包括许多必要的控制信息。为了提高帧的传输效率应当使数据部分的长度尽可能的大于首部和尾部的长度，但是每一种链路层协议都规定了所能传送的数据部分的长度上限——<code>最大传送单元MTU(maximum Transfer Unit)</code>。当数据在传输中出现差错时帧的界定符的作用更加明显，假如发送端尚未发送完一个帧时突然出了故障中断了发送，但随后又恢复了正常，重新从头发送刚才未发送完的帧。由于使用了帧界定符，接收端就知道前面收到的数据只有首部<code>开始控制符SOH(Start Of Header)</code>而没有<code>传输结束符EOT(End Of Transmission)</code>必须丢弃，而后面收到的数据有明确的帧界定符因此是一个完整的帧应该收下。<code>（这里的SOH EOT都是ASCII码的控制字符，他们的十六进制和二进制编码分别是 SOH:0x01 00000001和EOT: 0x04 00000100）</code></p></li><li><p>透明传输： 由于帧的开始和结束的标记是专门指明的控制字符，因此所传输的数据中任何8比特的组合一定不允许和用作帧界定的控制字符的比特编码一样，否则就会出现错误。透明表示实际存在的事物看起来好像不存在，也就是在数据链路层无论什么样的比特组合都可以通过。为了解决透明传输的问题，在传输的的数据部分如果出现控制字符<code>SOH</code>或<code>EOT</code>，发送端都会在前面插入一个<code>转义字符ESC(0x1B 00011011)</code>，接收端的数据链路层会在把数据送往网络层前删除这个转义字符。如果转义字符也出现在数据当中，那么就在前面再插入一个转义字符，接收端收到两个连续的转义字符时就删除前面一个，这种解决透明传输的方法称为<code>字节填充(byte stuffing)</code>。<br><img src="https://cdn.nafx.top/post_cover/20221013183905.png" alt="字节填充"></p></li><li><p>差错检测： 通讯链路在传输时不可避免会产生差错，差错控制有两种，分别是位差错和帧差错。如由于信号噪声等情况原本的0变成1或1变为0，这种情况称为<code>比特(位)差错</code>。传输错误的比特占总传输比特的比率称为<code>误码率BER(Bit Error Rate)</code>。所以为了保证数据传输的可靠性会采取各种差错检测措施，目前在链路层广泛使用<code>循环冗余检验CRC(Cyclic Redundancy Check)</code>的检错技术。帧差错有三种可能分别是帧丢失，帧重复，帧失序，因此还要在CRC检错的基础上加上帧编号、确认和重传机制。</p></li></ol><p>&emsp;&emsp;在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始到哪个比特结束，这样链路层在收到一个帧后就可以从中提取出数据部分上交给网络层。控制信息还使接收端能够检测到所收到的帧中有无差错，如发现差错链路层就简单的丢弃这个帧，以免继续在网络中算传送下去浪费网络资源。还可以采用可靠的传输协议来纠正出现的差错，当然这种方法会使链路层的协议复杂些。</p><p><img src="https://cdn.nafx.top/post_cover/20221011202846.png" alt="三层简化模型"></p><p>差错控制的原理很简单，就是在被传送的K位信息后附加r位的冗余位，接收方对收到的信息应用同一算法，将结果与发送方的结果进行比较，若不相等则数据出现了差错。如果接收方知道有差错发生，但不知道是怎样的差错，然后向发送方请求重传，这种策略称为检错；如果接收方知道有差错，而且知道是怎样的差错，这种策略称为纠错。对于通信质量良好的有线传输链路数据链路层协议不适用确认和重传机制，即不要求数据链路层向上提供可靠的传输服务。如果在数据链路层传输数据时出现了差错并且需要进行改正，那么改正差错的任务就由上层协议（例如，运输层的TCP协议）来完成。而对于通信质量较差的无线传输链路，数据链路层协议使用确认和重传机制，数据链路层向上提供可靠传输的服务。</p><h3 id="物理层（physical-layer）"><a href="#物理层（physical-layer）" class="headerlink" title="物理层（physical layer）"></a>物理层（physical layer）</h3><p>&emsp;&emsp;物理层由传输的网络接口支持，在物理层上传输的数据单元是数据位比特(bit)，物理层的任务就是透明地传送比特流。它界定了与传输媒体的接口有关(连接器和网线等)的规格，物理层要考虑：</p><ol><li>机械特性：明确接口所用连接器的尺寸和形状，引脚数目和排列，固定和锁定装置(如我们现在常见的光纤和RJ45接口)等等。</li><li>电气特性：规定了物理连接上接口电缆的各条导线的电气连接及有关电路特性。例如电压的范围。</li><li>功能特性：指明物理接口各条信号线的用途等。例如数据信号线、控制信号线和用多大的电压代表”1”或”0”等。</li><li>过程特性：也就是通信协议，指明利用接口传输比特流的全过程。例如事件可能的出现顺序和执行顺序。</li></ol><p>&emsp;&emsp;而且一般在数据在传输媒体上都是串行传输，但在计算机中多采用并行方式因此物理层还要完成传输方式的转换。</p><p>&emsp;&emsp;这里物理层考虑的是怎么样在连接各种计算机的传输媒体上传输数据比特流，而不是指<code>具体的传输媒体</code>(如双绞线、同轴电缆、光缆、无线信道等，这些具体的物理媒体可以当作第0层)。物理层尽可能的屏蔽掉这些传输媒体和通信手段的差异，使上面的数据链路层感觉不到这些差异。用于物理层的协议也常被称为物理层规程(procedure)。</p><p><img src="https://cdn.nafx.top/post_cover/%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%90%84%E5%B1%82%E9%97%B4%E4%BC%A0%E9%80%92%E8%BF%87%E7%A8%8B.png" alt="数据在各层间传递过程"></p>]]></content>
      
      
      <categories>
          
          <category> 学记笔记 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL2内使用Windows的v2ray代理</title>
      <link href="/archives/88ca14b9.html"/>
      <url>/archives/88ca14b9.html</url>
      
        <content type="html"><![CDATA[<h1 id="WSL2内使用Windows的v2ray代理"><a href="#WSL2内使用Windows的v2ray代理" class="headerlink" title="WSL2内使用Windows的v2ray代理"></a>WSL2内使用Windows的v2ray代理</h1><blockquote><p>在WSL2中使用install或git命令是总是因为网速问题失败，我们在部署配置环境时就最好需要使用代理，但WSL2 因为是通过虚拟机的方式实现,网络不再像 WSL1 一样与 Windows 共享,变成了一个新的网段,所以想使用宿主机的代理就比较麻烦，这里参考网上资料这里给出设置方法。</p></blockquote><h2 id="一、Windows内设置"><a href="#一、Windows内设置" class="headerlink" title="一、Windows内设置"></a>一、Windows内设置</h2><h3 id="v2ray客户端开启允许来自局域网的连接"><a href="#v2ray客户端开启允许来自局域网的连接" class="headerlink" title="v2ray客户端开启允许来自局域网的连接"></a>v2ray客户端开启允许来自局域网的连接</h3><p><img src="https://s2.loli.net/2022/07/21/ZAP2XURyg8BG3Y9.png" alt="v2ray客户端开启允许来自局域网的连接"></p><h2 id="二、WSL2内设置"><a href="#二、WSL2内设置" class="headerlink" title="二、WSL2内设置"></a>二、WSL2内设置</h2><h3 id="1-修改DNS服务器地址"><a href="#1-修改DNS服务器地址" class="headerlink" title="1. 修改DNS服务器地址"></a>1. 修改DNS服务器地址</h3><p>修改由于使用代理不能再通过宿主机IP获取<code>nameserver</code>,这里在<code>/etc/resolv.conf</code>直接设置<code>nameserver</code>为GoogleDNS地址<code>8.8.8.8</code>或者其他可用的dns服务器地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf:</span></span><br><span class="line"><span class="comment"># [network]</span></span><br><span class="line"><span class="comment"># generateResolvConf = false</span></span><br><span class="line"></span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><p>根据此注释可以看到这个文件是由 WSL 自动生成的。也就是每次自动生成就会覆盖掉我们对<code>nameserver</code>的修改，要停止自动生成此文件要在<code>/etc/wsl.conf</code>中设置<code>generateResolvConf</code>为<code>false</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[network]</span><br><span class="line">generateResolvConf = <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="2-获取主机IP并设置代理"><a href="#2-获取主机IP并设置代理" class="headerlink" title="2. 获取主机IP并设置代理"></a>2. 获取主机IP并设置代理</h3><p>WSL2 会在首次启动时创建一个虚拟网卡用于提供 WSL2 的网络，默认情况下这个网段是动态，这里我们使用<code>ip route</code>命令在网络路由信息中找到主机在WSL2中映射的IP地址。</p><p><img src="https://s2.loli.net/2022/07/21/HFM7YphuR9w4Xes.png" alt="ip route"></p><p>有了主机IP之后我们就可以通过v2ray中设置的端口设置代理了（v2ray中默认本地监听端口为<code>10808</code>）  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&#x27;socks5://主机IP:&lt;Port&gt;&#x27;</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&#x27;socks5://主机IP:&lt;Port&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>设置完之后可以用<code>curl -v google.com</code>测试下。</p><h3 id="3-编辑bashrc配置文件实现代理命令"><a href="#3-编辑bashrc配置文件实现代理命令" class="headerlink" title="3. 编辑bashrc配置文件实现代理命令"></a>3. 编辑bashrc配置文件实现代理命令</h3><p>在主目录中找到bash的隐藏配置文件<code>.bashrc</code>，在文件后面加入以下代码，后面就可以使用<code>proxy</code>命令和<code>unproxy</code>命令实现代理或取消代理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># add for proxy</span></span><br><span class="line"><span class="comment"># add for proxy</span></span><br><span class="line"><span class="built_in">export</span> hostip=$(ip route | grep default | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>)</span><br><span class="line"><span class="built_in">export</span> hostport=10808</span><br><span class="line"><span class="built_in">alias</span> proxy=<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    export HTTPS_PROXY=&quot;socks5://$&#123;hostip&#125;:$&#123;hostport&#125;&quot;;</span></span><br><span class="line"><span class="string">    export HTTP_PROXY=&quot;socks5://$&#123;hostip&#125;:$&#123;hostport&#125;&quot;;</span></span><br><span class="line"><span class="string">    export ALL_PROXY=&quot;socks5://$&#123;hostip&#125;:$&#123;hostport&#125;&quot;;</span></span><br><span class="line"><span class="string">    git config --global http.proxy &quot;socks5://$&#123;hostip&#125;:$&#123;hostport&#125;&quot;;</span></span><br><span class="line"><span class="string">    git config --global https.proxy &quot;socks5://$&#123;hostip&#125;:$&#123;hostport&#125;&quot;;</span></span><br><span class="line"><span class="string">    echo -e &quot;Acquire::http::Proxy \&quot;http://$&#123;hostip&#125;:$&#123;hostport&#125;\&quot;; &quot; | sudo tee -a /etc/apt/apt.conf.d/proxy.conf;</span></span><br><span class="line"><span class="string">    echo -e &quot;Acquire::https::Proxy \&quot;http://$&#123;hostip&#125;:$&#123;hostport&#125;\&quot;; &quot; | sudo tee -a /etc/apt/apt.conf.d/proxy.conf;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> unproxy=<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    unset HTTPS_PROXY;</span></span><br><span class="line"><span class="string">    unset HTTP_PROXY;</span></span><br><span class="line"><span class="string">    unset ALL_PROXY;</span></span><br><span class="line"><span class="string">    git config --global --unset  http.proxy;</span></span><br><span class="line"><span class="string">    git config --global --unset  https.proxy;</span></span><br><span class="line"><span class="string">    sudo sed -i -e &#x27;</span>/Acquire::http::Proxy/d<span class="string">&#x27; /etc/apt/apt.conf.d/proxy.conf;</span></span><br><span class="line"><span class="string">    sudo sed -i -e &#x27;</span>/Acquire::https::Proxy/d<span class="string">&#x27; /etc/apt/apt.conf.d/proxy.conf;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="三、测试效果"><a href="#三、测试效果" class="headerlink" title="三、测试效果"></a>三、测试效果</h2><p>用户对 bashrc 所作的任何更改将在您下次启动终端时应用，如果想立即生效可以手动执行如下命令刷新:  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>重启终端或刷新配置文件后</p><p><img src="https://s2.loli.net/2022/07/21/S1V3Fivd6Z4EDh7.png" alt="测试效果"></p><h2 id="四、错误排查"><a href="#四、错误排查" class="headerlink" title="四、错误排查"></a>四、错误排查</h2><p>如果配置不起作用或报错需排查以下：</p><h3 id="1-DNS服务器地址设置错误"><a href="#1-DNS服务器地址设置错误" class="headerlink" title="1. DNS服务器地址设置错误"></a>1. DNS服务器地址设置错误</h3><p>ping youtube.com  测试是否解析出IP（解析出IP之后最后全部丢包没关系，只要解析出域名对应的IP），否则需要验证是否正确配置DNS服务器地址。</p><h3 id="2-环境变量是否正确导出"><a href="#2-环境变量是否正确导出" class="headerlink" title="2. 环境变量是否正确导出"></a>2. 环境变量是否正确导出</h3><p>通过输出<code>echo $HTTP_PROXY</code>查看环境变量是否正确导出</p><h3 id="3-防火墙是否开启"><a href="#3-防火墙是否开启" class="headerlink" title="3. 防火墙是否开启"></a>3. 防火墙是否开启</h3><p>如在WSL2中ping主机不通，需在Windows系统中检查防火墙和网络保护界面中的防火墙设置，是否允许应用通过防火墙。</p><h3 id="4-主机端v2ray是否可用"><a href="#4-主机端v2ray是否可用" class="headerlink" title="4. 主机端v2ray是否可用"></a>4. 主机端v2ray是否可用</h3><p>如果检查各项配置都确认正确需检查主机端v2ray是否正常可用，可在windows terminal下运行<code>curl youtube.com</code>验证。</p><h3 id="5-etc-resolv-conf重启丢失"><a href="#5-etc-resolv-conf重启丢失" class="headerlink" title="5. /etc/resolv.conf重启丢失"></a>5. /etc/resolv.conf重启丢失</h3><p>如果之前代理正常，WSL2重启之后代理不可用，需检查<code>/etc/resolv.conf</code>文件是否丢失或被重置为默认。<br>造成这种情况的原因有很多，但在WSL中大概率是被系统重置了，我们这里直接使用<code>resolvconfig</code>应用实现DNS信息管理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install resolvconf</span><br></pre></td></tr></table></figure><p>安装后配置<code>/etc/resolvconf/resolv.conf.d/base</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><p>配置好后使用<code>resolvconf -u</code>更新resolvconf应用并使用下面命令查看并启动服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service resolvconf start</span><br><span class="line">service --status-all</span><br></pre></td></tr></table></figure><p>或直接配置好<code>/etc/resolv.conf</code>文件后使用<code>chattr</code>命令改变其文件属性不得任意更动文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /etc/resolv.conf</span><br><span class="line">sudo bash -c <span class="string">&#x27;echo &quot;nameserver 8.8.8.8&quot; &gt; /etc/resolv.conf&#x27;</span></span><br><span class="line">sudo bash -c <span class="string">&#x27;echo &quot;[network]&quot; &gt; /etc/wsl.conf&#x27;</span></span><br><span class="line">sudo bash -c <span class="string">&#x27;echo &quot;generateResolvConf = false&quot; &gt;&gt; /etc/wsl.conf&#x27;</span></span><br><span class="line">sudo chattr +i /etc/resolv.conf</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WSL </tag>
            
            <tag> v2ray代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电视盒子做小型服务器（华为海思Hi3798Mv100）</title>
      <link href="/archives/7f84f586.html"/>
      <url>/archives/7f84f586.html</url>
      
        <content type="html"><![CDATA[<h1 id="电视盒子做小型服务器（华为海思Hi3798Mv100）"><a href="#电视盒子做小型服务器（华为海思Hi3798Mv100）" class="headerlink" title="电视盒子做小型服务器（华为海思Hi3798Mv100）"></a>电视盒子做小型服务器（华为海思Hi3798Mv100）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>翻找东西时发现了闲置的一个电信电视盒子，在网上查找了下相关资料挺多的，而且其SDK已经公开，盒子主控是华为海思Hi3798Mv100，四核ARM Cortex A7，主频高达1.5GHz，我这个是1G内存8G的存储的版本，有SD卡槽和两个USB接口，可以外接存储设备扩展，还有蓝牙WIFI功能，功耗仅有3w左右，刷上Ubuntu系统后可玩性非常高，下面就改造下使其变成一个小型的服务器。</p><h2 id="拆机硬件"><a href="#拆机硬件" class="headerlink" title="拆机硬件"></a>拆机硬件</h2><p>拧下前面脚垫下方的两个螺丝后就可以用撬板撬下外壳，上下外壳有卡扣连接，没有撬板的话用螺丝刀慢慢撬也可以，只不过会留下些痕迹。</p><p><img src="https://cdn.nafx.top/post_cover/20220902231805.png" alt="拆机网图"></p><p>之前拆开忘记拍了这里补一个拆机网图，可以清楚的看到板子上的外设，两片南亚的512MB的闪存，背面一片8GB的闪迪eMMC芯片，瑞昱的RTL8188FTV低功耗无线芯片 ，双USB2.0接口。</p><p>在这个SD卡槽边上有一个预留的调试串口，我们可以自己焊上个座子然后用杜邦线连接好USB转串口的模块来烧录固件。</p><p><img src="https://cdn.nafx.top/post_cover/69743ba1d160e9779cca79cada51e68.jpg" alt="调试串口"></p><p>可以看到cpu是通过散热片被动散热的，后面用起来时温度总是太高，所以这里又拆开加了一个5V的小风扇辅助散热。</p><p><img src="https://cdn.nafx.top/post_cover/Hi3798Mv100.jpg" alt="散热风扇"></p><h2 id="烧录固件"><a href="#烧录固件" class="headerlink" title="烧录固件"></a>烧录固件</h2><p>这里直接使用神雕(Teasiu)大佬编译好的固件，是一个可以直接使用的支持docker的内核，运行Ubuntu 20.04.4 LTS 服务器系统。</p><p>HiTool海思烧录工具:<a href="https://oss.histb.com/HiTool-windows.7z">https://oss.histb.com/HiTool-windows.7z</a><br>固件下载:<a href="https://dl.ecoo.top:2096/">https://dl.ecoo.top:2096/</a></p><p>下载烧录工具和固件后，通过USB转串口模块连接好板子和计算机，接好12V电源和网线，打开烧录工具，记住要选择好对应的芯片型号，然后选择USB转串口模块对应的串口，选择好烧写的xml文件，选择烧写eMMC后就可以点击烧录了。</p><p><img src="https://cdn.nafx.top/post_cover/3e8f6202bb56899057ed6bfb02f5bfa.png" alt="固件烧录"></p><p>板子重新上电后会自动开始烧录，烧写完成后从路由器中查到板子获取到的IP后就可以通过SSH工具登录。</p><h2 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h2><p>使用SSH默认账号root密码1234登录。</p><p><img src="https://cdn.nafx.top/post_cover/20220903102301.png" alt="初次登陆"></p><h3 id="1-更新软件"><a href="#1-更新软件" class="headerlink" title="1.更新软件"></a>1.更新软件</h3><p>在做操作之前首先要更新下我们的索引和更新下软件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt update &amp;&amp; apt upgrade </span><br></pre></td></tr></table></figure><p><img src="https://cdn.nafx.top/post_cover/20220903113220.png" alt="更新软件"></p><h3 id="2-修改默认账号密码"><a href="#2-修改默认账号密码" class="headerlink" title="2.修改默认账号密码"></a>2.修改默认账号密码</h3><p>对于初始的默认账户root和ubuntu我们需要更改下它们的密码。</p><p><img src="https://cdn.nafx.top/post_cover/20220903114544.png" alt="修改密码"></p><h3 id="3-配置SSH服务"><a href="#3-配置SSH服务" class="headerlink" title="3.配置SSH服务"></a>3.配置SSH服务</h3><h4 id="a-更改SSH端口"><a href="#a-更改SSH端口" class="headerlink" title="a.更改SSH端口"></a>a.更改SSH端口</h4><p>首先更改掉SSH服务的默认22端口,一般建议把它改成一个大于1024小于65535的整数。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nafx.top/post_cover/20220903114933.png" alt="更改SSH端口"></p><h4 id="b-禁止root登录"><a href="#b-禁止root登录" class="headerlink" title="b.禁止root登录"></a>b.禁止root登录</h4><p>同样是修改<code>sshd_config</code>文件，在下方把<code>PermitRootLogin</code>一项参数改为<code>no</code></p><p><img src="https://cdn.nafx.top/post_cover/20220903122044.png" alt="禁止root登录"></p><p>退出并保存后重启ssh服务让变更生效。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service sshd restart</span><br></pre></td></tr></table></figure><p>这时不要关闭当前ssh串口，开启另一窗口测试。修改ssh登录的端口这时再用root登录就会提示ssh服务拒绝了密码，我们可以用ubuntu用户登录或者自己使用<code>adduser xxx</code>新建普通用户登录，记得要使用<code>visudo</code>命令赋予新建的用户sudo权限。</p><h4 id="c-启用密钥验证登录并禁止密码登录"><a href="#c-启用密钥验证登录并禁止密码登录" class="headerlink" title="c.启用密钥验证登录并禁止密码登录"></a>c.启用密钥验证登录并禁止密码登录</h4><p>所谓的<code>密钥验证</code>，就是生成<code>一对</code>相关联的密钥文件（公钥和私钥），然后把<code>公钥</code>上传到服务器。每次登录时，SSH 会将<code>公钥</code>和<code>私钥</code>进行匹配，若验证是正确的<code>密钥对</code>，则验证通过。（换言之，你无需记忆和输入复杂的密码，只要保护好<code>私钥</code>这个文件不外泄即可）。</p><p>如果你本地使用的是Linux或者是macOS系统可以在本机通过命令生成密钥对。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;&lt;CLIENT-NAME&gt;&quot;</span></span><br></pre></td></tr></table></figure><p>或者直接通过软件生成再上传到服务器上，这里通过本地ssh工具生成密钥对，然后在服务器创建.ssh文件夹，将公钥保存成名为authorized_keys的文件。</p><p><img src="https://cdn.nafx.top/post_cover/20220903135229.png" alt="保存公钥"></p><p>然后修改<code>.ssh</code>目录权限为700，修改<code>authorized_keys</code>文件权限为 600 （仅所有者可读可写）。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 ~/.ssh</span><br><span class="line">chmod 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nafx.top/post_cover/20220903140459.png" alt="修改权限"></p><p>然后配置ssh文件，搜索PasswordAuthentication（设置是否使用口令验证）选项把参数yes改成no,并将PubkeyAuthentication（用来设置是否开启公钥验证）选项的参数改为yes。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>修改完成后退出并保存，依然需要重启ssh服务让变更生效。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service sshd restart</span><br></pre></td></tr></table></figure><p>现在只能通过密钥对来连接上这台服务器了。</p><h3 id="4-设置静态IP地址"><a href="#4-设置静态IP地址" class="headerlink" title="4.设置静态IP地址"></a>4.设置静态IP地址</h3><p>通过修改配置文件设置静态IP地址。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/network/interfaces.d/eth0</span><br></pre></td></tr></table></figure><p>在<code>address</code>处填入要更改的IP地址，<code>netmask </code>处填掩码一般不变，<code>broadcast</code>广播地址后面的255表示向在本地网络当中所有主机广播，<code>gateway</code>处填入网关路由器的地址，<code>dns-nameservers</code>处可以填些dns地址也可以同样填网关路由器地址使用网关的dns，最后一行处可以修改网口的MAC地址。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">address 192.168.1.x</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">broadcast 192.168.1.255</span><br><span class="line">gateway 192.168.1.1</span><br><span class="line">dns-nameservers 192.168.1.1</span><br><span class="line">pre-up ifconfig eth0 hw ether 00:11:22:44:55:66</span><br></pre></td></tr></table></figure><p>修改完成后保存退出，重启让配置立即生效并使用新IP地址连接。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl reboot </span><br></pre></td></tr></table></figure><h3 id="5-卸载不需要的预装软件-自选"><a href="#5-卸载不需要的预装软件-自选" class="headerlink" title="5.卸载不需要的预装软件(自选)"></a>5.卸载不需要的预装软件(自选)</h3><p>在用户目录新建一个<code>uninstall.sh</code>脚本文件并输入以下内容，具体需要卸载的工具可以通过注释自行选择。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 正在卸载预装软件</span><br><span class="line"><span class="comment">#PHP</span></span><br><span class="line">systemctl stop php*</span><br><span class="line">sudo apt-get autoremove php* -y</span><br><span class="line">sudo find / -name <span class="string">&quot;*php*&quot;</span> |xargs  rm -rf</span><br><span class="line"></span><br><span class="line"><span class="comment">#Nginx</span></span><br><span class="line">systemctl stop nginx*</span><br><span class="line">sudo apt-get autoremove nginx* -y</span><br><span class="line">sudo find / -name <span class="string">&quot;*nginx*&quot;</span> |xargs  rm -rf</span><br><span class="line"></span><br><span class="line">rm -rf /var/www</span><br><span class="line"></span><br><span class="line"><span class="comment">#Aria2</span></span><br><span class="line">systemctl stop aria*</span><br><span class="line">sudo apt-get autoremove aria2 -y</span><br><span class="line">sudo find / -name <span class="string">&quot;*aria2*&quot;</span> |xargs  rm -rf</span><br><span class="line"></span><br><span class="line"><span class="comment">#Transmission</span></span><br><span class="line">systemctl stop transmission*</span><br><span class="line">apt-get autoremove transmission* -y</span><br><span class="line">sudo find / -name <span class="string">&quot;*transmission*&quot;</span> |xargs  rm -rf</span><br><span class="line"></span><br><span class="line"><span class="comment">#页面终端</span></span><br><span class="line">systemctl stop ttyd.service</span><br><span class="line">sudo find / -name <span class="string">&quot;*ttyd*&quot;</span> |xargs  rm -rf</span><br><span class="line"></span><br><span class="line"><span class="comment">#KMS</span></span><br><span class="line">sudo find / -name <span class="string">&quot;*vlmcsd*&quot;</span> |xargs  rm -rf</span><br><span class="line"></span><br><span class="line"><span class="comment">#FRP</span></span><br><span class="line">systemctl stop frpc.service</span><br><span class="line">sudo find / -name <span class="string">&quot;*frp*&quot;</span> |xargs  rm -rf</span><br><span class="line"></span><br><span class="line"><span class="comment">#NFS</span></span><br><span class="line">apt-get autoremove nfs* -y</span><br><span class="line"></span><br><span class="line"><span class="comment">#FTP</span></span><br><span class="line">systemctl stop vsftpd</span><br><span class="line">apt-get autoremove vsftpd -y</span><br><span class="line">sudo find / -name <span class="string">&quot;*vsftpd*&quot;</span> |xargs  rm -rf</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 预装软件卸载完毕</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 手动关闭6010端口：</span><br><span class="line"><span class="built_in">echo</span> 编辑：vim /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line">netstat -at</span><br></pre></td></tr></table></figure><p>保存退出后<code>sh uninstall.sh</code>运行脚本卸载。</p><h3 id="6-DDNS-解析自动更新（可选）"><a href="#6-DDNS-解析自动更新（可选）" class="headerlink" title="6.DDNS 解析自动更新（可选）"></a>6.DDNS 解析自动更新（可选）</h3><p>默认的ubuntu用户目录下自带阿里域名DDNS解析更新脚本，但首先需要安装nodejs。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nodejs</span><br></pre></td></tr></table></figure><p>安装完成后修改配置文件<code>vim /home/ubuntu/client-mode/config.json</code>填写你的阿里提供的 keyid 和 keysecret, 并填写你需要解析的域名。</p><p>保存并退出, 然后添加计划任务(每 15 分钟检查一次, 外网 IP 变化才自动更新)<br>输入<code>crontab -e</code>，然后输入<code>*/15 * * * * /home/ubuntu/client-mode/client.sh</code>创建计划任务。</p><h3 id="7-安装WIFI驱动"><a href="#7-安装WIFI驱动" class="headerlink" title="7.安装WIFI驱动"></a>7.安装WIFI驱动</h3><blockquote><p>驱动包下载链接:<a href="https://bbs.histb.com/d/18-wifi">https://bbs.histb.com/d/18-wifi</a></p></blockquote><p>先将下载好的驱动包上传到服务器上，这里上传到推荐目录<code>/tmp</code>下.</p><p><img src="https://cdn.nafx.top/post_cover/20220903181856.png" alt="上传驱动包"></p><p>然后需要安装必须软件Linux内核模块工具kmod。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y kmod</span><br></pre></td></tr></table></figure><h4 id="使用安装脚本自动安装"><a href="#使用安装脚本自动安装" class="headerlink" title="使用安装脚本自动安装"></a>使用安装脚本自动安装</h4><p>和驱动包一起的还有一个安装脚本，可以使用脚本进行安装，首先给脚本可执行权限。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x wifi_install.sh</span><br></pre></td></tr></table></figure><p>然后在命令行直接输入<code>sh wifi_install.sh -f 驱动包 [参数1] [参数1] ...</code>就可以安装，具体可用参数如下:</p><blockquote><p>   -f, –file<br>                驱动文件包名称 例如 rtl8188ftv.tar.gz<br>    -s, –ssid<br>                可选，wifi名称<br>    -p, –password<br>                可选，wifi密码<br>    -d, –address<br>                可选，固定ip地址 如 192.168.1.100<br>    -g, –gateway<br>                可选，网关 一般为 网段的第一个IP 如 192.168.1.1，<br>    -m, –netmask<br>                可选，掩码 一般为 255.255.255.0<br>例如：<br>sh wifi_install.sh -f rtl8188ftv-0403.tar.gz -s ChineaNet-X231 -p 123456</p></blockquote><p>备注：</p><ul><li>运行命令后会提示“安装成功”，此时驱动安装完成。</li><li>如果使用了 -s 参数，脚本会尝试连接wifi，成功后提示“连接成功”，</li><li>如果填入了 -d 参数，脚本会尝试修改wifi配置，成功后提示“修改地址成功”，</li><li>想修改WIFI配置的话可以使用命令 nmcli connection delete “wifi名字”之后再使用本脚本重新配置，此时可无需使用 -f 参数。</li></ul><h4 id="手动安装WiFi驱动"><a href="#手动安装WiFi驱动" class="headerlink" title="手动安装WiFi驱动"></a>手动安装WiFi驱动</h4><h4 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h4><h5 id="1-重新插拔网线后wifi不能使用"><a href="#1-重新插拔网线后wifi不能使用" class="headerlink" title="1.重新插拔网线后wifi不能使用"></a>1.重新插拔网线后wifi不能使用</h5><p>这是因为重新插网线后系统就增加一条优先级更高的默认路由，所有数据都从eth0接口出，导致通过wlan0的地址不能正常访问盒子了，只能手动删除默认的两个路由地址。<br>这里可以写个每次开机自动运行的脚本在每次开机删除默认路由地址。<br>首先创建rc-local.service文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /lib/systemd/system/rc-local.service /etc/systemd/system</span><br></pre></td></tr></table></figure><p>然后修改<code>/etc/systemd/system/rc-local.service</code>，在文件最下方添加:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Install]   </span><br><span class="line">WantedBy=multi-user.target   </span><br><span class="line">Alias=rc-local.service</span><br></pre></td></tr></table></figure><p>再创建<code>/etc/rc.local</code>里面添加:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> `date +<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>` begin &gt;&gt; /tmp/ip_route_del.log</span><br><span class="line"></span><br><span class="line">ip route delete 192.168.31.0/24 dev eth0</span><br><span class="line">ip route delete default</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> `date +<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>` end &gt;&gt; /tmp/ip_route_del.log</span><br><span class="line">ip route delete successfully<span class="string">&quot; &gt;&gt; /tmp/ip_route_del.log</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">exit 0</span></span><br></pre></td></tr></table></figure><p>给/etc/rc.local加上可执行权限</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /etc/rc.local</span><br></pre></td></tr></table></figure><p>最后启动服务让脚本每次开机自动运行，可以使用<code>sudo systemctl status rc-local.service</code>查看当前服务状态。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start rc-local.service</span><br></pre></td></tr></table></figure><h5 id="2-拔掉网线重新启动后获取不到IP地址"><a href="#2-拔掉网线重新启动后获取不到IP地址" class="headerlink" title="2.拔掉网线重新启动后获取不到IP地址"></a>2.拔掉网线重新启动后获取不到IP地址</h5><p>拔掉网线，重新启动盒子时，盒子的启动速度很慢，通过调试串口查看启动信息后发现，系统启动时卡在如下位置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...a start job is running <span class="keyword">for</span> raise network interfaces...</span><br></pre></td></tr></table></figure><p>查网上相关问题后发现，启动这么慢是因为eth0接口的配置参数默认设置成了auto模式，且是DHCP地址获取方式。导致系统长时间尝试为eth0申请获取IP地址，直到超时。</p><p>解决办法就是为eth0配置静态地址，不从DHCP方式获取地址。</p><h3 id="8-自定义美化"><a href="#8-自定义美化" class="headerlink" title="8.自定义美化"></a>8.自定义美化</h3><h4 id="修改-bashrc"><a href="#修改-bashrc" class="headerlink" title="修改.bashrc"></a>修改.bashrc</h4><p>在家目录<code>.bashrc</code>文件后添加下面命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#md folder_name  ==&gt; mkdit folder_name and cd folder_name</span></span><br><span class="line"><span class="function"><span class="title">md</span></span> () &#123;</span><br><span class="line">    mkdir -p <span class="variable">$1</span></span><br><span class="line">    <span class="built_in">cd</span> <span class="variable">$1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># bash颜色配置</span></span><br><span class="line"><span class="comment">#   颜色代码（字体加背景）：\[\e[F;Bm\]</span></span><br><span class="line"><span class="comment">#   \a ASCII 响铃字符（也可以键入 \007）</span></span><br><span class="line"><span class="comment">#   \e ASCII 转义字符（也可以键入 \033）</span></span><br><span class="line"><span class="comment">#   \d ：#代表日期，格式为weekday month date，例如：&quot;Mon Aug 1&quot;   </span></span><br><span class="line"><span class="comment">#   \u ：#当前用户的账号名称   </span></span><br><span class="line"><span class="comment">#   \H ：#完整的主机名称   </span></span><br><span class="line"><span class="comment">#   \h ：#仅取主机的第一个名字  </span></span><br><span class="line"><span class="comment">#   \t ：#显示时间为24小时格式，如：HH：MM：SS   </span></span><br><span class="line"><span class="comment">#   \T ：#显示时间为12小时格式   </span></span><br><span class="line"><span class="comment">#   \A ：#显示时间为24小时格式：HH：MM   </span></span><br><span class="line"><span class="comment">#   \n 换行符</span></span><br><span class="line"><span class="comment">#   \r 回车符</span></span><br><span class="line"><span class="comment">#   \v ：#BASH的版本信息   </span></span><br><span class="line"><span class="comment">#   \w ：#完整的工作目录名称   </span></span><br><span class="line"><span class="comment">#   \W ：#利用basename取得工作目录名称，所以只会列出最后一个目录   </span></span><br><span class="line"><span class="comment">#   \# ：#下达的第几个命令   </span></span><br><span class="line"><span class="comment">#   \$ ：#提示字符，如果是root时，提示符为：# ，普通用户则为：$ </span></span><br><span class="line"><span class="comment">#   \[\e[m\]：将前景、背景和加粗设置重置为它们的默认值，在在提示行结束时使用这个代码，以使您键入的文字成为非彩色的。</span></span><br><span class="line"><span class="built_in">export</span> PS1=<span class="string">&#x27;\[\e[36m\][\[\e[91m\]\u\[\e[m\]@\[\e[95m\]\h \[\e[34m\]\W\[\e[36m\]]\[\e[32m\]\$\[\e[m\]&#x27;</span></span><br></pre></td></tr></table></figure><p>保存退出后使用<code>sourve .bashrc</code>命令使改动马上生效。</p><h4 id="修改登录信息"><a href="#修改登录信息" class="headerlink" title="修改登录信息"></a>修改登录信息</h4><p>修改或新增<code>/etc/profile.d/</code>下的文件自定义登录信息。</p><p><img src="https://cdn.nafx.top/post_cover/20220903161328.png" alt="登录信息"></p><h2 id="安装外壳"><a href="#安装外壳" class="headerlink" title="安装外壳"></a>安装外壳</h2><p>系统软件配置完成后面还可以安装docker在上面跑一些有意思的东西，这里就可以安装外壳了，由于加装了个散热风扇导致整体高度超出外壳了3、4毫米，这里直接把底壳风扇下方开一个合适大小的洞正好可以增强散热效果，然后脚贴也需要加高一部分适配这个开洞的风扇。</p><p><img src="https://cdn.nafx.top/post_cover/%E9%A3%8E%E6%89%87.jpg" alt="底壳"></p><p>到这里一个巴掌大小的功耗仅有3W左右的小服务器就配置好了，平时可以放在桌上或者机箱上也不会有噪音，而且性能还很不错，美观又实用。</p>]]></content>
      
      
      <categories>
          
          <category> LINUX </category>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置美化bash和vim</title>
      <link href="/archives/e8e89f2a.html"/>
      <url>/archives/e8e89f2a.html</url>
      
        <content type="html"><![CDATA[<h1 id="配置美化bash和vim"><a href="#配置美化bash和vim" class="headerlink" title="配置美化bash和vim"></a>配置美化bash和vim</h1><p>bash、vim允许你自定义你的终端，自定义的bash、vim可以实现美化效果，还可以提高你在终端的工作效率，下面我备份的配置文件。</p><h2 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h2><p><code>.bashrc</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.bashrc: executed by bash(1) for non-login shells.</span></span><br><span class="line"><span class="comment"># see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)</span></span><br><span class="line"><span class="comment"># for examples</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If not running interactively, don&#x27;t do anything</span></span><br><span class="line">[ -z <span class="string">&quot;<span class="variable">$PS1</span>&quot;</span> ] &amp;&amp; <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># don&#x27;t put duplicate lines in the history. See bash(1) for more options</span></span><br><span class="line"><span class="comment"># ... or force ignoredups and ignorespace</span></span><br><span class="line">HISTCONTROL=ignoredups:ignorespace</span><br><span class="line"></span><br><span class="line"><span class="comment"># append to the history file, don&#x27;t overwrite it</span></span><br><span class="line"><span class="built_in">shopt</span> -s histappend</span><br><span class="line"></span><br><span class="line"><span class="comment"># for setting history length see HISTSIZE and HISTFILESIZE in bash(1)</span></span><br><span class="line">HISTSIZE=1000</span><br><span class="line">HISTFILESIZE=2000</span><br><span class="line"></span><br><span class="line"><span class="comment"># check the window size after each command and, if necessary,</span></span><br><span class="line"><span class="comment"># update the values of LINES and COLUMNS.</span></span><br><span class="line"><span class="built_in">shopt</span> -s checkwinsize</span><br><span class="line"></span><br><span class="line"><span class="comment"># make less more friendly for non-text input files, see lesspipe(1)</span></span><br><span class="line">[ -x /usr/bin/lesspipe ] &amp;&amp; <span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(SHELL=/bin/sh lesspipe)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set variable identifying the chroot you work in (used in the prompt below)</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$debian_chroot</span>&quot;</span> ] &amp;&amp; [ -r /etc/debian_chroot ]; <span class="keyword">then</span></span><br><span class="line">    debian_chroot=$(cat /etc/debian_chroot)</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set a fancy prompt (non-color, unless we know we &quot;want&quot; color)</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$TERM</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">    xterm-color) color_prompt=yes;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># uncomment for a colored prompt, if the terminal has the capability; turned</span></span><br><span class="line"><span class="comment"># off by default to not distract the user: the focus in a terminal window</span></span><br><span class="line"><span class="comment"># should be on the output of commands, not on the prompt</span></span><br><span class="line"><span class="comment">#force_color_prompt=yes</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$force_color_prompt</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> [ -x /usr/bin/tput ] &amp;&amp; tput setaf 1 &gt;&amp;/dev/null; <span class="keyword">then</span></span><br><span class="line"><span class="comment"># We have color support; assume it&#x27;s compliant with Ecma-48</span></span><br><span class="line"><span class="comment"># (ISO/IEC-6429). (Lack of such support is extremely rare, and such</span></span><br><span class="line"><span class="comment"># a case would tend to support setf rather than setaf.)</span></span><br><span class="line">color_prompt=yes</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">color_prompt=</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$color_prompt</span>&quot;</span> = yes ]; <span class="keyword">then</span></span><br><span class="line">    PS1=<span class="string">&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ &#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    PS1=<span class="string">&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\u@\h:\w\$ &#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">unset</span> color_prompt force_color_prompt</span><br><span class="line"></span><br><span class="line"><span class="comment"># If this is an xterm set the title to user@host:dir</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$TERM</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">xterm*|rxvt*)</span><br><span class="line">    PS1=<span class="string">&quot;\[\e]0;<span class="variable">$&#123;debian_chroot:+($debian_chroot)&#125;</span>\u@\h: \w\a\]<span class="variable">$PS1</span>&quot;</span></span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># enable color support of ls and also add handy aliases</span></span><br><span class="line"><span class="keyword">if</span> [ -x /usr/bin/dircolors ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">test</span> -r ~/.dircolors &amp;&amp; <span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(dircolors -b ~/.dircolors)</span>&quot;</span> || <span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(dircolors -b)</span>&quot;</span></span><br><span class="line">    <span class="built_in">alias</span> ls=<span class="string">&#x27;ls --color=auto&#x27;</span></span><br><span class="line">    <span class="comment">#alias dir=&#x27;dir --color=auto&#x27;</span></span><br><span class="line">    <span class="comment">#alias vdir=&#x27;vdir --color=auto&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">alias</span> grep=<span class="string">&#x27;grep --color=auto&#x27;</span></span><br><span class="line">    <span class="built_in">alias</span> fgrep=<span class="string">&#x27;fgrep --color=auto&#x27;</span></span><br><span class="line">    <span class="built_in">alias</span> egrep=<span class="string">&#x27;egrep --color=auto&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># some more ls aliases</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -alF&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">&#x27;ls -A&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> l=<span class="string">&#x27;ls -CF&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Alias definitions.</span></span><br><span class="line"><span class="comment"># You may want to put all your additions into a separate file like</span></span><br><span class="line"><span class="comment"># ~/.bash_aliases, instead of adding them here directly.</span></span><br><span class="line"><span class="comment"># See /usr/share/doc/bash-doc/examples in the bash-doc package.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -f ~/.bash_aliases ]; <span class="keyword">then</span></span><br><span class="line">    . ~/.bash_aliases</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># enable programmable completion features (you don&#x27;t need to enable</span></span><br><span class="line"><span class="comment"># this, if it&#x27;s already enabled in /etc/bash.bashrc and /etc/profile</span></span><br><span class="line"><span class="comment"># sources /etc/bash.bashrc).</span></span><br><span class="line"><span class="comment">#if [ -f /etc/bash_completion ] &amp;&amp; ! shopt -oq posix; then</span></span><br><span class="line"><span class="comment">#    . /etc/bash_completion</span></span><br><span class="line"><span class="comment">#fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add for proxy</span></span><br><span class="line"><span class="built_in">export</span> hostip=$(ip route | grep default | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>)</span><br><span class="line"><span class="built_in">export</span> hostport=10808</span><br><span class="line"><span class="built_in">alias</span> proxy=<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    export HTTPS_PROXY=&quot;socks5://$&#123;hostip&#125;:$&#123;hostport&#125;&quot;;</span></span><br><span class="line"><span class="string">    export HTTP_PROXY=&quot;socks5://$&#123;hostip&#125;:$&#123;hostport&#125;&quot;;</span></span><br><span class="line"><span class="string">    export ALL_PROXY=&quot;socks5://$&#123;hostip&#125;:$&#123;hostport&#125;&quot;;</span></span><br><span class="line"><span class="string">    git config --global http.proxy &quot;socks5://$&#123;hostip&#125;:$&#123;hostport&#125;&quot;;</span></span><br><span class="line"><span class="string">    git config --global https.proxy &quot;socks5://$&#123;hostip&#125;:$&#123;hostport&#125;&quot;;</span></span><br><span class="line"><span class="string">    echo -e &quot;Acquire::http::Proxy \&quot;http://$&#123;hostip&#125;:$&#123;hostport&#125;\&quot;; &quot; | sudo tee -a /etc/apt/apt.conf.d/proxy.conf;</span></span><br><span class="line"><span class="string">    echo -e &quot;Acquire::https::Proxy \&quot;http://$&#123;hostip&#125;:$&#123;hostport&#125;\&quot;; &quot; | sudo tee -a /etc/apt/apt.conf.d/proxy.conf;</span></span><br><span class="line"><span class="string">    echo &quot;nameserver 8.8.8.8&quot; &gt; /etc/resolv.conf;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> unproxy=<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    unset HTTPS_PROXY;</span></span><br><span class="line"><span class="string">    unset HTTP_PROXY;</span></span><br><span class="line"><span class="string">    unset ALL_PROXY;</span></span><br><span class="line"><span class="string">    git config --global --unset  http.proxy;</span></span><br><span class="line"><span class="string">    git config --global --unset  https.proxy;</span></span><br><span class="line"><span class="string">    sudo sed -i -e &#x27;</span>/Acquire::http::Proxy/d<span class="string">&#x27; /etc/apt/apt.conf.d/proxy.conf;</span></span><br><span class="line"><span class="string">    sudo sed -i -e &#x27;</span>/Acquire::https::Proxy/d<span class="string">&#x27; /etc/apt/apt.conf.d/proxy.conf;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#md folder_name  ==&gt; mkdit folder_name and cd folder_name</span></span><br><span class="line"><span class="function"><span class="title">md</span></span> () &#123;</span><br><span class="line">    mkdir -p <span class="variable">$1</span></span><br><span class="line">    <span class="built_in">cd</span> <span class="variable">$1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># bash颜色配置</span></span><br><span class="line"><span class="comment">#   颜色代码（字体加背景）：\[\e[F;Bm\]</span></span><br><span class="line"><span class="comment">#   \a ASCII 响铃字符（也可以键入 \007）</span></span><br><span class="line"><span class="comment">#   \e ASCII 转义字符（也可以键入 \033）</span></span><br><span class="line"><span class="comment">#   \d ：#代表日期，格式为weekday month date，例如：&quot;Mon Aug 1&quot;   </span></span><br><span class="line"><span class="comment">#   \u ：#当前用户的账号名称   </span></span><br><span class="line"><span class="comment">#   \H ：#完整的主机名称   </span></span><br><span class="line"><span class="comment">#   \h ：#仅取主机的第一个名字  </span></span><br><span class="line"><span class="comment">#   \t ：#显示时间为24小时格式，如：HH：MM：SS   </span></span><br><span class="line"><span class="comment">#   \T ：#显示时间为12小时格式   </span></span><br><span class="line"><span class="comment">#   \A ：#显示时间为24小时格式：HH：MM   </span></span><br><span class="line"><span class="comment">#   \n 换行符</span></span><br><span class="line"><span class="comment">#   \r 回车符</span></span><br><span class="line"><span class="comment">#   \v ：#BASH的版本信息   </span></span><br><span class="line"><span class="comment">#   \w ：#完整的工作目录名称   </span></span><br><span class="line"><span class="comment">#   \W ：#利用basename取得工作目录名称，所以只会列出最后一个目录   </span></span><br><span class="line"><span class="comment">#   \# ：#下达的第几个命令   </span></span><br><span class="line"><span class="comment">#   \$ ：#提示字符，如果是root时，提示符为：# ，普通用户则为：$ </span></span><br><span class="line"><span class="comment">#   \[\e[m\]：将前景、背景和加粗设置重置为它们的默认值，在在提示行结束时使用这个代码，以使您键入的文字成为非彩色的。</span></span><br><span class="line"><span class="built_in">export</span> PS1=<span class="string">&#x27;\[\e[36m\][\[\e[91m\]\u\[\e[m\]@\[\e[95m\]\h \[\e[34m\]\W\[\e[36m\]]\[\e[32m\]\$\[\e[m\]&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p><code>.vimrc</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> nocompatible    <span class="string">&quot; 去掉对vi的兼容，让vim运行在完全模式下&quot;</span></span><br><span class="line">filetype on                     <span class="string">&quot; 开启文件类型检测&quot;</span></span><br><span class="line">filetype plugin on              <span class="string">&quot; 开启插件的支持&quot;</span></span><br><span class="line">filetype indent on              <span class="string">&quot; 开启文件类型相应的缩进规则&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> rtp+=~/.vim/bundle/Vundle.vim</span><br><span class="line">call vundle<span class="comment">#begin()</span></span><br><span class="line"></span><br><span class="line">Plugin <span class="string">&#x27;ycm-core/YouCompleteMe&#x27;</span></span><br><span class="line"><span class="string">&quot; YouCompleteMe:语句补全插件 &quot;</span></span><br><span class="line"><span class="built_in">set</span> runtimepath+=~/.vim/bundle/YouCompleteMe</span><br><span class="line">autocmd InsertLeave * <span class="keyword">if</span> pumvisible() == 0|pclose|endif <span class="string">&quot;离开插入模式后自动关闭预览窗口&quot;</span></span><br><span class="line"><span class="built_in">let</span> g:ycm_collect_identifiers_from_tags_files = 1           <span class="string">&quot; 开启 YCM基于标签引擎&quot;</span></span><br><span class="line"><span class="built_in">let</span> g:ycm_collect_identifiers_from_comments_and_strings = 1 <span class="string">&quot; 注释与字符串中的内容也用于补全&quot;</span></span><br><span class="line"><span class="built_in">let</span> g:syntastic_ignore_files=[<span class="string">&quot;.*\.py$&quot;</span>]</span><br><span class="line"><span class="built_in">let</span> g:ycm_seed_identifiers_with_syntax = 1                  <span class="string">&quot; 语法关键字补全&quot;</span></span><br><span class="line"><span class="built_in">let</span> g:ycm_complete_in_comments = 1</span><br><span class="line"><span class="built_in">let</span> g:ycm_confirm_extra_conf = 0                            <span class="string">&quot; 关闭加载.ycm_extra_conf.py提示&quot;</span></span><br><span class="line"><span class="built_in">let</span> g:ycm_key_list_select_completion = [<span class="string">&#x27;&lt;c-n&gt;&#x27;</span>, <span class="string">&#x27;&lt;Down&gt;&#x27;</span>]  <span class="string">&quot; 映射按键,没有这个会拦截掉tab, 导致其他插件的tab不能用.&quot;</span></span><br><span class="line"><span class="built_in">let</span> g:ycm_key_list_previous_completion = [<span class="string">&#x27;&lt;c-p&gt;&#x27;</span>, <span class="string">&#x27;&lt;Up&gt;&#x27;</span>]</span><br><span class="line"><span class="built_in">let</span> g:ycm_complete_in_comments = 1                          <span class="string">&quot; 在注释输入中也能补全&quot;</span></span><br><span class="line"><span class="built_in">let</span> g:ycm_complete_in_strings = 1                           <span class="string">&quot; 在字符串输入中也能补全&quot;</span></span><br><span class="line"><span class="built_in">let</span> g:ycm_collect_identifiers_from_comments_and_strings = 1 <span class="string">&quot; 注释和字符串中的文字也会被收入补全&quot;</span></span><br><span class="line"><span class="built_in">let</span> g:ycm_global_ycm_extra_conf=<span class="string">&#x27;~/.ycm_extra_conf.py&#x27;</span>      <span class="string">&quot;&#x27;~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&#x27;&quot;</span></span><br><span class="line"><span class="built_in">let</span> g:ycm_show_diagnostics_ui = 0                           <span class="string">&quot; 禁用语法检查&quot;</span></span><br><span class="line">inoremap &lt;expr&gt; &lt;CR&gt; pumvisible() ? <span class="string">&quot;\&lt;C-y&gt;&quot;</span> : <span class="string">&quot;\&lt;CR&gt;&quot;</span>             <span class="string">&quot; 回车即选中当前项&quot;</span></span><br><span class="line">nnoremap &lt;c-j&gt; :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;     <span class="string">&quot; 跳转到定义处&quot;</span></span><br><span class="line"><span class="built_in">let</span> g:ycm_min_num_of_chars_for_completion=2                 <span class="string">&quot; 从第2个键入字符就开始罗列匹配项&quot;</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Plugin &#x27;VundleVim/Vundle.vim&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Plugin &#x27;vim-airline/vim-airline&#x27;</span></span><br><span class="line"><span class="string">Plugin &#x27;vim-airline/vim-airline-themes&#x27;</span></span><br><span class="line"><span class="string">&quot;</span>vim-airline配置:优化vim界面<span class="string">&quot;</span></span><br><span class="line"><span class="string">let g:airline#extensions#tabline#enabled = 1</span></span><br><span class="line"><span class="string">&quot;</span> airline设置<span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span> 显示颜色<span class="string">&quot;</span></span><br><span class="line"><span class="string">set t_Co=256</span></span><br><span class="line"><span class="string">set laststatus=2</span></span><br><span class="line"><span class="string">let g:airline_theme=&#x27;bubblegum&#x27;</span></span><br><span class="line"><span class="string">&quot;</span> 使用powerline打过补丁的字体<span class="string">&quot;</span></span><br><span class="line"><span class="string">let g:airline_powerline_fonts = 1</span></span><br><span class="line"><span class="string">&quot;</span> 开启tabline<span class="string">&quot;</span></span><br><span class="line"><span class="string">let g:airline#extensions#tabline#enabled = 1</span></span><br><span class="line"><span class="string">&quot;</span> tabline中当前buffer两端的分隔字符<span class="string">&quot;</span></span><br><span class="line"><span class="string">let g:airline#extensions#tabline#left_sep = &#x27; &#x27;</span></span><br><span class="line"><span class="string">&quot;</span> tabline中未激活buffer两端的分隔字符<span class="string">&quot;</span></span><br><span class="line"><span class="string">let g:airline#extensions#tabline#left_alt_sep = &#x27; &#x27;</span></span><br><span class="line"><span class="string">&quot;</span> tabline中buffer显示编号<span class="string">&quot;</span></span><br><span class="line"><span class="string">let g:airline#extensions#tabline#buffer_nr_show = 1</span></span><br><span class="line"><span class="string">&quot;</span> 映射切换buffer的键位<span class="string">&quot;</span></span><br><span class="line"><span class="string">nnoremap [b :bp&lt;CR&gt;</span></span><br><span class="line"><span class="string">nnoremap ]b :bn&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span> 映射&lt;leader&gt;num到num buffer<span class="string">&quot;</span></span><br><span class="line"><span class="string">map &lt;leader&gt;1 :b 1&lt;CR&gt;</span></span><br><span class="line"><span class="string">map &lt;leader&gt;2 :b 2&lt;CR&gt;</span></span><br><span class="line"><span class="string">map &lt;leader&gt;3 :b 3&lt;CR&gt;</span></span><br><span class="line"><span class="string">map &lt;leader&gt;4 :b 4&lt;CR&gt;</span></span><br><span class="line"><span class="string">map &lt;leader&gt;5 :b 5&lt;CR&gt;</span></span><br><span class="line"><span class="string">map &lt;leader&gt;6 :b 6&lt;CR&gt;</span></span><br><span class="line"><span class="string">map &lt;leader&gt;7 :b 7&lt;CR&gt;</span></span><br><span class="line"><span class="string">map &lt;leader&gt;8 :b 8&lt;CR&gt;</span></span><br><span class="line"><span class="string">map &lt;leader&gt;9 :b 9&lt;CR&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> vim-scripts 中的插件 <span class="string">&quot;</span></span><br><span class="line"><span class="string">Plugin &#x27;taglist.vim&#x27;</span></span><br><span class="line"><span class="string">Plugin &#x27;The-NERD-tree&#x27;</span></span><br><span class="line"><span class="string">Plugin &#x27;indentLine.vim&#x27;  &quot;</span>缩进线插件<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Plugin <span class="string">&#x27;git://git.wincent.com/command-t.git&#x27;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">call vundle#end()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span>键盘命令<span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">let mapleader = &quot;</span>\&lt;space&gt;<span class="string">&quot;</span></span><br><span class="line"><span class="string">nmap &lt;leader&gt;w :w!&lt;cr&gt; &quot;</span>&lt;space&gt;w强制保存文件<span class="string">&quot;</span></span><br><span class="line"><span class="string">nmap &lt;leader&gt;q :q!&lt;cr&gt; &quot;</span>&lt;space&gt;q强制退出文件<span class="string">&quot;</span></span><br><span class="line"><span class="string">nmap &lt;leader&gt;s :wq!&lt;cr&gt; &quot;</span>&lt;space&gt;s强制保存退出文件<span class="string">&quot;</span></span><br><span class="line"><span class="string">nmap &lt;leader&gt;f :find&lt;cr&gt; &quot;</span>&lt;space&gt;find查找<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>Alt+Up/Down向上下移动代码<span class="string">&quot;</span></span><br><span class="line"><span class="string">nnoremap &lt;A-Down&gt; :m+&lt;CR&gt;==</span></span><br><span class="line"><span class="string">nnoremap &lt;A-Up&gt; :m-2&lt;CR&gt;==</span></span><br><span class="line"><span class="string">inoremap &lt;A-Down&gt; &lt;Esc&gt;:m+&lt;CR&gt;==gi</span></span><br><span class="line"><span class="string">inoremap &lt;A-Up&gt; &lt;Esc&gt;:m-2&lt;CR&gt;==gi</span></span><br><span class="line"><span class="string">vnoremap &lt;A-Down&gt; :m&#x27;&gt;+&lt;CR&gt;gv=gv</span></span><br><span class="line"><span class="string">vnoremap &lt;A-Up&gt; :m-2&lt;CR&gt;gv=gv</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">nnoremap &lt;S-Down&gt; :t.&lt;CR&gt;$</span></span><br><span class="line"><span class="string">nnoremap &lt;S-Up&gt; yykp$</span></span><br><span class="line"><span class="string">inoremap &lt;A-S-Down&gt; &lt;Esc&gt;:t.&lt;CR&gt;$</span></span><br><span class="line"><span class="string">inoremap &lt;A-S-Up&gt; &lt;Esc&gt;yykp$</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 映射全选+复制 ctrl+a<span class="string">&quot;</span></span><br><span class="line"><span class="string">map &lt;C-A&gt; ggVGY</span></span><br><span class="line"><span class="string">map! &lt;C-A&gt; &lt;Esc&gt;ggVGY</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>新建标签<span class="string">&quot;</span></span><br><span class="line"><span class="string">map &lt;C-n&gt; :tabnew&lt;CR&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 选中状态下 Ctrl+c 复制<span class="string">&quot; </span></span><br><span class="line"><span class="string">vnoremap &lt;C-c&gt; &quot;</span>+y   <span class="string">&quot;支持在Visual模式下，通过C-y复制到系统剪切板</span></span><br><span class="line"><span class="string">nnoremap &lt;C-p&gt; &quot;</span>*p   <span class="string">&quot;支持在normal模式下，通过C-p粘贴系统剪切板</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>NERDTree 配置:F2快捷键显示当前目录树<span class="string">&quot;</span></span><br><span class="line"><span class="string">map &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;</span></span><br><span class="line"><span class="string">let NERDTreeWinSize=25 </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>ctags 配置:F3快捷键显示程序中的各种tags，包括变量和函数等。<span class="string">&quot;</span></span><br><span class="line"><span class="string">map &lt;F3&gt; :TlistToggle&lt;CR&gt;</span></span><br><span class="line"><span class="string">let Tlist_Use_Right_Window=1</span></span><br><span class="line"><span class="string">let Tlist_Show_One_File=1</span></span><br><span class="line"><span class="string">let Tlist_Exit_OnlyWindow=1</span></span><br><span class="line"><span class="string">let Tlist_WinWidt=25</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>c，c++ 按f5编译运行<span class="string">&quot;</span></span><br><span class="line"><span class="string">map &lt;F5&gt; :call CompileRunGcc()&lt;CR&gt;</span></span><br><span class="line"><span class="string">func! CompileRunGcc()</span></span><br><span class="line"><span class="string">    exec &quot;</span>w<span class="string">&quot;</span></span><br><span class="line"><span class="string">    if &amp;filetype == &#x27;c&#x27;</span></span><br><span class="line"><span class="string">        exec &quot;</span>!g++ % -o %&lt;<span class="string">&quot;</span></span><br><span class="line"><span class="string">        exec &quot;</span>! ./%&lt;<span class="string">&quot;</span></span><br><span class="line"><span class="string">    elseif &amp;filetype == &#x27;cpp&#x27;</span></span><br><span class="line"><span class="string">        exec &quot;</span>!g++ % -o %&lt;<span class="string">&quot;</span></span><br><span class="line"><span class="string">        exec &quot;</span>! ./%&lt;<span class="string">&quot;</span></span><br><span class="line"><span class="string">    elseif &amp;filetype == &#x27;java&#x27; </span></span><br><span class="line"><span class="string">        exec &quot;</span>!javac %<span class="string">&quot; </span></span><br><span class="line"><span class="string">        exec &quot;</span>!java %&lt;<span class="string">&quot;</span></span><br><span class="line"><span class="string">    elseif &amp;filetype == &#x27;sh&#x27;</span></span><br><span class="line"><span class="string">        :!./%</span></span><br><span class="line"><span class="string">    endif</span></span><br><span class="line"><span class="string">endfunc</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>F8 c,c++的调试<span class="string">&quot;</span></span><br><span class="line"><span class="string">map &lt;F8&gt; :call Rungdb()&lt;CR&gt;</span></span><br><span class="line"><span class="string">func! Rungdb()</span></span><br><span class="line"><span class="string">    exec &quot;</span>w<span class="string">&quot;</span></span><br><span class="line"><span class="string">    exec &quot;</span>!g++ % -g -o %&lt;<span class="string">&quot;</span></span><br><span class="line"><span class="string">    exec &quot;</span>!gdb ./%&lt;<span class="string">&quot;</span></span><br><span class="line"><span class="string">endfunc </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>F12智能缩进<span class="string">&quot;</span></span><br><span class="line"><span class="string">map &lt;F12&gt; gg=G</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>mf生成main函数<span class="string">&quot;</span></span><br><span class="line"><span class="string">map mf i#include &quot;</span>stdio.h<span class="string">&quot;&lt;Enter&gt;&lt;Enter&gt;int main(int argc, char *argv[])&lt;Esc&gt;o&#123;&lt;Esc&gt;oreturn 0;&lt;Esc&gt;o&#125;&lt;Esc&gt;2ko</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;实用设置&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> encoding</span><br><span class="line"><span class="built_in">set</span> encoding=utf-8              <span class="string">&quot; 打开文件时编码格式&quot;</span></span><br><span class="line"><span class="built_in">set</span> fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1         <span class="string">&quot;vim会根据该设置识别文件编码&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> nu      <span class="string">&quot; 显示行号&quot;</span></span><br><span class="line"><span class="built_in">set</span> ruler                   <span class="string">&quot; 显示当前光标行号和列&quot;</span></span><br><span class="line"><span class="built_in">set</span> <span class="built_in">history</span>=2000            <span class="string">&quot; 记录 Vim 历史操作的条数&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> autoread                <span class="string">&quot; 文件在vim外修改过自动重新载入&quot;</span></span><br><span class="line">au CursorHold,CursorHoldI * checktime</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> t_Co=256    <span class="string">&quot; 开启256色&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> background=light</span><br><span class="line">colorscheme desert    </span><br><span class="line"><span class="string">&quot; 颜色主题&quot;</span></span><br><span class="line"></span><br><span class="line">syntax on   <span class="string">&quot; 语法高亮&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> cursorline  <span class="string">&quot; 突出显示当前行&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> tabstop=4   <span class="string">&quot; Tab键的宽度&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> smarttab    <span class="string">&quot; 在行和段开始处使用制表符&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;  统一缩进为4&quot;</span></span><br><span class="line"><span class="built_in">set</span> softtabstop=4</span><br><span class="line"><span class="built_in">set</span> shiftwidth=4</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> autoindent  <span class="string">&quot; 自动对齐&quot;</span></span><br><span class="line"><span class="built_in">set</span> cindent     <span class="string">&quot; 自动缩进&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> showmatch   <span class="string">&quot; 高亮显示对应的括号&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; search&quot;</span></span><br><span class="line"><span class="built_in">set</span> smartcase   <span class="string">&quot;搜索时 如果输入大写，则严格按照大小写搜索，如果小写，并设置了ignorecase，则忽略大小写&quot;</span></span><br><span class="line"><span class="built_in">set</span> ignorecase  <span class="string">&quot;搜索忽略大小写&quot;</span></span><br><span class="line"><span class="built_in">set</span> incsearch   <span class="string">&quot;搜索时及时匹配搜索内容，需要回车确认&quot;</span></span><br><span class="line"><span class="built_in">set</span> hlsearch    <span class="string">&quot;高亮搜索项&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> confirm     <span class="string">&quot; 在处理未保存或只读文件的时候，弹出确认&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> noeb        <span class="string">&quot; 去掉输入错误的提示声音&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; 开始折叠 &quot;</span></span><br><span class="line"><span class="built_in">set</span> foldcolumn=0</span><br><span class="line"><span class="built_in">set</span> foldmethod=indent </span><br><span class="line"><span class="built_in">set</span> foldlevel=3 </span><br><span class="line"><span class="built_in">set</span> foldenable              </span><br><span class="line"></span><br><span class="line"><span class="string">&quot; 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位） &quot;</span></span><br><span class="line"><span class="built_in">set</span> mouse=a</span><br><span class="line"><span class="built_in">set</span> selection=exclusive</span><br><span class="line"><span class="built_in">set</span> selectmode=mouse,key</span><br><span class="line"></span><br><span class="line">filetype plugin indent on</span><br><span class="line"><span class="string">&quot; 分为三部分命令：file on, file plugin on, file indent on.分别表示自动识别文件类型，用文件类型脚本，使用缩进定义文件。&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> completeopt=preview,menu <span class="string">&quot;代码补全 &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; R键编译 Compile function&quot;</span></span><br><span class="line">noremap r :call CompileRunGcc()&lt;CR&gt;</span><br><span class="line"><span class="keyword">function</span>! CompileRunGcc()</span><br><span class="line">  execute <span class="string">&quot;w&quot;</span></span><br><span class="line">  <span class="keyword">if</span> &amp;filetype == <span class="string">&#x27;c&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> !isdirectory(<span class="string">&#x27;build&#x27;</span>)</span><br><span class="line">      execute <span class="string">&quot;!mkdir build&quot;</span></span><br><span class="line">    endif</span><br><span class="line">    execute <span class="string">&quot;!gcc % -o build/%&lt;&quot;</span></span><br><span class="line">    execute <span class="string">&quot;!time ./build/%&lt;&quot;</span></span><br><span class="line">  endif</span><br><span class="line">endfunction</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美化 </tag>
            
            <tag> bash </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实时操作系统FreeRTOS</title>
      <link href="/archives/e76a6a61.html"/>
      <url>/archives/e76a6a61.html</url>
      
        <content type="html"><![CDATA[<h2 id="FreeRTOS内核实现"><a href="#FreeRTOS内核实现" class="headerlink" title="FreeRTOS内核实现"></a>FreeRTOS内核实现</h2><h3 id="FreeRTOS中链表的实现"><a href="#FreeRTOS中链表的实现" class="headerlink" title="FreeRTOS中链表的实现"></a>FreeRTOS中链表的实现</h3>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> RTOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> RTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL更换镜像源</title>
      <link href="/archives/48884a62.html"/>
      <url>/archives/48884a62.html</url>
      
        <content type="html"><![CDATA[<h1 id="WSL更换清华镜像源"><a href="#WSL更换清华镜像源" class="headerlink" title="WSL更换清华镜像源"></a>WSL更换清华镜像源</h1><p>Ubuntu、Python、Nodejs、MySQL、Git、Chromium、Docker、Homebrew 等一系列的常用开源系统、软件都是国外开发的，下载地址位于国外，从国内访问、下载、更新速度慢所以我们要使用镜像源，其中清华源镜像镜像源数量最多，所以这里用清华源镜像做替换，下面是替换方法：</p><ol><li>备份原文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp  /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><ol start="2"><li>将<code>/etc/apt/sources.list</code>文件内容替换为清华镜像源</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预发布软件源，不建议启用</span></span><br><span class="line"><span class="comment"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure><ol start="3"><li>更新软件源</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用WSL+VScode搭建C/C++开发环境</title>
      <link href="/archives/d3d975f8.html"/>
      <url>/archives/d3d975f8.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用WSL-VScode搭建C-C-开发环境"><a href="#使用WSL-VScode搭建C-C-开发环境" class="headerlink" title="使用WSL+VScode搭建C/C++开发环境"></a>使用WSL+VScode搭建C/C++开发环境</h1><div class="note info flat"><p>参考文档：<a href="https://docs.microsoft.com/zh-cn/windows/wsl/setup/environment">https://docs.microsoft.com/zh-cn/windows/wsl/setup/environment</a></p></div><h2 id="安装WSL"><a href="#安装WSL" class="headerlink" title="安装WSL"></a>安装WSL</h2><h3 id="新版本"><a href="#新版本" class="headerlink" title="新版本"></a>新版本</h3><p>对于最新版本的 Windows （内部版本 20262+）可以使用简化的 –install 命令安装WSL。若要检查 Windows 版本及内部版本号，选择 Windows 徽标键 + R，然后键入“winver”，选择“确定”。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl -<span class="literal">-install</span></span><br></pre></td></tr></table></figure><p>–install 命令执行以下操作：</p><ul><li>启用可选的 WSL 和虚拟机平台组件</li><li>下载并安装最新 Linux 内核</li><li>将 WSL 2 设置为默认值</li><li>下载并安装 Ubuntu Linux 发行版（可能需要重新启动）</li></ul><p>在此安装过程中，你将需要重启计算机。</p><h3 id="其他版本"><a href="#其他版本" class="headerlink" title="其他版本"></a>其他版本</h3><p>若要更新到 WSL 2，需要运行 Windows 10。<br>对于 x64 系统：版本 1903 或更高版本，采用内部版本 18362 或更高版本。<br>对于 ARM64 系统：版本 2004 或更高版本，采用内部版本 19041 或更高版本。<br>低于 18362 的版本不支持 WSL 2。 使用 Windows Update 助手更新 Windows 版本。</p><p>如不是最新版本可以以管理员身份运行powershell，按以下步骤安装：</p><h4 id="1-启用-Windows-Subsystem-Linux子系统"><a href="#1-启用-Windows-Subsystem-Linux子系统" class="headerlink" title="1.启用 Windows-Subsystem-Linux子系统"></a>1.启用 Windows-Subsystem-Linux子系统</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dism.exe /online /<span class="built_in">enable-feature</span> /featurename:Microsoft<span class="literal">-Windows</span><span class="literal">-Subsystem</span><span class="literal">-Linux</span> /all /norestart   </span><br></pre></td></tr></table></figure><h4 id="2-开启虚拟机功能"><a href="#2-开启虚拟机功能" class="headerlink" title="2.开启虚拟机功能"></a>2.开启虚拟机功能</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dism.exe /online /<span class="built_in">enable-feature</span> /featurename:VirtualMachinePlatform /all /norestart </span><br></pre></td></tr></table></figure><h4 id="3-重启后下载安装Linux内核更新包"><a href="#3-重启后下载安装Linux内核更新包" class="headerlink" title="3.重启后下载安装Linux内核更新包"></a>3.重启后下载安装Linux内核更新包</h4><p>下载地址： <a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">适用于 x64 计算机的 WSL2 Linux 内核更新包</a></p><h4 id="4-将wsl2设为默认版本"><a href="#4-将wsl2设为默认版本" class="headerlink" title="4.将wsl2设为默认版本"></a>4.将wsl2设为默认版本</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl -<span class="literal">-set</span><span class="literal">-default</span><span class="literal">-version</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="5-自己选择安装Linux发行版"><a href="#5-自己选择安装Linux发行版" class="headerlink" title="5.自己选择安装Linux发行版"></a>5.自己选择安装Linux发行版</h4><p>打开 <a href="https://www.microsoft.com/store/apps/9n6svws3rx71">Microsoft Store</a>，并选择你偏好的 Linux 分发版。</p><h2 id="配置开发环境"><a href="#配置开发环境" class="headerlink" title="配置开发环境"></a>配置开发环境</h2><p>安装完成后打开WSL的shell</p><h3 id="1-更新ubuntu软件"><a href="#1-更新ubuntu软件" class="headerlink" title="1.更新ubuntu软件"></a>1.更新ubuntu软件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><h3 id="2-安装编译器调试器"><a href="#2-安装编译器调试器" class="headerlink" title="2.安装编译器调试器"></a>2.安装编译器调试器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt -y install gcc g++ gdb</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/10/KR7aLrdD4tZkjUf.png"></p><h3 id="3-在VScode中安装wsl插件"><a href="#3-在VScode中安装wsl插件" class="headerlink" title="3.在VScode中安装wsl插件"></a>3.在VScode中安装wsl插件</h3><p>在子系统shell中输入<code>code .</code>就可以打开VScode，第一次从子系统打开VS Code会自动安装一些插件，等待安装完成后就可以在WSL中进行开发了。</p>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WSL </tag>
            
            <tag> VScode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cxxx（深入理解计算机系统第七章02）</title>
      <link href="/archives/6b113d09.html"/>
      <url>/archives/6b113d09.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C </category>
          
          <category> CSAPP </category>
          
          <category> 第七章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> C </tag>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C可执行文件生成过程概述（深入理解计算机系统第七章01）</title>
      <link href="/archives/7f68ed10.html"/>
      <url>/archives/7f68ed10.html</url>
      
        <content type="html"><![CDATA[<h2 id="C可执行文件生成过程概述（深入理解计算机系统第七章01）"><a href="#C可执行文件生成过程概述（深入理解计算机系统第七章01）" class="headerlink" title="C可执行文件生成过程概述（深入理解计算机系统第七章01）"></a>C可执行文件生成过程概述（深入理解计算机系统第七章01）</h2><blockquote><p>视频教程：<br><a href="https://www.bilibili.com/video/BV1kE411X7S5">南京大学 计算机系统基础 袁春风老师</a><br><a href="https://www.bilibili.com/video/BV1X34y1o7zq">CSAPP-深入理解计算机系统 九曲阑干</a></p></blockquote><p>我一直有这样一个疑问，每当我在编辑器中写下一行行代码，完成一个又一个程序时，写好的<code>.c</code>文件里其实都是写满了使用特定编码(ASCII、UTF-8、GBK等等)的字符，电脑或运行程序的机器是如何转化为一个可执行文件的呢？</p><p><img src="http://cdn.nafx.top/post_cover/20220824170053.png" alt="gcc生成可执行文件"></p><p>以一个HelloWorld程序为例，在Linux系统中可以通过图中的gcc命令生成可执行文件，这实际上经历了下面几个过程，这里把整个过程分解采用手动链接的方式生成可执行程序。</p><p><img src="http://cdn.nafx.top/post_cover/6539f58189a6cfef1e659c5c682417e2.jpg" alt="gcc命令生成可执行文件过程"></p><blockquote><p>gcc命令实际上是具体程序(如ccp、cc1、as等)的包装命令,<br>用户通过gcc命令来使用具体的预处理程序cpp、编译程序cc1和汇编程序as等。</p></blockquote><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>首先是将<code>.c</code>文件通过预处理程序（c preprocessor）<code>cpp</code>生成预处理程序<code>hello.i</code>（通常以<code>.i</code>扩展名结尾），经过预处理后的文件还是一个可读的高级语言源程序文本文件，只不过不包含任何宏定义，为后续编译做准备。</p><p><img src="http://cdn.nafx.top/post_cover/20220827145644.png" alt="预处理命令"></p><p>这里直接使用<code>cpp</code>预处理器，也可以使用<code>gcc -E -o hello.i  hello.c</code>命令进行预处理，<code>-E</code>参数表示只激活预处理。我们可以看下生成的<code>hello.i</code>文件有733行。</p><p><img src="http://cdn.nafx.top/post_cover/20220827151615.png" alt="预处理文件行数"></p><p>实际上预处理过程只是处理了源文件中以<code>#</code>开头的预编译指令，包括：</p><ul><li>删除<code>#define</code>并展开所定义的宏。</li><li>处理所有条件预编译指令，如<code>#if</code>、<code>#ifdef</code>、<code>#endif</code>等。</li><li>插入头文件到<code>#include</code>处，可以递归方式进行处理。</li><li>删除所有的注释<code>//</code>和<code>/* */</code>。</li><li>添加行号和文件名标识，以便编译时编译器产生调试用的行号信息。</li><li>保留所有#pragma编译指令（编译器需要用）。</li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>下面进行编译，将<code>.i</code>文件通过编译程序（编译器）<code>cc1</code>编译生成汇编语言程序<code>hello.s</code>文件（通常以<code>.s</code>扩展名结尾），经过编译后的文件依然是可读的文本文件，只不过内容已经编译成了对应的汇编语言源程序。</p><p><img src="http://cdn.nafx.top/post_cover/20220827153119.png" alt="编译命令"></p><p>这里使用c编译器（c compiler）<code>cc</code>，同样也可以使用<code>gcc -S -o hello.s hello.i</code>命令编译，<code>-S</code>参数表示只激活预处理和编译，因为编译后生成的依旧是文本文件我们可以直接打开查看。</p><p><img src="http://cdn.nafx.top/post_cover/20220827153559.png" alt="编译后.s文件"></p><p>可以看到经过编译的词法分析、语法分析、语义分析并优化后我们的C语言程序代码已经变成了由汇编指令构成的汇编代码文件，由于还是文本文件计算机依旧不能理解和执行它。</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>下一步就是将<code>.s</code>文件通过汇编程序（汇编器）<code>as</code>进行汇编，也就是将汇编语言源程序转换为机器语言序列，生成可重定位目标文件<code>hello.o</code>，这个文件里就是由二进制的机器指令代码，计算机可以直接识别。汇编指令和机器指令一一对应，前者是后者的符号表示，它们都属于机器级指令，所构成的程序成为机器级代码。</p><p><img src="http://cdn.nafx.top/post_cover/20220827154421.png" alt="汇编命令"></p><p>这里使用汇编器（assembler）<code>as</code>，同样可以使用<code>gcc -c -o hello.o hello.s</code> 命令汇编，<code>-c</code>参数表示只激活预处理,编译,和汇编。汇编结果是可重定位目标文件，其中包含的是不可读的二进制代码，无法被当做普通文本文件打开，只能用相应的工具软件来查看其内容。</p><p>比如可以用<code>objdump -S</code>命令反汇编查看我们的目标文件包含的指令和数据。可以看到代码和数据的地址都是从0开始，因为可重定位目标文件还不清楚每个符号实际的地址，下面链接的重定位过程会计算每个定义的符号在虚拟地址空间的绝对地址并将可执行文件中的符号引用处的地址修改为重定位后的地址信息。</p><p><img src="http://cdn.nafx.top/post_cover/20220827190154.png" alt="反汇编查看"></p><p>汇编生成的可重定位目标文件或是链接后生成的可执行目标文件都是ELF (Executable and Linkable Format)格式的文件，可以使用<code>readelf -a</code>命令查看包括ELF头(ELF header)、程序头表(Program header table)和节头表(Section header table)的目标文件详细信息。</p><p><img src="http://cdn.nafx.top/post_cover/20220827193010.png" alt="readelf查看"></p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>一个程序可能会包含许多其他模块，也会使用到一些库，如这里使用到的<code>printf</code>函数就是定义在标准库<code>libc</code>中定义的。通过链接器<code>ld</code>将多个可重定位目标文件通过符号解析（symbol resolution)和重定位(relocation)合并以生成可执行目标程序，可执行目标文件程序也是由机器可以直接识别执行的二进制代码构成的。</p><p>当我们手动调用链接器<code>ld</code>来构造可执行程序时，除了需要用到汇编阶段得到的<code>hello.o</code>之外还需要加上crt库和crt入口等参数。</p><p><img src="http://cdn.nafx.top/post_cover/20220827164200.png" alt="ld参数"></p><p>所以这里我们直接使用<code>gcc</code>命令来自动链接我们的可重定位目标文件<code>hello.o</code>。<br><code>-static</code>参数表示静态链接，如不指定则默认动态链接。<br><code>-o</code>参数指定目标名称，如不指定则默认为<code>a.out</code>。</p><p><img src="http://cdn.nafx.top/post_cover/20220827164358.png" alt="链接命令"><br>连接操作得到的就是可执行目标文件。<br>链接过程的本质就是合并相同的“节”（session）到虚拟地址空间。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>最后确认得到的可执行目标文件prog是否能正确运行。</p><p><img src="http://cdn.nafx.top/post_cover/20220827184644.png" alt="运行"></p><p>通过shell调用操作系统中的加载器（loader）函数，将可执行目标文件中的代码和数据复制到内存中然后将CPU的控制权转移到prog程序的开头。这里只测试生成的可执行程序是否正常运行，关于可执行目标文件的加载和运行后面再详细说明。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
          <category> CSAPP </category>
          
          <category> 第七章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> C </tag>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——栈与队列</title>
      <link href="/archives/73783806.html"/>
      <url>/archives/73783806.html</url>
      
        <content type="html"><![CDATA[<h2 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈 stack"></a>栈 stack</h2><p>栈是<strong>限定仅在表尾进行插入和删除操作的线性表</strong>。把允许插入和删除的一端称为<strong>栈顶(top)</strong>,另一端称为<strong>栈底(bottom)</strong>,不含任何数据元素的栈称为空栈。栈又称为<strong>后进先出(Last In First Out)<strong>的线性表，简称</strong>LIFO</strong>结构。</p><h3 id="栈的顺序存储结构实现"><a href="#栈的顺序存储结构实现" class="headerlink" title="栈的顺序存储结构实现"></a>栈的顺序存储结构实现</h3><p>因为栈本身属于线性表的特例，那么栈的顺序存储其实也是线性表顺序存储的简化，称为顺序栈。</p><p>sqstack.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SQSTACK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQSTACK_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*                                宏定义</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 5 <span class="comment">/* 存储空间初始分配量 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Elemtype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*                                结构体定义</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elemtype data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125;Sqstack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*                                函数声明</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(Sqstack *S)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">ClearStack</span><span class="params">(Sqstack *S)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(Sqstack S)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackLength</span><span class="params">(Sqstack S)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(Sqstack S,Elemtype *e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(Sqstack *S,Elemtype e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(Sqstack *S,Elemtype *e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">visit</span><span class="params">(Elemtype c)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">StackTraverse</span><span class="params">(Sqstack S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* SQSTACK_H */</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>sqstack.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sqstack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  构造一个空栈S */</span></span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(Sqstack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* S.data=(SElemType *)malloc(MAXSIZE*sizeof(SElemType)); */</span></span><br><span class="line">S-&gt;top = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把S置为空栈 */</span></span><br><span class="line"><span class="function">Status <span class="title">ClearStack</span><span class="params">(Sqstack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// while (S-&gt;top &gt;= 0)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// S-&gt;data[S-&gt;top] = 0;</span></span><br><span class="line"><span class="comment">// S-&gt;top--;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// //释放元素内存</span></span><br><span class="line">S-&gt;top = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若栈S为空栈，则返回TRUE，否则返回FALSE */</span></span><br><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(Sqstack S)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (S.top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回S的元素个数，即栈的长度 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackLength</span><span class="params">(Sqstack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> S.top+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERROR */</span></span><br><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(Sqstack S,Elemtype *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (S.top==<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> ERR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                *e=S.data[S.top];</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入元素e为新的栈顶元素 */</span></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(Sqstack *S,Elemtype e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 栈满 */</span></span><br><span class="line"><span class="keyword">if</span> ( S-&gt;top == MAXSIZE<span class="number">-1</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;栈满!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ERR;</span><br><span class="line">&#125;</span><br><span class="line">S-&gt;top++;</span><br><span class="line">S-&gt;data[S-&gt;top]=e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若栈不为空，删除栈S顶元素，用e返回其值*/</span></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(Sqstack *S,Elemtype *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;栈空!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ERR;</span><br><span class="line">&#125;</span><br><span class="line">*e=S-&gt;data[S-&gt;top];</span><br><span class="line">S-&gt;top--;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">visit</span><span class="params">(Elemtype c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,c);</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从栈底到栈顶依次对栈中每个元素显示 */</span></span><br><span class="line"><span class="function">Status <span class="title">StackTraverse</span><span class="params">(Sqstack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=S.top)</span><br><span class="line">        &#123;</span><br><span class="line">                visit(S.data[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> opt;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">exit</span> = OK;</span><br><span class="line">Sqstack test;</span><br><span class="line">InitStack(&amp;test);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">exit</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n======================================================================================================================== \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt;&gt;请输入操作标号: 1.初始化栈; 2.将元素e入栈; 3.将栈顶元素弹出; 4.将栈清空; 5.打印栈内元素; 0.退出;\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;opt);</span><br><span class="line"><span class="keyword">switch</span> (opt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line">InitStack(&amp;test);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;初始化完成，目前栈为空!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">&#123;</span><br><span class="line">Elemtype val;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入入栈元素的值并按回车:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val);</span><br><span class="line"><span class="keyword">if</span>(Push(&amp;test,val))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;入栈成功!目前栈内有%d个元素。\n&quot;</span>,StackLength(test));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">&#123;</span><br><span class="line">Elemtype val;</span><br><span class="line"><span class="keyword">if</span> (Pop(&amp;test,&amp;val))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;栈顶元素%d弹出,目前栈内有%d个元素。\n&quot;</span>,val,StackLength(test));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ClearStack(&amp;test))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;清空完成，目前栈内有%d个元素。\n&quot;</span>,StackLength(test));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;目前栈内有%d个元素，分别是:\n&quot;</span>,StackLength(test));</span><br><span class="line">StackTraverse(test);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="built_in">exit</span> = ERR;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Goodbye~\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入错误请按标号重新输入！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="栈的链式存储结构实现"><a href="#栈的链式存储结构实现" class="headerlink" title="栈的链式存储结构实现"></a>栈的链式存储结构实现</h3><p>LinkStack.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LINKSTACK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINKSTACK_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*                                宏定义</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Elemtype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*                                结构体定义</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    </span><br><span class="line">&#125;StackNode,*LinkStackPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LinkStackPtr top;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*                                函数声明</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">visit</span><span class="params">(Elemtype c)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(LinkStack *S)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(LinkStack S)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">ClearStack</span><span class="params">(LinkStack *S)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackLength</span><span class="params">(LinkStack S)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(LinkStack S,Elemtype *e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">( LinkStack *S,Elemtype e )</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">( LinkStack *S,Elemtype *e )</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">StackTraverse</span><span class="params">(LinkStack S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* LINKSTACK_H */</span></span></span><br></pre></td></tr></table></figure><p>LinkStack.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;LinkStack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  构造一个空栈S */</span></span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(LinkStack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">        <span class="comment">// S-&gt;top = (LinkStackPtr)malloc(sizeof(StackNode)); /* 为头指针分配空间 */</span></span><br><span class="line">        <span class="comment">// if(!S-&gt;top)/* 内存分配失败 */</span></span><br><span class="line">        <span class="comment">//         return ERR;</span></span><br><span class="line">        <span class="comment">// S-&gt;top-&gt;next=NULL;/* 空栈S头指针指向空 */</span></span><br><span class="line">S-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">        S-&gt;count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若栈S为空栈，则返回TRUE，否则返回FALSE */</span></span><br><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(LinkStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (S.count==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> TRUE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把S置为空栈 */</span></span><br><span class="line"><span class="function">Status <span class="title">ClearStack</span><span class="params">(LinkStack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">        LinkStackPtr pxTop,temp;</span><br><span class="line">        pxTop = S-&gt;top;</span><br><span class="line">        <span class="keyword">while</span>(pxTop)<span class="comment">/* 直到头指针为空 */</span></span><br><span class="line">        &#123;  </span><br><span class="line">                temp=pxTop;</span><br><span class="line">                pxTop=pxTop-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125; </span><br><span class="line">        S-&gt;count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回S的元素个数，即栈的长度 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackLength</span><span class="params">(LinkStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> S.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERROR */</span></span><br><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(LinkStack S,Elemtype *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (S.top==<span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> ERR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                *e=S.top-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入元素e为新的栈顶元素 */</span></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">( LinkStack *S,Elemtype e )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkStackPtr newnode = (LinkStackPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">newnode-&gt;data = e;</span><br><span class="line">newnode-&gt;next = S-&gt;top;</span><br><span class="line">S-&gt;top = newnode;</span><br><span class="line">S-&gt;count++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若栈非空，删除栈顶元素用e返回其值 */</span></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">( LinkStack *S,Elemtype *e )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkStackPtr pxTop;</span><br><span class="line"><span class="keyword">if</span> (StackEmpty(*S))<span class="comment">/* 若栈空返回err */</span></span><br><span class="line"><span class="keyword">return</span> ERR;</span><br><span class="line">pxTop = S-&gt;top;</span><br><span class="line">*e = pxTop-&gt;data;</span><br><span class="line">S-&gt;top = S-&gt;top-&gt;next; <span class="comment">/* 使得栈顶指针下移一位，指向后一结点 */</span></span><br><span class="line"><span class="built_in">free</span>(pxTop);</span><br><span class="line">S-&gt;count--;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">visit</span><span class="params">(Elemtype c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,c);</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 从栈底到栈顶依次对栈中每个元素显示 */</span></span><br><span class="line"><span class="function">Status <span class="title">StackTraverse</span><span class="params">(LinkStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.count == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;栈空！\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ERR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        LinkStackPtr p=S.top;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">visit(p-&gt;data);</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> opt;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">exit</span> = OK;</span><br><span class="line">LinkStack test;</span><br><span class="line">InitStack(&amp;test);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">exit</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n======================================================================================================================== \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt;&gt;请输入操作标号: 1.初始化栈; 2.将元素e入栈; 3.将栈顶元素弹出; 4.将栈清空; 5.打印栈内元素; 0.退出;\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;opt);</span><br><span class="line"><span class="keyword">switch</span> (opt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line">InitStack(&amp;test);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;初始化完成，目前栈为空!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">&#123;</span><br><span class="line">Elemtype val;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入入栈元素的值并按回车:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val);</span><br><span class="line"><span class="keyword">if</span>(Push(&amp;test,val))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;入栈成功!目前栈内有%d个元素。\n&quot;</span>,StackLength(test));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">&#123;</span><br><span class="line">Elemtype val;</span><br><span class="line"><span class="keyword">if</span> (Pop(&amp;test,&amp;val))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;栈顶元素%d弹出,目前栈内有%d个元素。\n&quot;</span>,val,StackLength(test));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ClearStack(&amp;test))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;清空完成，目前栈内有%d个元素。\n&quot;</span>,StackLength(test));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;目前栈内有%d个元素，分别是:\n&quot;</span>,StackLength(test));</span><br><span class="line">StackTraverse(test);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="built_in">exit</span> = ERR;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Goodbye~\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入错误请按标号重新输入！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="栈总结"><a href="#栈总结" class="headerlink" title="栈总结"></a>栈总结</h3><p>由于链栈每个元素都有指针域增加了一些内存开销，所以在栈的大小相对确定或变化在可控范围内时最好使用顺序栈。反之如果栈中的元素变化不可预料，最好使用对于栈长度无限制的链栈。</p><h2 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列 queue"></a>队列 queue</h2><p>队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。把允许插入的一端称为队尾，允许删除的一端称为队头。队列又称为<strong>先进先出(First In First Out)<strong>的线性表，简称</strong>FIFO</strong>结构。</p><p>队列也是作为一种特殊的线性表，同样存在顺序存储、链式存储两种存储方式。</p><h3 id="队列的顺序存储"><a href="#队列的顺序存储" class="headerlink" title="队列的顺序存储"></a>队列的顺序存储</h3><p>sqqueue.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SQQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQQUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*                                宏定义</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20 <span class="comment">/* 存储空间初始分配量 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Elemtype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*                                结构体定义</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* 循环队列的顺序存储结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Elemtype data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> front;    <span class="comment">/* 头指针 */</span></span><br><span class="line"><span class="keyword">int</span> rear;<span class="comment">/* 尾指针，若队列不空，指向队列尾元素的下一个位置 */</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*                                函数声明</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">visit</span><span class="params">(Elemtype c)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue *Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">ClearQueue</span><span class="params">(SqQueue *Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">GetHead</span><span class="params">(SqQueue Q,Elemtype *e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue *Q,Elemtype e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue *Q,Elemtype *e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">QueueTraverse</span><span class="params">(SqQueue Q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* SQQUEUE_H */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>sqqueue.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sqqueue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">visit</span><span class="params">(Elemtype c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,c);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化一个空队列Q */</span></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Q-&gt;front=<span class="number">0</span>;</span><br><span class="line">Q-&gt;rear=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将Q清为空队列 */</span></span><br><span class="line"><span class="function">Status <span class="title">ClearQueue</span><span class="params">(SqQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Q-&gt;front=Q-&gt;rear=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若队列Q为空队列,则返回TRUE,否则返回FALSE */</span></span><br><span class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear) <span class="comment">/* 队列空的标志 */</span></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回Q的元素个数，也就是队列的当前长度 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span>  (Q.rear-Q.front+MAXSIZE)%MAXSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若队列不空,则用e返回Q的队头元素,并返回OK,否则返回ERROR */</span></span><br><span class="line"><span class="function">Status <span class="title">GetHead</span><span class="params">(SqQueue Q,Elemtype *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear) <span class="comment">/* 队列空 */</span></span><br><span class="line"><span class="keyword">return</span> ERR;</span><br><span class="line">*e=Q.data[Q.front];</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若队列未满，则插入元素e为Q新的队尾元素 */</span></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue *Q,Elemtype e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((Q-&gt;rear+<span class="number">1</span>)%MAXSIZE == Q-&gt;front)<span class="comment">/* 队列满的判断 */</span></span><br><span class="line"><span class="keyword">return</span> ERR;</span><br><span class="line">Q-&gt;data[Q-&gt;rear]=e;<span class="comment">/* 将元素e赋值给队尾 */</span></span><br><span class="line">Q-&gt;rear=(Q-&gt;rear+<span class="number">1</span>)%MAXSIZE;<span class="comment">/* rear指针向后移一位置， */</span></span><br><span class="line"><span class="comment">/* 若到最后则转到数组头部 */</span></span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若队列不空，则删除Q中队头元素，用e返回其值 */</span></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue *Q,Elemtype *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)<span class="comment">/* 队列空的判断 */</span></span><br><span class="line"><span class="keyword">return</span> ERR;</span><br><span class="line">*e=Q-&gt;data[Q-&gt;front];<span class="comment">/* 将队头元素赋值给e */</span></span><br><span class="line">Q-&gt;front=(Q-&gt;front+<span class="number">1</span>)%MAXSIZE;<span class="comment">/* front指针向后移一位置， */</span></span><br><span class="line"><span class="comment">/* 若到最后则转到数组头部 */</span></span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从队头到队尾依次对队列Q中每个元素输出 */</span></span><br><span class="line"><span class="function">Status <span class="title">QueueTraverse</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">i=Q.front;</span><br><span class="line"><span class="keyword">while</span>(i!=Q.rear)</span><br><span class="line">&#123;</span><br><span class="line">visit(Q.data[i]);</span><br><span class="line">i=(i+<span class="number">1</span>)%MAXSIZE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> opt;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">exit</span> = OK;</span><br><span class="line">SqQueue test;</span><br><span class="line">InitQueue(&amp;test);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">exit</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n======================================================================================================================== \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt;&gt;请输入操作标号: 1.初始化队列; 2.队尾入队 3.队头出队 4.队列清空; 5.打印队列内元素; 0.退出;\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;opt);</span><br><span class="line"><span class="keyword">switch</span> (opt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line">InitQueue(&amp;test);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;初始化完成，目前队列为空!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">&#123;</span><br><span class="line">Elemtype val;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入入队元素的值并按回车:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val);</span><br><span class="line"><span class="keyword">if</span>(EnQueue(&amp;test,val))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;入队成功!目前栈内有%d个元素。\n&quot;</span>,QueueLength(test));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">&#123;</span><br><span class="line">Elemtype val;</span><br><span class="line"><span class="keyword">if</span> (DeQueue(&amp;test,&amp;val))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;队头元素%d弹出,目前队内有%d个元素。\n&quot;</span>,val,QueueLength(test));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;操作失败，当前队列空！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ClearQueue(&amp;test))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;清空完成，目前队内有%d个元素。\n&quot;</span>,QueueLength(test));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;目前站内有%d个元素，分别是:\n&quot;</span>,QueueLength(test));</span><br><span class="line">QueueTraverse(test);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="built_in">exit</span> = ERR;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Goodbye~\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入错误请按标号重新输入！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h3><p>linkqueue.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LINKQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINKQUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*                                宏定义</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20 <span class="comment">/* 存储空间初始分配量 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW 3 <span class="comment">// overflow range error in math.h</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Elemtype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*                                结构体定义</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>/* 结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   Elemtype data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>/* 队列的链表结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   QueuePtr front,rear; <span class="comment">/* 队头、队尾指针 */</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*                                函数声明</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">visit</span><span class="params">(Elemtype c)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue *Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(LinkQueue *Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">ClearQueue</span><span class="params">(LinkQueue *Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(LinkQueue Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">GetHead</span><span class="params">(LinkQueue Q,Elemtype *e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue *Q,Elemtype e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue *Q,Elemtype *e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">QueueTraverse</span><span class="params">(LinkQueue Q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* LINKQUEUE_H </span></span></span><br><span class="line"><span class="comment"><span class="meta"></span></span></span><br></pre></td></tr></table></figure><p>linkqueue.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;linkqueue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">visit</span><span class="params">(Elemtype c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,c);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造一个空队列Q */</span></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">Q-&gt;front=Q-&gt;rear=(QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"><span class="keyword">if</span>(!Q-&gt;front)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OVERFLOW!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Q-&gt;front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 销毁队列Q */</span></span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(LinkQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(Q-&gt;front)</span><br><span class="line">&#123;</span><br><span class="line"> Q-&gt;rear=Q-&gt;front-&gt;next;</span><br><span class="line"> <span class="built_in">free</span>(Q-&gt;front);</span><br><span class="line"> Q-&gt;front=Q-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将Q清为空队列 */</span></span><br><span class="line"><span class="function">Status <span class="title">ClearQueue</span><span class="params">(LinkQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p,q;</span><br><span class="line">Q-&gt;rear=Q-&gt;front;</span><br><span class="line">p=Q-&gt;front-&gt;next;</span><br><span class="line">Q-&gt;front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line"> q=p;</span><br><span class="line"> p=p-&gt;next;</span><br><span class="line"> <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若Q为空队列,则返回TRUE,否则返回FALSE */</span></span><br><span class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求队列的长度 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">QueuePtr p;</span><br><span class="line">p=Q.front;</span><br><span class="line"><span class="keyword">while</span>(Q.rear!=p)</span><br><span class="line">&#123;</span><br><span class="line"> i++;</span><br><span class="line"> p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若队列不空,则用e返回Q的队头元素,并返回OK,否则返回ERROR */</span></span><br><span class="line"><span class="function">Status <span class="title">GetHead</span><span class="params">(LinkQueue Q,Elemtype *e)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">QueuePtr p;</span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line"><span class="keyword">return</span> ERR;</span><br><span class="line">p=Q.front-&gt;next;</span><br><span class="line">*e=p-&gt;data;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入元素e为Q的新的队尾元素 */</span></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue *Q,Elemtype e)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">QueuePtr s=(QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"><span class="keyword">if</span>(!s) <span class="comment">/* 存储分配失败 */</span></span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">s-&gt;data=e;</span><br><span class="line">s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">Q-&gt;rear-&gt;next=s;<span class="comment">/* 把拥有元素e的新结点s赋值给原队尾结点的后继 */</span></span><br><span class="line">Q-&gt;rear=s;<span class="comment">/* 把当前的s设置为队尾结点，rear指向s */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若队列不空,删除Q的队头元素,用e返回其值,并返回OK,否则返回ERROR */</span></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue *Q,Elemtype *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line"><span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)</span><br><span class="line"><span class="keyword">return</span> ERR;</span><br><span class="line">p=Q-&gt;front-&gt;next;<span class="comment">/* 将欲删除的队头结点暂存给p*/</span></span><br><span class="line">*e=p-&gt;data;<span class="comment">/* 将欲删除的队头结点的值赋值给e */</span></span><br><span class="line">Q-&gt;front-&gt;next=p-&gt;next;<span class="comment">/* 将原队头结点的后继p-&gt;next赋值给头结点后继 */</span></span><br><span class="line"><span class="keyword">if</span>(Q-&gt;rear==p)<span class="comment">/* 若队头就是队尾，则删除后将rear指向头结点  */</span></span><br><span class="line">Q-&gt;rear=Q-&gt;front;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从队头到队尾依次对队列Q中每个元素输出 */</span></span><br><span class="line"><span class="function">Status <span class="title">QueueTraverse</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line">p=Q.front-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line"> visit(p-&gt;data);</span><br><span class="line"> p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> opt;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">exit</span> = OK;</span><br><span class="line">LinkQueue test;</span><br><span class="line">InitQueue(&amp;test);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">exit</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n======================================================================================================================== \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt;&gt;请输入操作标号: 1.初始化队列; 2.队尾入队 3.队头出队 4.队列清空; 5.打印队列内元素; 0.退出;\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;opt);</span><br><span class="line"><span class="keyword">switch</span> (opt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line">InitQueue(&amp;test);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;初始化完成，目前队列为空!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">&#123;</span><br><span class="line">Elemtype val;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入入队元素的值并按回车:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val);</span><br><span class="line"><span class="keyword">if</span>(EnQueue(&amp;test,val))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;入队成功!目前栈内有%d个元素。\n&quot;</span>,QueueLength(test));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">&#123;</span><br><span class="line">Elemtype val;</span><br><span class="line"><span class="keyword">if</span> (DeQueue(&amp;test,&amp;val))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;队头元素%d弹出,目前队内有%d个元素。\n&quot;</span>,val,QueueLength(test));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;操作失败，当前队列空！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ClearQueue(&amp;test))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;清空完成，目前队内有%d个元素。\n&quot;</span>,QueueLength(test));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;目前站内有%d个元素，分别是:\n&quot;</span>,QueueLength(test));</span><br><span class="line">QueueTraverse(test);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="built_in">exit</span> = ERR;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Goodbye~\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入错误请按标号重新输入！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="队列总结"><a href="#队列总结" class="headerlink" title="队列总结"></a>队列总结</h3><p>链队列适用于需要支持任意长度的队列，且对入队、出队和删除操作都需要支持的场景，而如果对访问效率要求较高的场景，则需要考虑使用循环队列。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 线性表 </category>
          
          <category> 栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32启动文件详解</title>
      <link href="/archives/c1ce48e1.html"/>
      <url>/archives/c1ce48e1.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> STM32 </tag>
            
            <tag> 启动文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蜂鸣器播放超级马里奥（STM32HAL库）</title>
      <link href="/archives/c8bc38b7.html"/>
      <url>/archives/c8bc38b7.html</url>
      
        <content type="html"><![CDATA[<h1 id="蜂鸣器播放超级马里奥（STM32HAL库）"><a href="#蜂鸣器播放超级马里奥（STM32HAL库）" class="headerlink" title="蜂鸣器播放超级马里奥（STM32HAL库）"></a>蜂鸣器播放超级马里奥（STM32HAL库）</h1><h2 id="硬件部分"><a href="#硬件部分" class="headerlink" title="硬件部分"></a>硬件部分</h2><h3 id="1-无源蜂鸣器原理"><a href="#1-无源蜂鸣器原理" class="headerlink" title="1.无源蜂鸣器原理"></a>1.无源蜂鸣器原理</h3><p>蜂鸣器按驱动方式可分为有源蜂鸣器（内含驱动线路）和无源蜂鸣器（外部驱动）（“源”指的是激励源）。有源蜂鸣器虽加电源就可以发出声音但频率相对固定，这里使用的是无源蜂鸣器，无源蜂鸣器利用电磁感应现象，为音圈接入交变电流后形成的电磁铁与永磁铁相吸或相斥而推动振膜发声，接入直流电只能持续推动振膜而无法产生声音，只能在接通或断开时产生声音。</p><p><img src="https://s2.loli.net/2022/07/10/WOXjlsmMY3H785g.png" alt="蜂鸣器部分原理图">  </p><h3 id="2-频率音调对照表"><a href="#2-频率音调对照表" class="headerlink" title="2.频率音调对照表"></a>2.频率音调对照表</h3><p>所以只需要将无源蜂鸣器接入电路中并用单片机控制引脚给它一定频率的方波信号就可以产生不同音调，再用延时加以节奏就可以用蜂鸣器模拟曲调实现音乐效果了。 </p><p><img src="https://s2.loli.net/2022/08/15/41aSPR9oK2kXtOJ.jpg" alt="频率音调对照表">  </p><h2 id="软件部分"><a href="#软件部分" class="headerlink" title="软件部分"></a>软件部分</h2><h3 id="1-播放单个音调"><a href="#1-播放单个音调" class="headerlink" title="1.播放单个音调"></a>1.播放单个音调</h3><h4 id="音调"><a href="#音调" class="headerlink" title="音调"></a>音调</h4><p>函数第一个参数hz控制声音音调，本质是在循环中控制高低电平时间及占比即可控制音调，比如要播放中音1这个音调，该音调频率为523Hz也就是每个电平变化周期是1/523s==&gt;1000000/523us，让其中高低电平各占一半，即输出低电平后延时500000/523us再输出低电平，后再延时500000/523us再输出高电平。</p><h4 id="持续时间"><a href="#持续时间" class="headerlink" title="持续时间"></a>持续时间</h4><p>函数第二个参数time控制音调时间，本质是控制循环的次数，如播放523Hz音调电平每秒需要切换523次，那100ms需要切换的次数就为523*100/1000次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Beep</span><span class="params">(<span class="keyword">uint16_t</span> hz,<span class="keyword">uint16_t</span> time)</span></span>&#123;</span><br><span class="line"><span class="keyword">uint16_t</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;hz*time/<span class="number">1000</span>; i++)&#123;<span class="comment">//循环次数决定单音的时长</span></span><br><span class="line">       HAL_GPIO_WritePin(BEEP1_GPIO_Port,BEEP1_Pin,GPIO_PIN_RESET); <span class="comment">//蜂鸣器接口输出低电平</span></span><br><span class="line">       delay_us(<span class="number">500000</span>/hz); <span class="comment">//延时</span></span><br><span class="line">       HAL_GPIO_WritePin(BEEP1_GPIO_Port,BEEP1_Pin,GPIO_PIN_SET); <span class="comment">//蜂鸣器接口输出高电平</span></span><br><span class="line">       delay_us(<span class="number">500000</span>/hz); <span class="comment">//延时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-播放整首"><a href="#2-播放整首" class="headerlink" title="2.播放整首"></a>2.播放整首</h3><p>有了控制蜂鸣器播放单个音调的函数之后，想要播放整首歌就很简单了，只需要找到该歌曲的简谱，根据音符填入对应的频率即可。这里我们把频率都写入一个数组中，方便程序遍历。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint16_t</span> mario[] = &#123;<span class="number">659</span>, <span class="number">659</span>, <span class="number">15</span>, <span class="number">659</span>, <span class="number">15</span>, <span class="number">523</span>, <span class="number">659</span>, <span class="number">15</span>, <span class="number">784</span>, <span class="number">30</span>, <span class="number">392</span>, <span class="number">45</span>, <span class="number">523</span>,</span><br><span class="line">    <span class="number">30</span>, <span class="number">392</span>, <span class="number">30</span>, <span class="number">330</span>, <span class="number">30</span>, <span class="number">440</span>, <span class="number">30</span>, <span class="number">494</span>, <span class="number">15</span>, <span class="number">466</span>, <span class="number">440</span>, <span class="number">15</span>, <span class="number">392</span>, <span class="number">15</span>,<span class="number">659</span>, <span class="number">784</span>,</span><br><span class="line">    <span class="number">880</span>, <span class="number">15</span>, <span class="number">698</span>, <span class="number">784</span>, <span class="number">15</span>, <span class="number">659</span>, <span class="number">15</span>, <span class="number">523</span>, <span class="number">587</span>, <span class="number">494</span>, <span class="number">30</span>, <span class="number">523</span>, <span class="number">30</span>, <span class="number">392</span>, <span class="number">30</span>,</span><br><span class="line">    <span class="number">330</span>, <span class="number">30</span>, <span class="number">440</span>, <span class="number">30</span>, <span class="number">494</span>, <span class="number">15</span>, <span class="number">466</span>, <span class="number">440</span>, <span class="number">15</span>, <span class="number">392</span>, <span class="number">15</span>, <span class="number">659</span>, <span class="number">784</span>, <span class="number">880</span>, <span class="number">15</span>,</span><br><span class="line">    <span class="number">698</span>, <span class="number">784</span>, <span class="number">15</span>, <span class="number">659</span>, <span class="number">15</span>, <span class="number">523</span>, <span class="number">587</span>, <span class="number">494</span>, <span class="number">15</span>, <span class="number">784</span>, <span class="number">740</span>, <span class="number">622</span>, <span class="number">659</span>, <span class="number">523</span>,</span><br><span class="line">    <span class="number">587</span>, <span class="number">392</span>, <span class="number">440</span>, <span class="number">523</span>, <span class="number">15</span>, <span class="number">440</span>, <span class="number">523</span>, <span class="number">587</span>, <span class="number">15</span>, <span class="number">784</span>, <span class="number">740</span>, <span class="number">622</span>, <span class="number">659</span>, <span class="number">523</span>,</span><br><span class="line">    <span class="number">15</span>, <span class="number">1046</span>, <span class="number">15</span>, <span class="number">1046</span>, <span class="number">1046</span>, <span class="number">30</span>, <span class="number">784</span>, <span class="number">740</span>, <span class="number">622</span>, <span class="number">659</span>, <span class="number">523</span>, <span class="number">587</span>, <span class="number">392</span>, <span class="number">440</span>,</span><br><span class="line">    <span class="number">523</span>, <span class="number">15</span>, <span class="number">440</span>, <span class="number">523</span>, <span class="number">587</span>, <span class="number">15</span>, <span class="number">622</span>, <span class="number">30</span>, <span class="number">587</span>, <span class="number">30</span>, <span class="number">523</span>, <span class="number">30</span>, <span class="number">392</span>, <span class="number">392</span>, <span class="number">15</span>,</span><br><span class="line">    <span class="number">392</span>, <span class="number">30</span>, <span class="number">523</span>, <span class="number">523</span>, <span class="number">15</span>, <span class="number">523</span>, <span class="number">15</span>, <span class="number">523</span>, <span class="number">587</span>, <span class="number">15</span>, <span class="number">659</span>, <span class="number">523</span>, <span class="number">15</span>, <span class="number">440</span>, <span class="number">392</span>,</span><br><span class="line">    <span class="number">15</span>, <span class="number">523</span>, <span class="number">523</span>, <span class="number">15</span>, <span class="number">523</span>, <span class="number">15</span>, <span class="number">523</span>, <span class="number">587</span>, <span class="number">659</span>, <span class="number">15</span>, <span class="number">392</span>, <span class="number">15</span>, <span class="number">523</span>, <span class="number">523</span>, <span class="number">15</span>,</span><br><span class="line">    <span class="number">523</span>, <span class="number">15</span>, <span class="number">523</span>, <span class="number">587</span>, <span class="number">15</span>, <span class="number">659</span>, <span class="number">523</span>, <span class="number">15</span>, <span class="number">440</span>, <span class="number">392</span>, <span class="number">15</span>, <span class="number">659</span>, <span class="number">659</span>, <span class="number">15</span>, <span class="number">659</span>,</span><br><span class="line">    <span class="number">15</span>, <span class="number">523</span>, <span class="number">659</span>, <span class="number">15</span>, <span class="number">784</span>, <span class="number">30</span>, <span class="number">523</span>, <span class="number">30</span>, <span class="number">392</span>, <span class="number">30</span>, <span class="number">330</span>, <span class="number">30</span>, <span class="number">440</span>, <span class="number">30</span>, <span class="number">494</span>,</span><br><span class="line">    <span class="number">15</span>, <span class="number">466</span>, <span class="number">440</span>, <span class="number">15</span>, <span class="number">392</span>, <span class="number">15</span>, <span class="number">659</span>, <span class="number">784</span>, <span class="number">880</span>, <span class="number">15</span>, <span class="number">698</span>, <span class="number">784</span>, <span class="number">15</span>, <span class="number">659</span>, <span class="number">15</span>,</span><br><span class="line">    <span class="number">523</span>, <span class="number">587</span>, <span class="number">494</span>, <span class="number">30</span>, <span class="number">523</span>, <span class="number">30</span>, <span class="number">392</span>, <span class="number">30</span>, <span class="number">330</span>, <span class="number">30</span>, <span class="number">440</span>, <span class="number">30</span>, <span class="number">494</span>, <span class="number">15</span>, <span class="number">466</span>,</span><br><span class="line">    <span class="number">440</span>, <span class="number">15</span>, <span class="number">392</span>, <span class="number">15</span>, <span class="number">659</span>, <span class="number">784</span>, <span class="number">880</span>, <span class="number">15</span>, <span class="number">698</span>, <span class="number">784</span>, <span class="number">15</span>, <span class="number">659</span>, <span class="number">15</span>, <span class="number">523</span>, <span class="number">587</span>,</span><br><span class="line">    <span class="number">494</span>, <span class="number">30</span>, <span class="number">659</span>, <span class="number">523</span>, <span class="number">15</span>, <span class="number">392</span>, <span class="number">15</span>, <span class="number">415</span>, <span class="number">15</span>, <span class="number">440</span>, <span class="number">698</span>, <span class="number">15</span>, <span class="number">698</span>, <span class="number">698</span>, <span class="number">30</span>,</span><br><span class="line">    <span class="number">494</span>, <span class="number">880</span>, <span class="number">15</span>, <span class="number">880</span>, <span class="number">5</span>, <span class="number">880</span>, <span class="number">5</span>, <span class="number">784</span>, <span class="number">5</span>, <span class="number">698</span>, <span class="number">15</span>, <span class="number">659</span>, <span class="number">523</span>, <span class="number">15</span>, <span class="number">440</span>, <span class="number">392</span>,</span><br><span class="line">    <span class="number">30</span>, <span class="number">659</span>, <span class="number">523</span>, <span class="number">15</span>, <span class="number">392</span>, <span class="number">15</span>, <span class="number">415</span>, <span class="number">15</span>, <span class="number">440</span>, <span class="number">698</span>, <span class="number">15</span>, <span class="number">698</span>, <span class="number">698</span>, <span class="number">30</span>, <span class="number">494</span>,</span><br><span class="line">    <span class="number">698</span>, <span class="number">5</span>, <span class="number">698</span>, <span class="number">5</span>, <span class="number">698</span>, <span class="number">5</span>, <span class="number">698</span>, <span class="number">5</span>, <span class="number">659</span>, <span class="number">5</span>, <span class="number">587</span>, <span class="number">523</span>, <span class="number">30</span>&#125;;</span><br></pre></td></tr></table></figure><p>剩下就只需要在播放函数中遍历此数组就好了，其中<code>ARRAY_SIZE(song)</code>是一个计算数组大小的函数宏，方便播放不同歌曲。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MIDI_PLAY</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">uint16_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint16_t</span> hz = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ARRAY_SIZE(song); i++)&#123;</span><br><span class="line">hz = song[i];</span><br><span class="line"><span class="keyword">if</span>(hz &lt; <span class="number">50</span>)</span><br><span class="line">HAL_Delay(hz*<span class="number">10</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    Beep(hz, <span class="number">160</span>);</span><br><span class="line">HAL_Delay(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在数组中加入了一些小于50的数作为节奏上的暂停，if语句判断如果如果小于50就延时该数值*10ms，还需要自己根据歌曲速度给<code>Beep</code>函数设定合适的音调时间。</p><h2 id="完整驱动代码"><a href="#完整驱动代码" class="headerlink" title="完整驱动代码"></a>完整驱动代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;buzzer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_SIZE(a) ((sizeof a)/(sizeof a[0]))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> song mario</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Beep</span><span class="params">(<span class="keyword">uint16_t</span> hz,<span class="keyword">uint16_t</span> time)</span></span>&#123;</span><br><span class="line"><span class="keyword">uint16_t</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;hz*time/<span class="number">1000</span>; i++)&#123;<span class="comment">//循环次数决定单音的时长</span></span><br><span class="line">       HAL_GPIO_WritePin(BEEP1_GPIO_Port,BEEP1_Pin,GPIO_PIN_RESET); <span class="comment">//蜂鸣器接口输出低电平</span></span><br><span class="line">       delay_us(<span class="number">500000</span>/hz); <span class="comment">//延时</span></span><br><span class="line">       HAL_GPIO_WritePin(BEEP1_GPIO_Port,BEEP1_Pin,GPIO_PIN_SET); <span class="comment">//蜂鸣器接口输出高电平</span></span><br><span class="line">       delay_us(<span class="number">500000</span>/hz); <span class="comment">//延时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*超级马里奥*/</span></span><br><span class="line"><span class="keyword">uint16_t</span> mario[] = &#123;<span class="number">659</span>, <span class="number">659</span>, <span class="number">15</span>, <span class="number">659</span>, <span class="number">15</span>, <span class="number">523</span>, <span class="number">659</span>, <span class="number">15</span>, <span class="number">784</span>, <span class="number">30</span>, <span class="number">392</span>, <span class="number">45</span>, <span class="number">523</span>,</span><br><span class="line">    <span class="number">30</span>, <span class="number">392</span>, <span class="number">30</span>, <span class="number">330</span>, <span class="number">30</span>, <span class="number">440</span>, <span class="number">30</span>, <span class="number">494</span>, <span class="number">15</span>, <span class="number">466</span>, <span class="number">440</span>, <span class="number">15</span>, <span class="number">392</span>, <span class="number">15</span>,<span class="number">659</span>, <span class="number">784</span>,</span><br><span class="line">    <span class="number">880</span>, <span class="number">15</span>, <span class="number">698</span>, <span class="number">784</span>, <span class="number">15</span>, <span class="number">659</span>, <span class="number">15</span>, <span class="number">523</span>, <span class="number">587</span>, <span class="number">494</span>, <span class="number">30</span>, <span class="number">523</span>, <span class="number">30</span>, <span class="number">392</span>, <span class="number">30</span>,</span><br><span class="line">    <span class="number">330</span>, <span class="number">30</span>, <span class="number">440</span>, <span class="number">30</span>, <span class="number">494</span>, <span class="number">15</span>, <span class="number">466</span>, <span class="number">440</span>, <span class="number">15</span>, <span class="number">392</span>, <span class="number">15</span>, <span class="number">659</span>, <span class="number">784</span>, <span class="number">880</span>, <span class="number">15</span>,</span><br><span class="line">    <span class="number">698</span>, <span class="number">784</span>, <span class="number">15</span>, <span class="number">659</span>, <span class="number">15</span>, <span class="number">523</span>, <span class="number">587</span>, <span class="number">494</span>, <span class="number">15</span>, <span class="number">784</span>, <span class="number">740</span>, <span class="number">622</span>, <span class="number">659</span>, <span class="number">523</span>,</span><br><span class="line">    <span class="number">587</span>, <span class="number">392</span>, <span class="number">440</span>, <span class="number">523</span>, <span class="number">15</span>, <span class="number">440</span>, <span class="number">523</span>, <span class="number">587</span>, <span class="number">15</span>, <span class="number">784</span>, <span class="number">740</span>, <span class="number">622</span>, <span class="number">659</span>, <span class="number">523</span>,</span><br><span class="line">    <span class="number">15</span>, <span class="number">1046</span>, <span class="number">15</span>, <span class="number">1046</span>, <span class="number">1046</span>, <span class="number">30</span>, <span class="number">784</span>, <span class="number">740</span>, <span class="number">622</span>, <span class="number">659</span>, <span class="number">523</span>, <span class="number">587</span>, <span class="number">392</span>, <span class="number">440</span>,</span><br><span class="line">    <span class="number">523</span>, <span class="number">15</span>, <span class="number">440</span>, <span class="number">523</span>, <span class="number">587</span>, <span class="number">15</span>, <span class="number">622</span>, <span class="number">30</span>, <span class="number">587</span>, <span class="number">30</span>, <span class="number">523</span>, <span class="number">30</span>, <span class="number">392</span>, <span class="number">392</span>, <span class="number">15</span>,</span><br><span class="line">    <span class="number">392</span>, <span class="number">30</span>, <span class="number">523</span>, <span class="number">523</span>, <span class="number">15</span>, <span class="number">523</span>, <span class="number">15</span>, <span class="number">523</span>, <span class="number">587</span>, <span class="number">15</span>, <span class="number">659</span>, <span class="number">523</span>, <span class="number">15</span>, <span class="number">440</span>, <span class="number">392</span>,</span><br><span class="line">    <span class="number">15</span>, <span class="number">523</span>, <span class="number">523</span>, <span class="number">15</span>, <span class="number">523</span>, <span class="number">15</span>, <span class="number">523</span>, <span class="number">587</span>, <span class="number">659</span>, <span class="number">15</span>, <span class="number">392</span>, <span class="number">15</span>, <span class="number">523</span>, <span class="number">523</span>, <span class="number">15</span>,</span><br><span class="line">    <span class="number">523</span>, <span class="number">15</span>, <span class="number">523</span>, <span class="number">587</span>, <span class="number">15</span>, <span class="number">659</span>, <span class="number">523</span>, <span class="number">15</span>, <span class="number">440</span>, <span class="number">392</span>, <span class="number">15</span>, <span class="number">659</span>, <span class="number">659</span>, <span class="number">15</span>, <span class="number">659</span>,</span><br><span class="line">    <span class="number">15</span>, <span class="number">523</span>, <span class="number">659</span>, <span class="number">15</span>, <span class="number">784</span>, <span class="number">30</span>, <span class="number">523</span>, <span class="number">30</span>, <span class="number">392</span>, <span class="number">30</span>, <span class="number">330</span>, <span class="number">30</span>, <span class="number">440</span>, <span class="number">30</span>, <span class="number">494</span>,</span><br><span class="line">    <span class="number">15</span>, <span class="number">466</span>, <span class="number">440</span>, <span class="number">15</span>, <span class="number">392</span>, <span class="number">15</span>, <span class="number">659</span>, <span class="number">784</span>, <span class="number">880</span>, <span class="number">15</span>, <span class="number">698</span>, <span class="number">784</span>, <span class="number">15</span>, <span class="number">659</span>, <span class="number">15</span>,</span><br><span class="line">    <span class="number">523</span>, <span class="number">587</span>, <span class="number">494</span>, <span class="number">30</span>, <span class="number">523</span>, <span class="number">30</span>, <span class="number">392</span>, <span class="number">30</span>, <span class="number">330</span>, <span class="number">30</span>, <span class="number">440</span>, <span class="number">30</span>, <span class="number">494</span>, <span class="number">15</span>, <span class="number">466</span>,</span><br><span class="line">    <span class="number">440</span>, <span class="number">15</span>, <span class="number">392</span>, <span class="number">15</span>, <span class="number">659</span>, <span class="number">784</span>, <span class="number">880</span>, <span class="number">15</span>, <span class="number">698</span>, <span class="number">784</span>, <span class="number">15</span>, <span class="number">659</span>, <span class="number">15</span>, <span class="number">523</span>, <span class="number">587</span>,</span><br><span class="line">    <span class="number">494</span>, <span class="number">30</span>, <span class="number">659</span>, <span class="number">523</span>, <span class="number">15</span>, <span class="number">392</span>, <span class="number">15</span>, <span class="number">415</span>, <span class="number">15</span>, <span class="number">440</span>, <span class="number">698</span>, <span class="number">15</span>, <span class="number">698</span>, <span class="number">698</span>, <span class="number">30</span>,</span><br><span class="line">    <span class="number">494</span>, <span class="number">880</span>, <span class="number">15</span>, <span class="number">880</span>, <span class="number">5</span>, <span class="number">880</span>, <span class="number">5</span>, <span class="number">784</span>, <span class="number">5</span>, <span class="number">698</span>, <span class="number">15</span>, <span class="number">659</span>, <span class="number">523</span>, <span class="number">15</span>, <span class="number">440</span>, <span class="number">392</span>,</span><br><span class="line">    <span class="number">30</span>, <span class="number">659</span>, <span class="number">523</span>, <span class="number">15</span>, <span class="number">392</span>, <span class="number">15</span>, <span class="number">415</span>, <span class="number">15</span>, <span class="number">440</span>, <span class="number">698</span>, <span class="number">15</span>, <span class="number">698</span>, <span class="number">698</span>, <span class="number">30</span>, <span class="number">494</span>,</span><br><span class="line">    <span class="number">698</span>, <span class="number">5</span>, <span class="number">698</span>, <span class="number">5</span>, <span class="number">698</span>, <span class="number">5</span>, <span class="number">698</span>, <span class="number">5</span>, <span class="number">659</span>, <span class="number">5</span>, <span class="number">587</span>, <span class="number">523</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*小星星*/</span></span><br><span class="line"><span class="keyword">uint16_t</span> star[] = &#123;<span class="number">523</span>,<span class="number">523</span>,<span class="number">784</span>,<span class="number">784</span>,<span class="number">880</span>,<span class="number">880</span>,<span class="number">784</span>,<span class="number">15</span>,<span class="number">698</span>,<span class="number">698</span>,<span class="number">659</span>,<span class="number">659</span>,<span class="number">587</span>,<span class="number">587</span>,<span class="number">523</span>,<span class="number">15</span>,<span class="number">784</span>,<span class="number">784</span>,<span class="number">698</span>,<span class="number">698</span>,<span class="number">659</span>,<span class="number">659</span>,<span class="number">587</span>,<span class="number">15</span>,<span class="number">784</span>,<span class="number">784</span>,<span class="number">698</span>,<span class="number">698</span>,<span class="number">659</span>,<span class="number">659</span>,<span class="number">587</span>,<span class="number">15</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MIDI_PLAY</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">uint16_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint16_t</span> hz = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ARRAY_SIZE(song); i++)&#123;</span><br><span class="line">hz = song[i];</span><br><span class="line"><span class="keyword">if</span>(hz &lt; <span class="number">50</span>)</span><br><span class="line">HAL_Delay(hz*<span class="number">10</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    Beep(hz, <span class="number">160</span>);</span><br><span class="line">HAL_Delay(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> STM32 </tag>
            
            <tag> HAL库 </tag>
            
            <tag> 蜂鸣器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——线性表</title>
      <link href="/archives/335a1544.html"/>
      <url>/archives/335a1544.html</url>
      
        <content type="html"><![CDATA[<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表(List):零个或多个数据元素的有限序列。</p><h3 id="顺序存储线性表"><a href="#顺序存储线性表" class="headerlink" title="顺序存储线性表"></a>顺序存储线性表</h3><ul><li>优点: 可以快速存取表中任一位置的元素，无需为变种元素之间的逻辑关系增加存储空间。</li><li>缺点: 插入删除需要移动大量元素，长度变化较大时难以确定存储空间的容量(分配大了浪费，小了溢出)，造成存储空间碎片。<br>查找性能O(1),插入删除O(n)。<br>若线性表需要频繁查找，很少进行插入和删除操作时可以采用顺序存储结构，一个简单的顺序存储线性表实现例子:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*                                宏定义</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*                                结构体定义</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line">&#125;sqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*                                函数</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化顺序线性表 */</span></span><br><span class="line"><span class="function">Status <span class="title">ListInit</span><span class="params">(sqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ElemType defaultList[11] = &#123;1,8,0,2,5,3,3,1,4,0,8&#125;;</span></span><br><span class="line"><span class="comment">// for (int i = 0; i &lt;L-&gt;len ; i++)</span></span><br><span class="line"><span class="comment">// L-&gt;data[i] = defaultList[i];</span></span><br><span class="line"><span class="comment">// L-&gt;len = 11;</span></span><br><span class="line"></span><br><span class="line">L-&gt;len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在。操作结果：若L为空表，则返回TRUE，否则返回FALSE */</span></span><br><span class="line"><span class="function">Status <span class="title">ListEmpty</span><span class="params">(sqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">if</span>(L.len == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在。操作结果：返回L中数据元素个数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(sqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> L.len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span></span><br><span class="line"><span class="comment">/* 操作结果：用e返回L中第i个数据元素的值,注意i是指位置，第1个位置的数组是从0开始 */</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(sqList L,<span class="keyword">int</span> i ,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L.len == <span class="number">0</span> || i&lt;<span class="number">1</span> || i&gt;L.len )</span><br><span class="line"><span class="keyword">return</span> ERR;</span><br><span class="line">*e = L.data[i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， */</span></span><br><span class="line"><span class="comment">/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */</span></span><br><span class="line"><span class="function">Status <span class="title">ListIns</span><span class="params">(sqList *L ,<span class="keyword">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;len == MAXSIZE )<span class="comment">/* 顺序线性表已经满 */</span></span><br><span class="line"><span class="keyword">return</span> ERR;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;len+<span class="number">1</span>)<span class="comment">/* 当i比第一位置小或者比最后一位置后一位置还要大时 */</span></span><br><span class="line"><span class="keyword">return</span> ERR;</span><br><span class="line"><span class="keyword">if</span> ( i&lt;= L-&gt;len)<span class="comment">/* 若插入数据位置不在表尾 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (k = L-&gt;len<span class="number">-1</span>;k&gt;=i<span class="number">-1</span>;k--)<span class="comment">/* 将要插入位置之后的数据元素向后移动一位 */</span></span><br><span class="line">L-&gt;data[k+<span class="number">1</span>] = L-&gt;data[k];</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;data[i<span class="number">-1</span>] = e; <span class="comment">/* 将新元素插入 */</span></span><br><span class="line">L-&gt;len++;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span></span><br><span class="line"><span class="comment">/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */</span></span><br><span class="line"><span class="function">Status <span class="title">ListDel</span><span class="params">(sqList *L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;len == <span class="number">0</span>)<span class="comment">/* 线性表为空 */</span></span><br><span class="line"><span class="keyword">return</span> ERR;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;len)<span class="comment">/* 删除位置不正确 */</span></span><br><span class="line"><span class="keyword">return</span> ERR;</span><br><span class="line">*e = L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(i&lt;L-&gt;len)<span class="comment">/* 如果删除不是最后位置 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (k=i;k&lt;L-&gt;len;k++)</span><br><span class="line">L-&gt;data[k<span class="number">-1</span>] = L-&gt;data[k];<span class="comment">/* 将删除位置后继元素前移 */</span></span><br><span class="line">&#125;</span><br><span class="line">L-&gt;len--;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在 */</span></span><br><span class="line"><span class="comment">/* 操作结果：依次对L的每个数据元素输出 */</span></span><br><span class="line"><span class="function">Status <span class="title">PrintList</span><span class="params">(sqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L.len == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前表为空!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ERR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;L.len<span class="number">-1</span> ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>,L.data[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>,L.data[L.len<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在 */</span></span><br><span class="line"><span class="comment">/* 操作结果：返回L中第1个与e满足关系的数据元素的位序。 */</span></span><br><span class="line"><span class="comment">/* 若这样的数据元素不存在，则返回值为0 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(sqList L,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (L.len==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">if</span> (L.data[i]==e)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=L.len)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将所有的在线性表Lb中但不在La中的数据元素插入到La中*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionL</span><span class="params">(sqList *La,sqList Lb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> La_len,Lb_len,i;</span><br><span class="line">ElemType e;                        <span class="comment">/*声明与La和Lb相同的数据元素e*/</span></span><br><span class="line">La_len=ListLength(*La);            <span class="comment">/*求线性表的长度 */</span></span><br><span class="line">Lb_len=ListLength(Lb);</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=Lb_len;i++)</span><br><span class="line">&#123;</span><br><span class="line">GetElem(Lb,i,&amp;e);              <span class="comment">/*取Lb中第i个数据元素赋给e*/</span></span><br><span class="line"><span class="keyword">if</span> (!LocateElem(*La,e))        <span class="comment">/*La中不存在和e相同数据元素*/</span></span><br><span class="line">ListInsert(La,++La_len,e); <span class="comment">/*插入*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> opt;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">exit</span> = OK;</span><br><span class="line">sqList thislist;</span><br><span class="line">ListInit(&amp;thislist);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">exit</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n===================================================================================================== \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt;&gt;请输入操作标号: 1.初始化顺序线性表; 2.在第i个位置插入新元素e; 3.删除第i位元素; 4.查看第i位元素; 5.查看当前表; 0.退出;\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;opt);</span><br><span class="line"><span class="keyword">switch</span> (opt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line">ListInit(&amp;thislist);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;初始化完成，目前线性表元素为:&quot;</span>);</span><br><span class="line">PrintList(thislist);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i,e;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请依次输入i和e的值:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;i,&amp;e);</span><br><span class="line"><span class="keyword">if</span> (ListIns(&amp;thislist,i,e))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入成功，目前线性表元素为:&quot;</span>);</span><br><span class="line">PrintList(thislist);</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入失败!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i,e;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入i的值:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i);</span><br><span class="line"><span class="keyword">if</span> (ListDel(&amp;thislist,i,&amp;e))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除成功，目前线性表元素为:&quot;</span>);</span><br><span class="line">PrintList(thislist);</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除失败!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i,e;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入i的值:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i);</span><br><span class="line"><span class="keyword">if</span> (GetElem(thislist,i,&amp;e))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;取值成功，目前线性表第%d位元素为:%d\n&quot;</span>,i,e);</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;取值失败!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;目前线性表元素为:&quot;</span>);</span><br><span class="line">PrintList(thislist);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="built_in">exit</span> = ERR;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Goodbye~\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入错误请按标号重新输入！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="链式存储线性表"><a href="#链式存储线性表" class="headerlink" title="链式存储线性表"></a>链式存储线性表</h3><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>单链表不需要提前分配存储空间，元素个数也不受限制。<br>查找性能O(n)，插入性能O(1).<br>如需要频繁插入删除时或线性表中元素个数变化较大或根本不知道有多大时可以采用链式存储线性表结构。一个简单的单链表实现例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*                                头文件</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*                                宏定义</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Elemtype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*                                结构体定义</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Elemtype data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node, *Linklist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*                                函数</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* 初始化链式线性表 */</span></span><br><span class="line"><span class="function">Status <span class="title">InitList</span> <span class="params">(Linklist *Head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">*Head = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">/* 产生头结点,并使Head指向此头结点 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!(*Head)) <span class="comment">/* 存储分配失败 */</span></span><br><span class="line">        <span class="keyword">return</span> ERR;</span><br><span class="line"></span><br><span class="line">(*Head)-&gt;next = <span class="literal">NULL</span>;<span class="comment">/* 指针域为空 */</span></span><br><span class="line">(*Head)-&gt;data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始条件：链式线性表L已存在。操作结果：若L为空表，则返回TRUE，否则返回FALSE */</span></span><br><span class="line"><span class="function">Status <span class="title">ListEmpty</span><span class="params">(Linklist L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始条件：链式线性表L已存在。操作结果：将L重置为空表 */</span></span><br><span class="line"><span class="function">Status <span class="title">CleanList</span> <span class="params">(Linklist *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Linklist p = (*L)-&gt;next;<span class="comment">/*  p指向第一个结点 */</span></span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line">Linklist tmp = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = tmp; </span><br><span class="line">&#125;</span><br><span class="line">(*L)-&gt;next = <span class="literal">NULL</span>;<span class="comment">/* 头结点指针域为空 */</span></span><br><span class="line">(*L)-&gt;data = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始条件：链式线性表L已存在。操作结果：返回L中数据元素个数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(Linklist L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// int i=0;</span></span><br><span class="line">    <span class="comment">// Linklist p=L-&gt;next; /* p指向第一个结点 */</span></span><br><span class="line">    <span class="comment">// while(p)                        </span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     i++;</span></span><br><span class="line">    <span class="comment">//     p=p-&gt;next;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// return i;</span></span><br><span class="line"><span class="keyword">return</span> L-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始条件：链式线性表L已存在，1≤i≤ListLength(L) */</span></span><br><span class="line"><span class="comment">/* 操作结果：用e返回L中第i个数据元素的值 */</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span> <span class="params">(Linklist L,<span class="keyword">int</span> i,Elemtype *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">Linklist p = L-&gt;next;<span class="comment">/* 让p指向链表L的第一个结点 */</span></span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; j &lt; i) <span class="comment">/* p不为空或者计数器j还没有等于i时，循环继续 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span> (!p || j&gt;i )  <span class="comment">/*  第i个元素不存在 */</span></span><br><span class="line"><span class="keyword">return</span> ERR;</span><br><span class="line">*e = p-&gt;data;<span class="comment">/*  取第i个元素的数据 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始条件：链式线性表L已存在 */</span></span><br><span class="line"><span class="comment">/* 操作结果：返回L中第1个与e满足关系的数据元素的位序。 */</span></span><br><span class="line"><span class="comment">/* 若这样的数据元素不存在，则返回值为0 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(Linklist L,Elemtype e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    Linklist p=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data==e) <span class="comment">/* 找到这样的数据元素 */</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始条件：链式线性表L已存在,1≤i≤ListLength(L)， */</span></span><br><span class="line"><span class="comment">/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */</span></span><br><span class="line"><span class="function">Status <span class="title">InsNode</span> <span class="params">(Linklist *L,<span class="keyword">int</span> i ,Elemtype e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">Linklist p = *L; </span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; j &lt; i) <span class="comment">/* 寻找第i个结点 */</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!p || j&gt;i )  <span class="comment">/* 第i个元素不存在 */</span></span><br><span class="line"><span class="keyword">return</span> ERR;</span><br><span class="line">Linklist new_node = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">/*  生成新结点(C语言标准函数) */</span></span><br><span class="line">new_node-&gt;data = e;</span><br><span class="line">new_node-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = new_node;</span><br><span class="line">++(*L)-&gt;data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始条件：链式线性表L已存在，1≤i≤ListLength(L) */</span></span><br><span class="line"><span class="comment">/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */</span></span><br><span class="line"><span class="function">Status <span class="title">DelNode</span> <span class="params">(Linklist *L,<span class="keyword">int</span> i ,Elemtype *e)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">Linklist prev = *L;</span><br><span class="line"><span class="keyword">while</span> (prev-&gt;next &amp;&amp; j &lt; i) <span class="comment">// 找到第i个节点的前一个节点prev</span></span><br><span class="line">&#123;</span><br><span class="line">prev = prev-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( !(prev-&gt;next) || j &gt; i ) <span class="comment">//第i个结点不存在</span></span><br><span class="line"><span class="keyword">return</span> ERR;</span><br><span class="line">Linklist p = prev-&gt;next; <span class="comment">// 找到第i个节点p</span></span><br><span class="line">prev-&gt;next = p-&gt;next;       <span class="comment">// 从链表中删除p节点</span></span><br><span class="line">*e = p-&gt;data;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">--(*L)-&gt;data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始条件：链式线性表L已存在 */</span></span><br><span class="line"><span class="comment">/* 操作结果：依次对L的每个数据元素输出 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintNode</span> <span class="params">(Linklist L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Linklist p = L-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;data);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  头插法插入元素e */</span></span><br><span class="line"><span class="function">Linklist <span class="title">ListInsHead</span> <span class="params">(Linklist *L , Elemtype e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Linklist new_node = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">new_node-&gt;data = e;</span><br><span class="line"><span class="keyword">if</span> ((*L)-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">(*L)-&gt;next = new_node;</span><br><span class="line">new_node-&gt;next  = <span class="literal">NULL</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">new_node-&gt;next = (*L)-&gt;next;</span><br><span class="line">(*L)-&gt;next = new_node;</span><br><span class="line">&#125;</span><br><span class="line">++(*L)-&gt;data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  尾插法插入元素e */</span></span><br><span class="line"><span class="function">Linklist <span class="title">ListInsTail</span> <span class="params">(Linklist *L , Elemtype e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Linklist new_node = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">new_node-&gt;data = e;</span><br><span class="line">new_node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">Linklist p = *L;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;   <span class="comment">// 找到链表的尾节点</span></span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = new_node;</span><br><span class="line">++(*L)-&gt;data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> opt;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">exit</span> = OK;</span><br><span class="line">Linklist thislist;</span><br><span class="line">InitList(&amp;thislist);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">exit</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n======================================================================================================================== \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt;&gt;请输入操作标号: 1.头插法增加结点; 2.尾插法增加结点; 3.在第i个位置之前插入新结点; 4.删除第i个位置的结点; 5.查看第i个结点的值; 6.清空当前链表; 7.查看当前链表; 0.退出;\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;opt);</span><br><span class="line"><span class="keyword">switch</span> (opt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line">Elemtype val;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入新增结点的值并按回车:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val);</span><br><span class="line">ListInsHead(&amp;thislist,val);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入完成，目前链表共%d有个结点。每个结点值分别为:&quot;</span>,thislist-&gt;data);</span><br><span class="line">PrintNode(thislist);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">&#123;</span><br><span class="line">Elemtype val;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入新增结点的值并按回车:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val);</span><br><span class="line">ListInsTail(&amp;thislist,val);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入完成，目前链表共%d有个结点。每个结点值分别为:&quot;</span>,thislist-&gt;data);</span><br><span class="line">PrintNode(thislist);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i,e;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入i的值:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入新增结点的值并按回车:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;e);</span><br><span class="line"><span class="keyword">if</span> (InsNode(&amp;thislist,i,e))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入完成，目前链表共%d有个结点。每个结点值分别为:&quot;</span>,thislist-&gt;data);</span><br><span class="line">PrintNode(thislist);</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入失败!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i,e;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入i的值:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i);</span><br><span class="line"><span class="keyword">if</span> (DelNode(&amp;thislist,i,&amp;e))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除完成，删除结点的值为: %d \n目前链表共有%d个结点。每个结点值分别为:&quot;</span>,e,thislist-&gt;data);</span><br><span class="line">PrintNode(thislist);</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除失败!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i,e;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入i的值:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i);</span><br><span class="line"><span class="keyword">if</span> (GetElem(thislist,i,&amp;e))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;该结点的值为: %d \n&quot;</span>,e);</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查看失败!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">&#123;</span><br><span class="line">CleanList(&amp;thislist);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;清空完成! \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (thislist-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前链表为空! 请先增加些结点。\n\n&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前链表共%d有个结点。每个结点值分别为:&quot;</span>,thislist-&gt;data);</span><br><span class="line">PrintNode(thislist);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="built_in">exit</span> = ERR;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Goodbye~\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入错误请按标号重新输入！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><p>静态链表在插入和删除操作时只需要移动游标不需要移动元素从而改进了顺序存储结构插入和删除元素需要移动大量元素的缺点。但是没有解决连续存储分配带来的表长难以确定问题，页数去了顺序存储随机存取的特性。下面是一个简单的静态链表实现例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*                                头文件</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*                                宏定义</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Elemtype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*                                结构体定义</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这是一个静态链表的数据结构定义，其中Component表示链表的每个结点，包括数据元素data和游标cur。</span></span><br><span class="line"><span class="comment">staticLinkList是一个数组，用于存储静态链表的所有结点，其中MAXSIZE表示静态链表的最大长度。*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Elemtype data;</span><br><span class="line"><span class="keyword">int</span> cur;<span class="comment">// 游标(cursor),为0时表示无指向</span></span><br><span class="line">&#125; Component,staticLinkList[MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*                                函数</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* 数组第一个元素space[0]的cur用来存放备用链表(空闲空间)第一个结点的下标。</span></span><br><span class="line"><span class="comment">   数组的最后一个元素[MAXSIZE-1]用来存放第一个插入元素的下标，相当于头结点，整个链表为空时则为0*/</span></span><br><span class="line"><span class="function">Status <span class="title">InitStaticList</span> <span class="params">(staticLinkList space)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;MAXSIZE<span class="number">-1</span>; i++)</span><br><span class="line">space[i].cur = i + <span class="number">1</span>;</span><br><span class="line">space[MAXSIZE<span class="number">-1</span>].cur = <span class="number">0</span>;<span class="comment">/* 目前静态链表为空，最后一个元素的cur为0 */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若备用空间链表非空（还有存储空间），则返回分配的节点下标，否则返回0*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Malloc_SLL</span> <span class="params">( staticLinkList space)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = space[<span class="number">0</span>].cur;<span class="comment">/* 当前数组第一个元素的cur存的值 */</span></span><br><span class="line">                        <span class="comment">/* 就是要返回的第一个备用空闲的下标 */</span></span><br><span class="line"><span class="keyword">if</span> (space[<span class="number">0</span>].cur)</span><br><span class="line">&#123;</span><br><span class="line">space[<span class="number">0</span>].cur = space[i].cur; <span class="comment">//将下一个空闲结点的下标放在space[0]的cur中以便下次使用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将下标为k的结点回收到备用链表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Free_SSL</span> <span class="params">(staticLinkList space , <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">space[k].cur = space[<span class="number">0</span>].cur;<span class="comment">//将备用链表(空闲空间)第一个结点的下标给要回收结点的下标</span></span><br><span class="line">space[<span class="number">0</span>].cur = k;<span class="comment">//space[0]的cur用来存放备用链表(空闲空间)第一个结点的下标</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始条件：静态链表L已存在。操作结果：返回L中数据元素个数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span> <span class="params">( staticLinkList L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">//存储静态链表L中元素的个数</span></span><br><span class="line"><span class="keyword">int</span> i = L[MAXSIZE<span class="number">-1</span>].cur;<span class="comment">//[MAXSIZE-1]用来存放第一个插入元素的下标</span></span><br><span class="line"><span class="keyword">while</span> (i)</span><br><span class="line">&#123;</span><br><span class="line">i = L[i].cur;           <span class="comment">//遍历静态链表直到最后一个有值元素（其cur的值为0）</span></span><br><span class="line">++num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向静态链表L的位置i插入e元素 */</span></span><br><span class="line"><span class="function">Status <span class="title">Ins_SSL</span> <span class="params">(staticLinkList L,<span class="keyword">int</span> i ,Elemtype e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( i&lt;<span class="number">1</span> || i &gt; ListLength(L)+<span class="number">1</span> ) <span class="comment">//验证插入位置的合法性</span></span><br><span class="line"><span class="keyword">return</span> ERR;</span><br><span class="line"><span class="keyword">int</span> k = MAXSIZE - <span class="number">1</span>;  <span class="comment">//[MAXSIZE-1]用来存放第一个插入元素的下标</span></span><br><span class="line"><span class="keyword">int</span> idle_node = Malloc_SLL(L);  </span><br><span class="line"><span class="keyword">if</span> (idle_node)<span class="comment">//如果没有空间Malloc_SLL(L)返回0复制给idle_node</span></span><br><span class="line">&#123;</span><br><span class="line">L[idle_node].data = e; </span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> pos = <span class="number">1</span>; pos &lt;= i<span class="number">-1</span> ; pos++) <span class="comment">//从[MAXSIZE-1].cur指向的第一个元素开始找到第i个元素之前的位置</span></span><br><span class="line">&#123;</span><br><span class="line">k = L[k].cur; </span><br><span class="line">&#125;</span><br><span class="line">L[idle_node].cur = L[k].cur; <span class="comment">//将找到的第i个元素前的位置的cur（也就是下个节点的位置）给新节点的cur</span></span><br><span class="line">L[k].cur = idle_node; <span class="comment">//将新插入元素的下标值给第i个元素前的位置的cur</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> ERR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  删除在L中第i个数据元素   */</span></span><br><span class="line"><span class="function">Status <span class="title">Del_SSL</span><span class="params">(staticLinkList L,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( i&lt;<span class="number">1</span> || i &gt; ListLength(L)  ) <span class="comment">//验证i位置的合法性</span></span><br><span class="line"><span class="keyword">return</span> ERR;</span><br><span class="line"><span class="keyword">int</span> k = MAXSIZE - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> pos = <span class="number">1</span>; pos &lt;= i<span class="number">-1</span> ; pos++) <span class="comment">//从[MAXSIZE-1].cur指向的第一个元素开始找到第i个元素之前的位置</span></span><br><span class="line">&#123;</span><br><span class="line">k = L[k].cur; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> temp = L[k].cur; <span class="comment">//将要删除的结点的cur值，也就是后面结点的下标给temp</span></span><br><span class="line">L[k].cur = L[temp].cur; <span class="comment">//将下面结点的cur值赋给第i个元素之前的位置</span></span><br><span class="line">Free_SSL(L,temp);<span class="comment">//将temp位置的结点释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_SSL</span> <span class="params">(staticLinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = L[MAXSIZE<span class="number">-1</span>].cur;<span class="comment">//[MAXSIZE-1]用来存放第一个插入元素的下标</span></span><br><span class="line"><span class="keyword">while</span> (i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,L[i].data);</span><br><span class="line">i = L[i].cur;           <span class="comment">//遍历静态链表直到最后一个有值元素（其cur的值为0）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> opt;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">exit</span> = OK;</span><br><span class="line">staticLinkList thisList;</span><br><span class="line"><span class="keyword">if</span> (InitStaticList(thisList))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;静态链表初始化成功！&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;静态链表初始化失败！&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">exit</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n===================================================================================================== \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt;&gt;请输入操作标号: 1.在第i个位置插入新元素e; 2.删除第i位元素; 3.查看当前表; 0.退出;\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;opt);</span><br><span class="line"><span class="keyword">switch</span> (opt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i,e;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请依次输入i和e的值:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;i,&amp;e);</span><br><span class="line"><span class="keyword">if</span>(Ins_SSL(thisList,i,e))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入成功，目前静态链表共有%d个元素，分别为:&quot;</span>,ListLength(thisList));</span><br><span class="line">Print_SSL(thisList);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入失败!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请依次输入i的值:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i);</span><br><span class="line"><span class="keyword">if</span> (thisList[MAXSIZE<span class="number">-1</span>].cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ListLength(thisList) == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Del_SSL(thisList,i))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除成功，目前目前链表为空&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除失败!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Del_SSL(thisList,i))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除成功，目前静态链表共有%d个元素，分别为:&quot;</span>,ListLength(thisList));</span><br><span class="line">Print_SSL(thisList);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除失败!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除失败，当前链表为空！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (thisList[MAXSIZE<span class="number">-1</span>].cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;目前线性表元素为:&quot;</span>);</span><br><span class="line">Print_SSL(thisList);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;链表为空! \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="built_in">exit</span> = ERR;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Goodbye~\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入错误请按标号重新输入！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 线性表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云服务器部署个人网盘服务</title>
      <link href="/archives/fb8823a1.html"/>
      <url>/archives/fb8823a1.html</url>
      
        <content type="html"><![CDATA[<h1 id="阿里云服务器部署个人网盘服务"><a href="#阿里云服务器部署个人网盘服务" class="headerlink" title="阿里云服务器部署个人网盘服务"></a>阿里云服务器部署个人网盘服务</h1><blockquote><p>相关资源：<br>kiftd ： <a href="https://github.com/KOHGYLW/kiftd">https://github.com/KOHGYLW/kiftd</a></p></blockquote><h2 id="1-安装JAVA运行环境"><a href="#1-安装JAVA运行环境" class="headerlink" title="1.安装JAVA运行环境"></a>1.安装JAVA运行环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install java-11-openjdk-devel</span><br></pre></td></tr></table></figure><p>安装完成后查看版本，输出下面内容说明已经安装好。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@nafxali ~]<span class="comment"># java -version</span></span><br><span class="line">openjdk version <span class="string">&quot;11.0.9.1&quot;</span> 2020-11-04 LTS</span><br><span class="line">OpenJDK Runtime Environment 18.9 (build 11.0.9.1+1-LTS)</span><br><span class="line">OpenJDK 64-Bit Server VM 18.9 (build 11.0.9.1+1-LTS, mixed mode, sharing)</span><br></pre></td></tr></table></figure><p>CentOS 8还支持无头版本的OpenJDK，该版本提供了无需图形用户界面（不支持键盘，鼠标和显示系统）来执行应用程序所需的最少Java运行时，该版本具有更少的依赖性和更少的系统资源，因此它更适合于服务器应用程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install java-11-openjdk-headless</span><br></pre></td></tr></table></figure><h2 id="2-下载kiftd包并解压"><a href="#2-下载kiftd包并解压" class="headerlink" title="2.下载kiftd包并解压"></a>2.下载kiftd包并解压</h2><p>Linux压缩包：<a href="https://cloud.189.cn/t/ruIr2eyeyUVb">https://cloud.189.cn/t/ruIr2eyeyUVb</a> (访问码:v5pj)<br>下载压缩包并上传到服务器，在具备rwx权限且不含中文的文件夹中解压，即可以用命令直接启动kiftd服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar kiftd-x.x.x-xxx.jar -console </span><br></pre></td></tr></table></figure><h2 id="3-后台运行kiftd"><a href="#3-后台运行kiftd" class="headerlink" title="3.后台运行kiftd"></a>3.后台运行kiftd</h2><h3 id="Screen-工具"><a href="#Screen-工具" class="headerlink" title="Screen 工具"></a>Screen 工具</h3><p>Screen 工具能够虚拟出一个终端并执行相应的操作。使用前，您需要先安装<br>该工具，例如在 Ubnutu 系统中，您可以使用以下命令进行安装： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install screen </span><br></pre></td></tr></table></figure><p>该工具安装完成后，您便可以使用它来运行 kiftd:  </p><h4 id="1-创建一个虚拟终端："><a href="#1-创建一个虚拟终端：" class="headerlink" title="1.创建一个虚拟终端："></a>1.创建一个虚拟终端：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S &#123;自定义的虚拟终端名称&#125; </span><br></pre></td></tr></table></figure><p>例如： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S kiftd </span><br></pre></td></tr></table></figure><h4 id="2-在虚拟终端中以命令模式启动-kiftd："><a href="#2-在虚拟终端中以命令模式启动-kiftd：" class="headerlink" title="2.在虚拟终端中以命令模式启动 kiftd："></a>2.在虚拟终端中以命令模式启动 kiftd：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar kiftd-x.x.x-xxx.jar -console </span><br></pre></td></tr></table></figure><p>之后您便可以断开 SSH 连接或者使用 Ctrl+A Ctrl+D 键暂时退出虚拟终端以进行其他操作。</p><h4 id="3，当您需要继续操作-kiftd-时："><a href="#3，当您需要继续操作-kiftd-时：" class="headerlink" title="3，当您需要继续操作 kiftd 时："></a>3，当您需要继续操作 kiftd 时：</h4><p>请使用 SSH 重新链接至远程服务器，之后使用虚拟终端名重新回到 screen虚拟终端： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -r &#123;自定义的虚拟终端名称&#125; </span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -r kiftd </span><br></pre></td></tr></table></figure><p>这样您便能返回之前的虚拟终端并继续操作 kiftd。</p><h2 id="4-开放端口"><a href="#4-开放端口" class="headerlink" title="4.开放端口"></a>4.开放端口</h2><h3 id="服务器防火墙开放端口"><a href="#服务器防火墙开放端口" class="headerlink" title="服务器防火墙开放端口"></a>服务器防火墙开放端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">查看防火墙某个端口是否开放</span><br><span class="line">firewall-cmd --query-port=3306/tcp</span><br><span class="line">开放防火墙端口3306</span><br><span class="line">firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class="line">注意：开放端口后要重启防火墙生效</span><br><span class="line">重启防火墙</span><br><span class="line">systemctl restart firewalld</span><br><span class="line">关闭防火墙端口</span><br><span class="line">firewall-cmd --remove-port=3306/tcp --permanent</span><br><span class="line">查看防火墙状态</span><br><span class="line">systemctl status firewalld</span><br><span class="line">关闭防火墙</span><br><span class="line">systemctl stop firewalld</span><br><span class="line">打开防火墙</span><br><span class="line">systemctl start firewalld</span><br><span class="line">开放一段端口</span><br><span class="line">firewall-cmd --zone=public --add-port=40000-45000/tcp --permanent</span><br><span class="line">查看开放的端口列表</span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line">查看被监听(Listen)的端口</span><br><span class="line">netstat -lntp</span><br><span class="line">检查端口被哪个进程占用</span><br><span class="line">netstat -lnp|grep 3306</span><br></pre></td></tr></table></figure><h3 id="阿里云开放端口"><a href="#阿里云开放端口" class="headerlink" title="阿里云开放端口"></a>阿里云开放端口</h3><p>实例=&gt;安全组=&gt;手动添加</p>]]></content>
      
      
      <categories>
          
          <category> LINUX </category>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPC-610E(电子组件的可接受性)</title>
      <link href="/archives/b3c014a2.html"/>
      <url>/archives/b3c014a2.html</url>
      
        <content type="html"><![CDATA[<h1 id="IPC-610E（电子组件的可接受性）"><a href="#IPC-610E（电子组件的可接受性）" class="headerlink" title="IPC-610E（电子组件的可接受性）"></a>IPC-610E（电子组件的可接受性）</h1><h2 id="IPC简介"><a href="#IPC简介" class="headerlink" title="IPC简介"></a>IPC简介</h2><p>&emsp;&emsp;IPC最初为“The Institute of Printed Circuit”的缩写，即美国“印制电路板协会”，后改名为“The Institute of the Interconnecting and Packing Electronic Circuit”(电子电路互连与封装协会)，1999年再次更名为“Associatation Of Connecting Electronics Industries”(电子制造业协会”)。由于IPC知名度很高，所以更名后，IPC的标记和缩写仍然没有改变。IPC拥有两千六百多个协会成员，包括世界著名的从事印制电路板设计、制造、组装、OEM（Original equipment manufacturer 即原始设备制造商）加工、EMS（electronics manufacture service 即电子制造服务）外包的大公司，IPC与IEC、ISO、IEEE、JEDC一样，是美国乃至全球电子制造业最有影响力的组织之一。 </p><p>&emsp;&emsp;IPC-A-610是国际上电子制造业界普遍公认的可作为国际通行的质量检验标准。IPC-A-610收集了有关电子组件的外观质量可接受要求，规定了怎样把元器件合格地组装到电路板上，对每种级别的标准都提供了可测量的元器件位置和焊点尺寸，并提供合格焊点的相应技术指标。</p><h2 id="IPC-A-610E电子产品等级"><a href="#IPC-A-610E电子产品等级" class="headerlink" title="IPC-A-610E电子产品等级"></a>IPC-A-610E电子产品等级</h2><ol><li>1级-普通类电⼦子产品<br>包括那些对外观要求不高而以其组装功能完整为主要要求的产品。（如玩具、计算器等）</li><li>2级-专⽤用服务类电⼦子产品<br>包括那些要求持续运行和较长使用寿命的产品，最好能保持不间断工作但该要求不严格。一般情况下不会因使用环境而导致故障。（如通讯设备等）</li><li>3级-⾼高性能电⼦子产品<br>包括以连续具有高性能或严格按指令运行为关键的产品。这类产品的服务间断是不可接受的，且最终产品使用环境异常苛刻；有要求时产品必须能够正常运行，例如救生设备或飞行控制系统等其他关键系统。</li></ol><h2 id="IPC-A-610E-验收条件"><a href="#IPC-A-610E-验收条件" class="headerlink" title="IPC-A-610E 验收条件"></a>IPC-A-610E 验收条件</h2><p>&emsp;&emsp;当合同要求使用IPC-A-610，本标准中所有适用的要求应当被实施于所有适用的分包合同中。如无，按以下优先次序执行：</p><ul><li>用户与制造商之间达成的采购文件。</li><li>反映用户具体要求的总图或总装图。</li><li>用户引用或合同协议引用IPC-A-610。<br>当其他文件同时与IPC-A-610被引用时，应当在采购文件中规定其优先顺序。  </li></ul><p><strong>四级验收条件：</strong></p><ul><li><p>目标条件<br>&emsp;&emsp;是指近乎完美/首选的情形，然而这是一种理想而非总能达到的情形，且对于保证组件在使用环境下的可靠性并非必要的情形。</p></li><li><p>可接受条件<br>&emsp;&emsp;是指组件不必完美但要在使用环境下保持完整性和可靠性的特征。</p></li><li><p>缺陷条件<br>&emsp;&emsp;缺陷是指组件在其最终使用环境下不足以确保外形、装配和功能（3F）的情况。缺陷情况应当由制造商根据设计、服务和客户要求进行处置（处置：决定缺陷应该作何种处理)。处置可以是返工、维修、报废或照样使用，但不限于以上处理方式。其中维修或“照样使用”必须取得客户的认可。<br>★1级缺陷自动成为2级和3级缺陷。2级缺陷意味着对3级也是缺陷。</p></li><li><p>制程警示条件<br>&emsp;&emsp;制程警示（非缺陷）是指没有影响到产品的外形、装配和功能（3F）的情况。且对于保证组件在使用环境下的可靠性并非必要的情形。这种情况是由于材料、设计或操作人员/机器设备等相关因素引起的，既不能完全满足可接受条件又非缺陷。应该将制程警示纳入过程控制系统而对其实行监控。当制程警示的数量表明制程发生变异或朝着不理想的趋势变化时，则应该对工艺进行分析。结果可能要求采取措施以降低制程变异程度并提高产量。不要求对单一性制程警示进行处置。</p></li></ul><h2 id="专业名词解释"><a href="#专业名词解释" class="headerlink" title="专业名词解释"></a>专业名词解释</h2><ul><li>主面<br>总设计图上定义的封装与互连结构(PCB)面。（通常为包含最复杂或数量最多的元器件那一面。该面在通孔插装技术中有时又称作元器件面或焊接终止面）。</li><li>辅面<br>与主面相对的封装与互连结构（PCB）面。（在通孔插装技术中有时称作焊接面或焊接起始面）</li><li>焊接起始面<br>焊接起始面是指印制电路板上施加焊料的那一面。采用波峰焊、浸焊或拖焊时，通常又是PCB的辅面。采用手工焊接时，焊接起始面也可能是PCB的主面。</li><li>焊接终止面<br>焊接终止面是指通孔插装中PCB上焊料流向的那一面，采用波峰焊、浸焊或拖焊时，通常又是PCB的主面。采用手工焊接时，焊接终止面也可能是PCB的辅面。</li><li>冷焊接连接<br>是指呈现很差的润湿性、外表灰暗、疏松的焊接连接。（这种现象是由于焊料中杂质过多，焊接前清洁不充分，和/或焊接过程中热量不足所致。）</li><li>浸析<br>指焊接过程中金属基材或涂覆层的流失或去除。</li><li>照明<br>对被检查的部件应当有足够的照明。工作台表面的照明至少应该达到1000 lm/m2[约93英尺烛光]。应该选择不会产生阴影的光源。<br>注：选择光源时，色温是一个需要考虑的重要因素。色温在3000-5000o K范围的光源，清晰度会逐步增加，使用户能够鉴别出印制电路板组<br>件的各种特征和污染物。</li></ul><h2 id="焊接可接受性要求"><a href="#焊接可接受性要求" class="headerlink" title="焊接可接受性要求"></a>焊接可接受性要求</h2><h3 id="目标-1-2-3级"><a href="#目标-1-2-3级" class="headerlink" title="目标-1,2,3级"></a>目标-1,2,3级</h3><ul><li>焊料填充基本平滑，对连接的零部件呈现良好润湿。</li><li>零部件的轮廓容易分辨。</li><li>焊料在被连接部件上形成羽毛状边缘。</li><li>填充呈凹面状。<h3 id="可接受-1-2-3级"><a href="#可接受-1-2-3级" class="headerlink" title="可接受-1,2,3级"></a>可接受-1,2,3级</h3></li><li>有些材料和工艺，例如：无铅合金、大热容PCB引起的慢冷却，可能导致干枯粗糙、灰暗、或颗粒状这种与材料和工艺相关的焊料外观，属正常现象。这样的焊接连接是可接受的。</li><li>焊接连接润湿角（焊料与元器件之间和焊料与焊盘之间）不超过90o （图5-1的A和B）。–例外的情况是当焊料轮廓延伸到可焊端边缘或阻焊膜时，润湿角可以超过90o（图5-1的C和D）</li><li>典型的锡铅焊点特征：光亮 平滑  凹形表面  轮廓清晰</li></ul><blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> IPC-610E </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IPC-610E </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环境温湿度监控系统（51+DHT11+1602液晶）</title>
      <link href="/archives/3003c9dd.html"/>
      <url>/archives/3003c9dd.html</url>
      
        <content type="html"><![CDATA[<h1 id="环境温湿度监控系统（51-DHT11-1602液晶）"><a href="#环境温湿度监控系统（51-DHT11-1602液晶）" class="headerlink" title="环境温湿度监控系统（51+DHT11+1602液晶）"></a>环境温湿度监控系统（51+DHT11+1602液晶）</h1><div class="note info flat"><p>使用模块：<br>DHT11 Datasheet: <a href="https://www.alldatasheetcn.com/datasheet-pdf/pdf/1132088/ETC2/DHT11.html">https://www.alldatasheetcn.com/datasheet-pdf/pdf/1132088/ETC2/DHT11.html</a><br>SMC1602 Datasheet: <a href="https://www.alldatasheetcn.com/datasheet-pdf/pdf/106031/ETC/SMC1602A.html">https://www.alldatasheetcn.com/datasheet-pdf/pdf/106031/ETC/SMC1602A.html</a><br>89C52 Datasheet: <a href="https://www.alldatasheet.com/datasheet-pdf/pdf/240685/ATMEL/AT89C52.html">https://www.alldatasheet.com/datasheet-pdf/pdf/240685/ATMEL/AT89C52.html</a></p></div><h2 id="一-原理图"><a href="#一-原理图" class="headerlink" title="一.原理图"></a>一.原理图</h2><p><img src="https://s2.loli.net/2022/07/10/udMPwKBETUZiQNR.png" alt="Schematic"></p><h2 id="二-1602显示模块"><a href="#二-1602显示模块" class="headerlink" title="二.1602显示模块"></a>二.1602显示模块</h2><p>模块头文件：引脚定义，接口定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _1602_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _1602_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_Bus P2 <span class="comment">//LCD1602数据总线</span></span></span><br><span class="line">sbit RS = P0^<span class="number">7</span>;<span class="comment">// LCD数据/命令选择端</span></span><br><span class="line">sbit RW = P0^<span class="number">6</span>;<span class="comment">// LCD读写选择端</span></span><br><span class="line">sbit EN = P0^<span class="number">5</span>;<span class="comment">// LCD使能端，高脉冲有效</span></span><br><span class="line"></span><br><span class="line">sbit busy_led1 = P1^<span class="number">0</span>; <span class="comment">//LCD忙指示灯</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Lcd_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;                    <span class="comment">//1602初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Lcd_WriteData</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> Data)</span></span>; <span class="comment">//写数据</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Lcd_WriteCmd</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> Cmd)</span></span>; <span class="comment">//写指令</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Lcd_WriteStr</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *Str)</span></span>; <span class="comment">//写一串字符串</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>函数实现见<a href="https://github.com/Nafoaix/DHT11-1602.git"><code>GIT仓库</code></a>或参考<a href="https://www.alldatasheetcn.com/datasheet-pdf/pdf/106031/ETC/SMC1602A.html"><code>SMC1602 Datasheet</code></a>编写。</p><h2 id="三-DHT11模块"><a href="#三-DHT11模块" class="headerlink" title="三.DHT11模块"></a>三.DHT11模块</h2><p>模块头文件：引脚定义，接口定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _DHT11_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DHT11_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrins.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit DHT11_Data = P0^<span class="number">4</span>;   <span class="comment">//dht11数据端口</span></span><br><span class="line"></span><br><span class="line">sbit NOresponse_led2 = P1^<span class="number">1</span>;</span><br><span class="line">sbit start_led3 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ERRORREVISE_LED4 = P1^<span class="number">3</span>;</span><br><span class="line">sbit test_led5 = P1^<span class="number">4</span>;</span><br><span class="line">sbit ASK_LED6 = P1^<span class="number">5</span>;</span><br><span class="line">sbit rec_byte_led7 = P1^<span class="number">6</span>;</span><br><span class="line">sbit rec_40_led8 = P1^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DHT11 测量范围 20~90%RH(5%RH) 0~50C(2C) 工作电压3~ 5.5V*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> rec_dat[<span class="number">16</span>];<span class="comment">//全局变量 用于显示的接收数据数组             </span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> RH,TH;</span><br><span class="line"><span class="comment">//extern void DHT11_delay_us(unsigned char us); //11.0592大概每次循环延时4.3us</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">DHT11_delay_ms</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> ms)</span></span>;  <span class="comment">//ms延时</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">DHT11_rec_40</span><span class="params">(<span class="keyword">void</span>)</span></span>;   <span class="comment">//接收40位全部数据</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>函数实现见<a href="https://github.com/Nafoaix/DHT11-1602.git"><code>GIT仓库</code></a>或参考<a href="https://www.alldatasheetcn.com/datasheet-pdf/pdf/1132088/ETC2/DHT11.html"><code>DHT11 Datasheet</code></a>编写。</p><h2 id="四-功能模块"><a href="#四-功能模块" class="headerlink" title="四.功能模块"></a>四.功能模块</h2><p>主函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;1602.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;DHT11.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar unsigned char</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="comment">/*------------按键引脚---------------*/</span></span><br><span class="line">sbit ok_SW1 = P3^<span class="number">5</span>; <span class="comment">//确定-SW1</span></span><br><span class="line">sbit add_SW2 = P3^<span class="number">4</span>;<span class="comment">//增加-SW2</span></span><br><span class="line">sbit sub_SW3 = P3^<span class="number">3</span>;<span class="comment">//减少-SW3</span></span><br><span class="line">sbit sw_SW4 = P3^<span class="number">2</span>; <span class="comment">//选择-SW4</span></span><br><span class="line"><span class="comment">/*------------蜂鸣器引脚---------------*/</span></span><br><span class="line">sbit bell = P3^<span class="number">6</span>;</span><br><span class="line"><span class="comment">/*------------变量声明---------------*/</span></span><br><span class="line">uchar HTemp,LTemp,HRH,LRH,<span class="built_in">set</span>;</span><br><span class="line"><span class="comment">/*------------函数声明---------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">Key_Scan</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_Alarm_Timer0</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uchar i;   <span class="comment">//rec_dat[]数组显示用</span></span><br><span class="line">DHT11_delay_ms(<span class="number">1500</span>);   <span class="comment">//DHT11上电后要等待1S以越过不稳定状态在此期间不能发送任何指令</span></span><br><span class="line">DHT11_rec_40();</span><br><span class="line">Lcd_Init();<span class="comment">//Lcd初始化</span></span><br><span class="line">HTemp=<span class="number">35</span>,LTemp=<span class="number">15</span>;HRH=<span class="number">80</span>,LRH=<span class="number">20</span>;<span class="built_in">set</span>=<span class="number">2</span>;</span><br><span class="line">Init_Alarm_Timer0();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span>(<span class="built_in">set</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;Press S1 to set &quot;</span>);</span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span> + <span class="number">0x40</span>);<span class="comment">//设置数据指针到第二行首</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)&#123;Lcd_WriteData(rec_dat[i]);&#125;   <span class="comment">//显示数据 </span></span><br><span class="line"><span class="keyword">if</span>(Key_Scan() == <span class="number">1</span>) &#123;<span class="built_in">set</span> = <span class="number">2</span>;&#125;</span><br><span class="line">                DHT11_delay_ms(<span class="number">2500</span>);</span><br><span class="line">DHT11_rec_40();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;Set the max RH  &quot;</span>);</span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span> + <span class="number">0x40</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;Maximum RH: &quot;</span>);</span><br><span class="line">Lcd_WriteData(<span class="string">&#x27;0&#x27;</span>+(HRH/<span class="number">10</span>));</span><br><span class="line">Lcd_WriteData(<span class="string">&#x27;0&#x27;</span>+(HRH%<span class="number">10</span>));</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;%  &quot;</span>);</span><br><span class="line"><span class="keyword">switch</span>(Key_Scan())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">set</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">HRH+=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">HRH-=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;Set the min RH  &quot;</span>);</span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span> + <span class="number">0x40</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;Minimum RH: &quot;</span>);</span><br><span class="line">Lcd_WriteData(<span class="string">&#x27;0&#x27;</span>+(LRH/<span class="number">10</span>));</span><br><span class="line">Lcd_WriteData(<span class="string">&#x27;0&#x27;</span>+(LRH%<span class="number">10</span>));</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;%  &quot;</span>);</span><br><span class="line"><span class="keyword">switch</span>(Key_Scan())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">set</span> = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">LRH+=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">LRH-=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;Set the max Temp &quot;</span>);</span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span> + <span class="number">0x40</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;Max Temp:  &quot;</span>);</span><br><span class="line">Lcd_WriteData(<span class="string">&#x27;0&#x27;</span>+(HTemp/<span class="number">10</span>));</span><br><span class="line">Lcd_WriteData(<span class="string">&#x27;0&#x27;</span>+(HTemp%<span class="number">10</span>));</span><br><span class="line">Lcd_WriteData(<span class="string">&#x27;0&#x27;</span>+<span class="number">175</span>); </span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;C   &quot;</span>);</span><br><span class="line"><span class="keyword">switch</span>(Key_Scan())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">set</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">HTemp+=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">HTemp-=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;Set the min Temp &quot;</span>);</span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span> + <span class="number">0x40</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;Min Temp:  &quot;</span>);</span><br><span class="line">Lcd_WriteData(<span class="string">&#x27;0&#x27;</span>+(LTemp/<span class="number">10</span>));</span><br><span class="line">Lcd_WriteData(<span class="string">&#x27;0&#x27;</span>+(LTemp%<span class="number">10</span>));</span><br><span class="line">Lcd_WriteData(<span class="string">&#x27;0&#x27;</span>+<span class="number">175</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;C   &quot;</span>);</span><br><span class="line"><span class="keyword">switch</span>(Key_Scan())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">set</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">LTemp+=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">LTemp-=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>: </span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;Over Temp alarm &quot;</span>);</span><br><span class="line">bell = ~bell;</span><br><span class="line"><span class="keyword">if</span>(Key_Scan()) &#123; <span class="built_in">set</span> = <span class="number">4</span>; &#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>: </span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;Over RH alarm   &quot;</span>);</span><br><span class="line">bell = ~bell;</span><br><span class="line"><span class="keyword">if</span>(Key_Scan()) &#123; <span class="built_in">set</span> = <span class="number">2</span>; &#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span> :</span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;ERROR 101       &quot;</span>);</span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span> + <span class="number">0x40</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;UNKNOW SET VALUE&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(Key_Scan()) &#123; <span class="built_in">set</span> = <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_Alarm_Timer0</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TMOD |= <span class="number">0x01</span>;  <span class="comment">//使用工作模式1，16位定时器，使用&quot;|&quot;或等符号可以在使用多个定时器时不受影响     </span></span><br><span class="line">TH0 = (<span class="number">65535</span><span class="number">-46082</span>) / <span class="number">256</span>;<span class="comment">//给定初值50ms</span></span><br><span class="line">TL0 = (<span class="number">65535</span><span class="number">-46082</span>) % <span class="number">256</span>;</span><br><span class="line">EA=<span class="number">1</span>;             <span class="comment">//打开总中断</span></span><br><span class="line">ET0=<span class="number">1</span>;            <span class="comment">//定时器中断打开 T0的溢出中断允许位</span></span><br><span class="line">TR0 = <span class="number">1</span>;  <span class="comment">//打开定时器开关</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer0_Alarm</span><span class="params">(<span class="keyword">void</span>)</span> interrupt 1</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TH0 = (<span class="number">65535</span><span class="number">-46082</span>) / <span class="number">256</span>;<span class="comment">//重设初值</span></span><br><span class="line">TL0 = (<span class="number">65535</span><span class="number">-46082</span>) % <span class="number">256</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">set</span> == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(TH&lt;LTemp||TH&gt;HTemp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">set</span> = <span class="number">6</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(RH&lt;LRH||RH&gt;HRH)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">set</span> = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">Key_Scan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> keyValue = <span class="number">0</span> , i; <span class="comment">//保存键值</span></span><br><span class="line">    <span class="comment">//--检测按键SW1--//</span></span><br><span class="line">    <span class="keyword">if</span> (ok_SW1 != <span class="number">1</span>)<span class="comment">//检测按键&#x27;确定-SW1&#x27;是否按下 按键被按下VCC上拉电阻接地，输入线线路电压0V</span></span><br><span class="line">    &#123;</span><br><span class="line">    DHT11_delay_ms(<span class="number">10</span>);<span class="comment">//消除抖动</span></span><br><span class="line">        <span class="keyword">if</span> (ok_SW1 != <span class="number">1</span>)<span class="comment">//再次检测按键是否按下</span></span><br><span class="line">        &#123;</span><br><span class="line">            keyValue = <span class="number">1</span>;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((i&lt;<span class="number">50</span>) &amp;&amp; (ok_SW1 != <span class="number">1</span>)) <span class="comment">//检测按键是否松开</span></span><br><span class="line">            &#123;</span><br><span class="line">                DHT11_delay_ms(<span class="number">10</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//--检测按键SW2--//</span></span><br><span class="line">    <span class="keyword">if</span> (add_SW2 != <span class="number">1</span>)<span class="comment">//检测&#x27;增加-SW2&#x27;是否按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        DHT11_delay_ms(<span class="number">10</span>);<span class="comment">//消除抖动</span></span><br><span class="line">        <span class="keyword">if</span> (add_SW2!= <span class="number">1</span>)<span class="comment">//再次检测按键是否按下</span></span><br><span class="line">        &#123;</span><br><span class="line">            keyValue = <span class="number">2</span>;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((i&lt;<span class="number">50</span>) &amp;&amp; (add_SW2 != <span class="number">1</span>)) <span class="comment">//检测按键是否松开</span></span><br><span class="line">            &#123;</span><br><span class="line">                DHT11_delay_ms(<span class="number">10</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//--检测按键SW3--//</span></span><br><span class="line">    <span class="keyword">if</span> (sub_SW3 != <span class="number">1</span>)<span class="comment">//检测&#x27;减少-SW3&#x27;是否按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        DHT11_delay_ms(<span class="number">10</span>);<span class="comment">//消除抖动</span></span><br><span class="line">        <span class="keyword">if</span> (sub_SW3 != <span class="number">1</span>)<span class="comment">//再次检测按键是否按下</span></span><br><span class="line">        &#123;</span><br><span class="line">            keyValue = <span class="number">3</span>;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((i&lt;<span class="number">50</span>) &amp;&amp; (sub_SW3 != <span class="number">1</span>)) <span class="comment">//检测按键是否松开</span></span><br><span class="line">            &#123;</span><br><span class="line">                DHT11_delay_ms(<span class="number">10</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//--检测按键SW4--//</span></span><br><span class="line">    <span class="keyword">if</span> (sw_SW4 != <span class="number">1</span>)<span class="comment">//检测&#x27;选择-SW4&#x27;是否按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        DHT11_delay_ms(<span class="number">10</span>);<span class="comment">//消除抖动</span></span><br><span class="line">        <span class="keyword">if</span> (sw_SW4!= <span class="number">1</span>)<span class="comment">//再次检测按键是否按下</span></span><br><span class="line">        &#123;</span><br><span class="line">            keyValue = <span class="number">4</span>;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((i&lt;<span class="number">50</span>) &amp;&amp; (sw_SW4 != <span class="number">1</span>)) <span class="comment">//检测按键是否松开</span></span><br><span class="line">            &#123;</span><br><span class="line">                DHT11_delay_ms(<span class="number">10</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyValue;   <span class="comment">//将读取到键值的值返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tips:</p><p>nop指令的作用：<br>1）就是通过nop指令的填充（nop指令一个字节），使指令按字对齐，从而减少取指令时的内存访问次数。（一般用来内存地址偶数对齐，比如有一条指令，占3字节，这时候使用nop指令，cpu 就可以从第四个字节处读取指令了。）<br>2）通过nop指令产生一定的延迟，但是对于快速的CPU来说效果不明显，可以使用rep前缀，多延迟几个时钟。<br>3）i/o传输时，也会用一下 nop，等待缓冲区清空，总线恢复；<br>4）清除由上一个算术逻辑指令设置的flag位；</p><p>该函数是在51单片机中用的延时函数，表示执行一条没有什么意义的指令，延时一个指令周期，有的指令周期是两个或两个以上的机械周期，但是_nop_();指令需要的只是一个机械周期也就是12个时钟周期（震荡周期）。<br>51单片机中，1个机械周期 = 12个时钟周期 = 12 * （ 1 / f）。（f 为晶振频率）。<br>如果只用的是12MHZ的晶振，那么 一个机械周期就是1us；也就是说：<br>nop(); 指令的延迟时间为 1us。可以较为精确得控制延迟时间。</p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
          <category> 51 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 51 </tag>
            
            <tag> 1602 </tag>
            
            <tag> DHT11 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在浏览器中输入 URL 回车之后发生了什么</title>
      <link href="/archives/c0d06efd.html"/>
      <url>/archives/c0d06efd.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>本文转自<a href="https://4ark.me//post/b6c7c0a2.html">4Ark</a><br>注意: 本文的步骤是建立在，请求的是一个简单的 HTTP 请求，没有 HTTPS、HTTP2、最简单的 DNS、没有代理、并且服务器没有任何问题的基础上，儘管这是不切实际的。</p></div><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><ol><li>URL 解析</li><li>DNS 查询</li><li>TCP 连接</li><li>处理请求</li><li>接受响应</li><li>渲染页面</li></ol><h3 id="一、URL-解析"><a href="#一、URL-解析" class="headerlink" title="一、URL 解析"></a>一、URL 解析</h3><ul><li>地址解析<br>  首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。</li><li>HSTS（HTTP Strict Transport Security）<br>  由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面</li><li>其他操作<br>  浏览器还会进行一些额外的操作，比如安全检查、访问限制（之前国产浏览器限制 996.icu）。</li><li>检查缓存<br>  <img src="https://s2.loli.net/2022/08/15/KE3gktbnMwNuILy.png" alt="What_happens_when_you_type_an_URL_in_the_browser_and_press_enter"></li></ul><h3 id="二、DNS-查询"><a href="#二、DNS-查询" class="headerlink" title="二、DNS 查询"></a>二、DNS 查询</h3><p><strong>基本步骤</strong></p><p><img src="https://s2.loli.net/2022/07/10/iMvbQPoEr3ytf7e.png" alt="DNS查询"></p><ol><li><p>浏览器缓存<br>浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。</p></li><li><p>操作系统缓存<br>操作系统也有自己的 DNS 缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。</p></li><li><p>路由器缓存<br>路由器也有自己的缓存。</p></li><li><p>ISP DNS 缓存<br>ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。</p></li><li><p>根域名服务器查询<br>在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程：</p><p><img src="https://s2.loli.net/2022/07/10/VxvCpokuf8QqJsM.png" alt="DNS服务器查询"></p><blockquote><p>根域名服务器：<a href="https://zh.wikipedia.org/wiki/%E6%A0%B9%E7%B6%B2%E5%9F%9F%E5%90%8D%E7%A8%B1%E4%BC%BA%E6%9C%8D%E5%99%A8">维基百科</a></p></blockquote><p> <strong>需要注意的点</strong></p><ul><li>递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地 DNS 服务器的过程）</li><li>迭代方式，就是本地 DNS 服务器到根域名服务器查询的方式。</li><li>什么是 DNS 劫持</li><li>前端 dns-prefetch 优化</li></ul></li></ol><h3 id="三、TCP-连接"><a href="#三、TCP-连接" class="headerlink" title="三、TCP 连接"></a>三、TCP 连接</h3><p>TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装：</p><p><img src="https://s2.loli.net/2022/07/10/A9oSeLUd2yhXZzf.png" alt="TCPIP"></p><ol><li><p>应用层：发送 HTTP 请求<br>在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括：</p><blockquote><p>1.请求报头（Request Header）：请求方法、目标地址、遵循的协议等等<br>2.请求主体（其他参数）</p></blockquote></li><li><p>传输层：TCP 传输报文<br>传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。<br>在建立连接前，会先进行 TCP 三次握手。</p><blockquote><p>关于 TCP/IP 三次握手，网上已经有很多段子和图片生动地描述了。<br>相关知识点：<br>SYN 泛洪攻击</p></blockquote></li><li><p>网络层：IP 协议查询 Mac 地址<br>将数据段打包，并加入源及目标的 IP 地址，并且负责寻找传输路线。<br>判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。</p><blockquote><p>注意：在 OSI 参考模型中 ARP 协议位于链路层，但在 TCP/IP 中，它位于网络层。</p></blockquote></li><li><p>链路层：以太网协议</p></li></ol><h4 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h4><p>根据以太网协议将数据分为以“帧”为单位的数据包，每一帧分为两个部分：</p><ul><li>标头：数据包的发送者、接受者、数据类型</li><li>数据：数据包具体内容</li></ul><h4 id="Mac-地址"><a href="#Mac-地址" class="headerlink" title="Mac 地址"></a>Mac 地址</h4><p>以太网规定了连入网络的所有设备都必须具备“网卡”接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力。</p><h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><p>发送数据的方法很原始，直接把数据通过 ARP 协议，向本网络的所有机器发送，接收方根据标头信息与自身 Mac 地址比较，一致就接受，否则丢弃。</p><p>注意：接收方回应是单播。</p><blockquote><p>相关知识点：<br>ARP 攻击</p></blockquote><p><strong>服务器接受请求</strong><br>接受过程就是把以上步骤逆转过来，参见上图。</p><h3 id="四、服务器处理请求"><a href="#四、服务器处理请求" class="headerlink" title="四、服务器处理请求"></a>四、服务器处理请求</h3><p><strong>大致流程</strong><br><img src="https://s2.loli.net/2022/07/10/O7j852nt3zrFHay.png" alt="大致流程"></p><h4 id="HTTPD"><a href="#HTTPD" class="headerlink" title="HTTPD"></a>HTTPD</h4><p>最常见的 HTTPD 有 Linux 上常用的 Apache 和 Nginx，以及 Windows 上的 IIS。</p><p>它会监听得到的请求，然后开启一个子进程去处理这个请求。</p><h4 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h4><p>接受 TCP 报文后，会对连接进行处理，对 HTTP 协议进行解析（请求方法、域名、路径等），并且进行一些验证：</p><pre><code>验证是否配置虚拟主机验证虚拟主机是否接受此方法验证该用户可以使用该方法（根据 IP 地址、身份信息等）</code></pre><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>假如服务器配置了 HTTP 重定向，就会返回一个 301 永久重定向响应，浏览器就会根据响应，重新发送 HTTP 请求（重新执行上面的过程）。</p><blockquote><p>关于更多：<a href="https://www.cnblogs.com/workest/p/3891321.html">详见这篇文章</a></p></blockquote><h4 id="URL-重写"><a href="#URL-重写" class="headerlink" title="URL 重写"></a>URL 重写</h4><p>然后会查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js 文件等，则会直接把这个文件返回。</p><p>否则服务器会按照规则把请求重写到 一个 REST 风格的 URL 上。</p><p>然后根据动态语言的脚本，来决定调用什么类型的动态文件解释器来处理这个请求。</p><p>以 PHP 语言的 MVC 框架举例，它首先会初始化一些环境的参数，根据 URL 由上到下地去匹配路由，然后让路由所定义的方法去处理请求。</p><h3 id="五、浏览器接受响应"><a href="#五、浏览器接受响应" class="headerlink" title="五、浏览器接受响应"></a>五、浏览器接受响应</h3><p>浏览器接收到来自服务器的响应资源后，会对资源进行分析。<br>首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。<br>如果响应资源进行了压缩（比如 gzip），还需要进行解压。<br>然后，对响应资源做缓存。<br>接下来，根据响应资源里的 MIME 类型去解析响应内容（比如 HTML、Image 各有不同的解析方式）。</p><h3 id="六、渲染页面"><a href="#六、渲染页面" class="headerlink" title="六、渲染页面"></a>六、渲染页面</h3><h4 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h4><p><img src="https://s2.loli.net/2022/07/10/gU6cvTSnpYhWMIo.png" alt="浏览器内核"></p><p>不同的浏览器内核，渲染过程也不完全相同，但大致流程都差不多。</p><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p><img src="https://s2.loli.net/2022/08/15/ALvfIks9PJtleRG.png" alt="基本流程"></p><h4 id="1-HTML-解析"><a href="#1-HTML-解析" class="headerlink" title="1.HTML 解析"></a>1.HTML 解析</h4><p>首先要知道浏览器解析是从上往下一行一行地解析的。</p><p>解析的过程可以分为四个步骤：</p><ol><li><p>解码（encoding）<br>传输回来的其实都是一些二进制字节数据，浏览器需要根据文件指定编码（例如 UTF-8）转换成字符串，也就是 HTML 代码。</p></li><li><p>预解析（pre-parsing）<br>预解析做的事情是提前加载资源，减少处理时间，它会识别一些会请求资源的属性，比如 img 标签的 src 属性，并将这个请求加到请求队列中。</p></li><li><p>符号化（Tokenization）<br>符号化是词法分析的过程，将输入解析成符号，HTML 符号包括，开始标签、结束标签、属性名和属性值。<br>它通过一个状态机去识别符号的状态，比如遇到&lt;，&gt;状态都会产生变化。</p></li><li><p>构建树（tree construction）</p><blockquote><p>注意：符号化和构建树是并行操作的，也就是说只要解析到一个开始标签，就会创建一个 DOM 节点。</p></blockquote></li></ol><p>在上一步符号化中，解析器获得这些标记，然后以合适的方法创建 DOM 对象并把这些符号插入到 DOM 对象中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is an example Web page.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/10/sprnHj5wQLEGC62.png" alt="HTMLDOM"></p><p><strong>浏览器容错进制</strong><br>你从来没有在浏览器看过类似”语法无效”的错误，这是因为浏览器去纠正错误的语法，然后继续工作。</p><p><strong>事件</strong><br>当整个解析的过程完成以后，浏览器会通过 <code>DOMContentLoaded</code> 事件来通知 <code>DOM</code> 解析完成。</p><h4 id="2-CSS-解析"><a href="#2-CSS-解析" class="headerlink" title="2. CSS 解析"></a>2. CSS 解析</h4><p>一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 <code>CSS</code>，根据语法<a href="https://drafts.csswg.org/css-syntax-3/">规范解析</a>出所有的 <code>CSS</code> 并进行标记化，然后我们得到一个规则表。</p><p><strong>CSS 匹配规则</strong><br>在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如：<code>div p &#123; font-size :14px &#125;</code>会先寻找所有的<code>p</code>标签然后判断它的父元素是否为 <code>div</code>。</p><p>所以我们写 <code>CSS</code> 时，尽量用 <code>id</code> 和 <code>class</code>，千万不要过度层叠。</p><h4 id="3-渲染树"><a href="#3-渲染树" class="headerlink" title="3. 渲染树"></a>3. 渲染树</h4><p>其实这就是一个 <code>DOM</code> 树和 <code>CSS</code> 规则树合并的过程。</p><blockquote><p>注意：渲染树会忽略那些不需要渲染的节点，比如设置了<code>display:none</code>的节点。</p></blockquote><p><strong>计算</strong><br>通过计算让任何尺寸值都减少到三个可能之一：<code>auto</code>、百分比、<code>px</code>，比如把 <code>rem</code> 转化为 <code>px</code>。</p><p><strong>级联</strong><br>浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做 specificity 的公式，这个公式会通过：</p><pre><code>  1.  标签名、class、id  2.  是否内联样式  3.  !important</code></pre><p>然后得出一个权重值，取最高的那个。</p><p><strong>渲染阻塞</strong><br>当遇到一个 script 标签时，DOM 构建会被暂停，直至脚本完成执行，然后继续构建 DOM 树。<br>但如果 JS 依赖 CSS 样式，而它还没有被下载和构建时，浏览器就会延迟脚本执行，直至 CSS Rules 被构建。</p><p>所有我们知道：</p><pre><code>  - CSS 会阻塞 JS 执行  - JS 会阻塞后面的 DOM 解析</code></pre><p>为了避免这种情况，应该以下原则：</p><pre><code>- CSS 资源排在 JavaScript 资源前面- JS 放在 HTML 最底部，也就是 &lt;/body&gt;前</code></pre><p>另外，如果要改变阻塞模式，可以使用 defer 与 async，详见：<a href="https://github.com/xiaoyu2er/blog/issues/8">这篇文章</a></p><h4 id="4-布局与绘制"><a href="#4-布局与绘制" class="headerlink" title="4. 布局与绘制"></a>4. 布局与绘制</h4><p>确定渲染树种所有节点的几何属性，比如：位置、大小等等，最后输入一个盒子模型，它能精准地捕获到每个元素在屏幕内的准确位置与大小。</p><p>然后遍历渲染树，调用渲染器的 paint() 方法在屏幕上显示其内容。</p><h4 id="5-合并渲染层"><a href="#5-合并渲染层" class="headerlink" title="5. 合并渲染层"></a>5. 合并渲染层</h4><p>把以上绘制的所有图片合并，最终输出一张图片。</p><h4 id="6-回流与重绘"><a href="#6-回流与重绘" class="headerlink" title="6. 回流与重绘"></a>6. 回流与重绘</h4><p><strong>回流(reflow)</strong><br>当浏览器发现某个部分发现变化影响了布局时，需要倒回去重新渲染，会从 html 标签开始递归往下，重新计算位置和大小。<br>reflow 基本是无法避免的，因为当你滑动一下鼠标、resize 窗口，页面就会产生变化。</p><p><strong>重绘(repaint)</strong><br>改变了某个元素的背景色、文字颜色等等不会影响周围元素的位置变化时，就会发生重绘。<br>每次重绘后，浏览器还需要合并渲染层并输出到屏幕上。<br>回流的成本要比重绘高很多，所以我们应该尽量避免产生回流。<br>比如：<br>    - <code>display:none</code> 会触发回流，而 <code>visibility:hidden</code> 只会触发重绘。</p><h4 id="7-JavaScript-编译执行"><a href="#7-JavaScript-编译执行" class="headerlink" title="7. JavaScript 编译执行"></a>7. JavaScript 编译执行</h4><p><strong>大致流程</strong><br>可以分为三个阶段：<br><img src="https://s2.loli.net/2022/07/10/QwOgRlVY6BCoTpP.png" alt="JavaScript 编译执行流程"></p><h5 id="1-词法分析"><a href="#1-词法分析" class="headerlink" title="1. 词法分析"></a>1. 词法分析</h5><p>JS 脚本加载完毕后，会首先进入语法分析阶段，它首先会分析代码块的语法是否正确，不正确则抛出“语法错误”，停止执行。</p><p>几个步骤：</p><ul><li>分词，例如将 var a = 2，，分成 var、a、=、2 这样的词法单元。</li><li>解析，将词法单元转换成抽象语法树（AST）。</li><li>代码生成，将抽象语法树转换成机器指令。</li></ul><h5 id="2-预编译"><a href="#2-预编译" class="headerlink" title="2. 预编译"></a>2. 预编译</h5><p>JS 有三种运行环境：</p><ul><li>全局环境</li><li>函数环境</li><li>eval</li></ul><p>每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。</p><p><strong>创建执行上下文</strong><br>创建执行上下文的过程中，主要做了以下三件事：</p><ul><li>创建变量对象<pre><code>- 参数、函数、变量</code></pre></li><li>建立作用域链  <pre><code>- 确认当前执行环境是否能访问变量</code></pre></li><li>确定 This 指向</li></ul><h5 id="3-执行"><a href="#3-执行" class="headerlink" title="3. 执行"></a>3. 执行</h5><p><strong>JS 线程</strong><br><img src="https://s2.loli.net/2022/07/10/1bqEzQAecsky9gl.png" alt="JS 线程"><br>虽然 JS 是单线程的，但实际上参与工作的线程一共有四个：</p><blockquote><p>其中三个只是协助，只有 JS 引擎线程是真正执行的</p></blockquote><ul><li>JS 引擎线程：也叫 JS 内核，负责解析执行 JS 脚本程序的主线程，例如 V8 引擎</li><li>事件触发线程：属于浏览器内核线程，主要用于控制事件，例如鼠标、键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待 JS 引擎线程执行</li><li>定时器触发线程：主要控制setInterval和setTimeout，用来计时，计时完毕后，则把定时器的处理函数推进事件队列中，等待 JS 引擎线程。</li><li>HTTP 异步请求线程：通过XMLHttpRequest连接后，通过浏览器新开的一个线程，监控readyState状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待JS引擎线程执行。</li></ul><p><strong>注：浏览器对同一域名的并发连接数是有限的，通常为 6 个。</strong></p><p><strong>宏任务</strong><br>分为：</p><ul><li>同步任务：按照顺序执行，只有前一个任务完成后，才能执行后一个任务</li><li>异步任务：不直接执行，只有满足触发条件时，相关的线程将该异步任务推进任务队列中，等待JS引擎主线程上的任务执行完毕时才开始执行，例如异步Ajax、DOM事件，setTimeout等。</li></ul><p><strong>微任务</strong><br>微任务是 ES6 和 Node 环境下的，主要 API 有：<code>Promise</code>，<code>process.nextTick</code>。</p><p>微任务的执行在宏任务的同步任务之后，在异步任务之前。</p><p><img src="https://s2.loli.net/2022/07/10/7xCXGJQ6UW4mZYM.png" alt="微任务"></p><p>代码例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>); <span class="comment">// 宏任务 同步</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>); <span class="comment">// 宏任务 异步</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>); <span class="comment">// 宏任务 同步</span></span><br><span class="line">resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>) <span class="comment">// 微任务</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>) <span class="comment">// 宏任务 同步</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上代码输出顺序为：1,3,5,4,2</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://github.com/skyline75489/what-happens-when-zh_CN">what-happens-when-zh_CN</a></li><li><a href="https://alistapart.com/article/tags-to-dom/">Tags to DOM</a></li><li><a href="https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/">彻底理解浏览器的缓存机制</a></li><li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#The_rendering_engine">浏览器的工作原理：新式网络浏览器幕后揭秘</a></li><li><a href="https://blog.fundebug.com/2019/01/03/understand-browser-rendering/">深入浅出浏览器渲染原理</a></li><li><a href="https://heyingye.github.io/2018/03/19/js%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/#%E9%A2%84%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5">js 引擎的执行过程（一）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫学习笔记（一）</title>
      <link href="/archives/60acca91.html"/>
      <url>/archives/60acca91.html</url>
      
        <content type="html"><![CDATA[<p>Null</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盘点国外知名游戏厂商（一）CD Projekt</title>
      <link href="/archives/29f83498.html"/>
      <url>/archives/29f83498.html</url>
      
        <content type="html"><![CDATA[<h1 id="盘点国外知名游戏厂商（一）CD-Projekt"><a href="#盘点国外知名游戏厂商（一）CD-Projekt" class="headerlink" title="盘点国外知名游戏厂商（一）CD Projekt"></a>盘点国外知名游戏厂商（一）CD Projekt</h1><div class="note info flat"><p>本篇文章写于 2020 年 4 月，在赛博朋克 2077 漫长而又煎熬的等待之余我我决定以我<strong>个人视角</strong>盘点下那些带给我无数爱恨、惊喜与感动的游戏厂商们。文章资料同通过互联网搜集整理，如有错误还请指正，本文内容仅代表个人观点。</p></div><h2 id="CD-Projekt-RED"><a href="#CD-Projekt-RED" class="headerlink" title="CD Projekt RED"></a>CD Projekt RED</h2><p><img src="https://s2.loli.net/2022/07/10/z8pOxYoBUrTKXZC.jpg" alt="CDPR"></p><blockquote><p><a href="https://www.bilibili.com/video/av16789674/"><code>av16789674</code></a>《巫师 3》以及 CD Projekt 成功发展史-全 6 集游戏纪录片</p></blockquote><p>&emsp;&emsp;第一个就提到“波兰蠢驴”的原因<del>肯定不是馋 9 月即将登陆的《赛博朋克 2077》 的身子</del>，也不是《巫师》三部曲那出色的游戏质量，而是他们心中那份对玩家足够的诚意与对游戏的热爱，让我将其视作当代游戏界的绿洲。</p><p>&emsp;&emsp;CD Projekt Red（后面简称 CDPR） 是波兰电子游戏研发商 CD Projekt 下的游戏开发部门，我们还是先从 CD Projekt 旗下的数字发行平台 GOG.com 今年推出的<code>[30 天内退款政策]</code>说起吧。这个政策毫无疑问是将目前市面上的数字发行平台的退换政策戳出了一个大窟窿，本来 STEAM 平台的<code>[14 天 2 小时]</code>已经足够宽松了，但 CD Projekt 这番举措瞬间在全世界的游戏厂商、平台和玩家群体间炸开了锅，其实我觉得这本来就是“波兰蠢驴”玩家至上理念的一贯体现，在这先不论这是不是一次精心设计的 PR 行为，这一举措确实给玩家们带来了大量的利好，你可以有更大的余地选择更精良自己更喜欢的游戏。也有不少人担心目前的玩家群体还没形成完全自觉的良好氛围来从中恶意牟利，担心这项举措会导致大量 3A 游戏不选择在 GOG 上发售，确实“波兰蠢驴”自己这也是在赌，但是他们已经赌了太多次了，他们也甘愿为了给玩家们一个更好的游戏环境去赌不是吗？</p><p>&emsp;&emsp;1994 年在受历史等因素影响下，社会环境、经济环境动荡贫瘠的波兰，想要用电脑或是想玩被视为“资本主义的精神毒品”的游戏只能通过地下的集市，而这种本就灰色的地带也滋生了大量盗版游戏。作为 CD Projekt 的联合创始人马尔钦（Marcin Iwinski）和米卡（Michal Kicinski）深知在当时盗版如此猖獗环境之下，想要从头开发游戏赚钱是不现实的事，于是两人做起了波兰国内鲜有的游戏代理发行商业务。在卖游戏赚到了第一桶金之后他们并不满足于此，于是他们两个人加上一台电脑一间公寓的 CD Projekt 便注册成立了。公司成立后的第一件事便是与当时波兰国内盗版横行的游戏环境对抗，作为热爱游戏的二人，他们深知玩家们的需求，他们在 1996 年开始做游戏的本地化，将游戏翻译成波兰语投放到市场。恰逢 1998 年龙与地下城旷世神作《博德之门》发售，马尔钦坚信这款游戏能在波兰市场上获得成功，于是第一时间与 bioware 签订协议，当时的盗版游戏很少有翻译或翻译质量尚可的，CD Projekt 决定用本地化打败盗版势力让玩家心甘情愿地掏钱买正版。但是《博德之门》在当时作为一款优秀的作品有海量的文本和丰富的语音，本地化成本非常之高。CD Projekt 之前几年的利润都用在了海量的文本翻译、邀请顶级的配音演员进行出演、前所未有的大规模推广上，更是在光盘的基础之上送了一份火漆封缄的羊皮纸地图、一本厚实的龙与地下城规则手册以及一张原声 CD，这几乎耗尽了公司所有的积蓄，CD Projekt 的命运全赌在这款游戏上了。然而“波兰蠢驴”的这份良心让他们赢得了对盗版的战争，仅发售当日就卖出了 18000 套游戏，这次的成功更是加深了他们对于玩家至上的理念，他们认为只要你做的足够好，玩家没理由不买你的正版产品。廉价的盗版可能并不足以成为失败的借口。</p><p><img src="https://s2.loli.net/2022/07/10/zpSxt7KqRrbD3V1.png" alt="CDPR"></p><p>&emsp;&emsp;这时开始他们决定自己开发游戏来贯彻自己的理念，这就有了现在的 CDPR（CD Projekt Red）工作室，成立之初 CDPR 是一个仅有 15 人的工作室，虽然从之前合作过的 Bioware 那里借到了引擎，但是这么小的团队甚至没有游戏开发流程经验的 CDPR 明显是没办法开发出他们要的作品的，为了他们心中那份对游戏的热爱他们花了近五年时间，一路扩充到 100 人的工作室，发售时间不断跳票,几乎耗尽了资金的“波兰蠢驴”将自己的命运赌在了《巫师 1》上，用马尔钦的话说，“那是我们所拥有的全部资金，还要再多些。”幸运的是《巫师 1》虽然有着游戏节奏过慢等的缺点，但终究瑕不掩瑜，及其出色的叙事，加上独特的战斗系统和当时在波兰国民级小说《猎魔人》IP 加成下，《巫师 1》取得了超 200 万的销量并大获好评，“波兰蠢驴”又赌赢了。由此受到了极大鼓励的 CDPR 马上立项了《巫师 2》，虽然有了前作的成功但后面的《巫师 2》也是历经挫折，由于雅达利 <em>(前面《巫师 1》研发使公司快要弹尽粮绝时 CDPR 与雅达利谈成协议获得了几万美元的投资但是发行权交给了雅达利)</em> 想要求把《巫师》移植到主机平台上，由于专心开发《巫师 2》CDPR 没有太多精力，于是将移植工作交给一个法国的开发商，最后这个主机移植项目在耗费了 CDPR 大量的资金后被取消了。</p><blockquote><p>马尔钦曾在媒体采访时抱怨称对方总是还要更多的钱、开发者、时间，以至于他们在对方身上花了几百万美元，比自己公司的支出还要高。</p></blockquote><p>&emsp;&emsp;恰逢 2008 年金融危机,他们还要偿还雅达利之前的巨额投资，导致公司又又濒临破产躺在了现实的断头台前，马尔钦为了解决财政危机，公司解散了一批子公司 <code>（这里面一部分员工组建了另一个公司——11bit 也就是后面推出《这是我的战争》《冰气时代》的工作室)</code> 公司人数从 350 减少到不到 200 人，,削减开支，削减《巫师 2》项目的内容，并对一家 IT 公司进行反向收购，借壳在华沙证券交易所上市。这些注入的资金使得 CDPR 可以专心制作《巫师 2》和自研引擎的开发<code>（之前从 Bioware 借到的 Aurora 引擎难以满足当时 PC 得的要求了，CDPR 在重写了引擎近 80%的代码后不得已放弃转而自研引擎）</code>，经过三年半的研发时间后，2011 年《巫师 2：国王刺客》正式发售第一年在 PC 就卖了 110 万套，而且由于自研引擎使得游戏更为方便的移植到当时的两大主机平台<code>（PS3、XBOX360）</code>。《巫师 2》和当年的“老滚 5”平分秋色，收获国际声誉的 CDPR 已然成为了波兰的骄傲，使政府开始极大重视并鼓励游戏行业的发展。甚至 2011 年奥巴马赴波兰进行国事访问时波兰总理将《巫师 2》作为国礼相赠。“波兰蠢驴”们为了回馈玩家对《巫师 2》的支持，在游戏正式发售一年后公布了《巫师 2》的增强版，除了在原版基础上进行了画质增强外，还加入了当初砍掉的那些内容，并将这些内容全部免费送给玩家。</p><p><img src="https://s2.loli.net/2022/07/10/g6ZcUIvp4DajGon.png" alt="CD Projekt RED"></p><p>&emsp;&emsp;后面发生的事相信大家都已经知道了，就是大家津津乐道的“波兰蠢驴”封神之作《巫师 3》了，三年半的开发时间，3.06 亿波兰兹罗提（8100 万美元）的开发成本，交出了一份他们满意的答卷，高达 92 的媒体平均分，以及 IGN <em>“《巫师 3：狂猎》提升到了一个其他许多 RPG 无法企及的高度”</em> 的评价，加上各种年度 RPG 奖项，足够说明《巫师 3》有多好了。就更不用说“波兰蠢驴”之后还追加了 16 个免费 DLC 和把两个新游戏《石之心》与《血与酒》当 DLC 卖有多良心了。<code>（《血与酒》更是获得了 TGA2016 最佳 RPG 游戏的奖项）</code>《巫师 3》让 CDPR 彻底的成为了世界级公司，能取得今天的成就可谓实至名归。<br>&emsp;&emsp;他们出于对游戏的热爱而投身游戏领域，尽管知道盗版猖獗但仍未向其妥协，习惯用用实实在在的品质和后续的服务让玩家心甘情愿的掏钱，这就是我们的“波兰蠢驴”。回到开头，这就不难理解为什么《赛博朋克 2077》开放预购一小时后就一举夺得 STEAM 销量榜的冠军，受无数游戏玩家期待。没有他们心中那份对玩家足够的诚意与对游戏的热爱，怎么会有 CDPR 数次把公司前途押上的豪赌？怎么会有诺维格瑞的万家灯火？怎么会有凯尔莫罕天空中略过的飞鸟？我们 2077 年的不夜城见！也希望 CDPR 能继续做我们心中的绿洲。</p><p><img src="https://s2.loli.net/2022/07/10/XHJ2eFjTBELMI9y.png" alt="Cyberpunk2077"><br><em>“波兰蠢驴”你们可千万别破产了呀！</em></p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记(一)-从本地库开始</title>
      <link href="/archives/3cb7cd1a.html"/>
      <url>/archives/3cb7cd1a.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-学习笔记-一"><a href="#Git-学习笔记-一" class="headerlink" title="Git 学习笔记(一)"></a>Git 学习笔记(一)</h1><div class="note info flat"><p>作为一个刚接触 Git 不久的小白，该笔记是这两天我在网上看视频和教程自己总结记录下来的，主要为了方便未来自己查阅和帮助像我一样的小白学习 Git。文章中斜体部分为我自己方便记忆的理解，如有错误还请指正，见谅！</p></div><h2 id="Git-的一点介绍"><a href="#Git-的一点介绍" class="headerlink" title="Git 的一点介绍"></a>Git 的一点介绍</h2><h3 id="Git-下载地址："><a href="#Git-下载地址：" class="headerlink" title="Git 下载地址："></a>Git 下载地址：</h3><p><code>https://git-scm.com/</code></p><h3 id="Git-是什么"><a href="#Git-是什么" class="headerlink" title="Git 是什么"></a>Git 是什么</h3><p>&emsp;百度百科的介绍是：</p><blockquote><p>Git 是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。</p></blockquote><p><em>可以理解为一个小秘书来帮你打理你的项目，让你专注于项目上，而不是被错综复杂的项目版本和文件弄晕。</em></p><h3 id="Git-记录的是什么"><a href="#Git-记录的是什么" class="headerlink" title="Git 记录的是什么"></a>Git 记录的是什么</h3><p>&emsp;集中式版本控制系统 SVN 记录的是每一次版本变动的内容，Git 则是将项目的每个版本独立保存。Git 通过维护 <strong>工作区域</strong> <strong>暂存区域</strong> <strong>Git 仓库</strong> 来实现版本控制。<em>你可以理解为三座在本地的仓库。</em></p><h3 id="Git-管理的文件的三种状态"><a href="#Git-管理的文件的三种状态" class="headerlink" title="Git 管理的文件的三种状态"></a>Git 管理的文件的三种状态</h3><ul><li>已修改（modified）</li><li>已暂存（staged）</li><li>已提交（committed）</li></ul><h2 id="Git-的使用流程"><a href="#Git-的使用流程" class="headerlink" title="Git 的使用流程"></a>Git 的使用流程</h2><h3 id="Git-初始化"><a href="#Git-初始化" class="headerlink" title="Git 初始化"></a>Git 初始化</h3><p>&emsp;和游戏或 APP 一样，下载完之后要在命令行或在 GitBash 中输入以下命令来注册个账号<br>&emsp; <code>git config --global user.name &quot;你随便起的ID&quot;</code><br>&emsp; <code>git config --global user.email &quot;你的邮箱&quot;</code><br>&emsp;使用时首先要在工作的文件夹初始化 Git，你可以在命令行中进入工作文件夹目录也可以以直接在文件夹右键选择 Git Bash Here 然后输入：<br>&emsp;<code>git init</code><br>&emsp;<em>这样就相当于你告诉了 git：“这个文件夹需要你帮我管理。”</em><br>&emsp;这里就成了这个项目的根目录，也就是<strong>工作区域</strong>。初始化完成后该目录下会多了一个<code>.git</code>的目录，这个目录就是 Git 用来跟踪管理版本库的，没事不要手动修改这个目录里的文件。（如果没看到也没关系，因为该目录默认是隐藏的。）</p><h3 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h3><ul><li><p>当你对项目进行一顿操作后可以使用<br><code>git add 文件名 ---就是将指定文件添加到暂存区</code><br><code>git add ./-A/--all/* ---可以提交工作区中所有的文件</code><br>将文件添加到<strong>暂存区</strong>，也就是上面提到三座仓库中的第二座，这个区域区如其名，只是临时保存你的改动。<br><em>可以理解为小秘书记在随身携带的临时笔记本上。</em></p></li><li><p>当你完成了某个改动、变更了某项设置、写完了一个章节就可以使用<br><code>git commit -m &quot;提交说明(你干了啥)&quot;</code><br>&emsp;将暂存区文件提交到 <strong>Git 仓库</strong>，也就是上面提到的本地的第三座仓库。就相当于你告诉秘书：<em>“这些你都帮我打印出来放到 <strong>Git 仓库</strong>存个档。”</em><br>&emsp;<em>提交说明就相当于一个档案上贴的小标签比如‘三年二班期末考试成绩’方便自己或别人查阅仓库中存档的档案</em></p><div class="note info no-icon flat"><p>修改最后一次提交:<br> 执行带 –amend 选项的 commit 提交命令 Git 就会更正最近的一次提交<br>git commit –amend<br>如果不希望修改:q!退出后包保留旧的说明</p></div></li></ul><h3 id="查看状态与提交历史"><a href="#查看状态与提交历史" class="headerlink" title="查看状态与提交历史"></a>查看状态与提交历史</h3><ul><li><code>git status</code>可以查看目前工作区和暂存区的状态。 <em>就相当于你把秘书叫过来核对下</em><br> 当你在工作区新增了某些文件后使用此命令秘书就会告诉你:<br><code>Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</code><br><em>“你放了个文件进来怎么都不和我说一声，快用 add 命令添加进仓库里。”</em>:</li></ul><p>&emsp;&emsp;当你在工作区删除或者更改了某些文件后使用此命令秘书就会告诉你:<br>&emsp;&emsp;<code>Changes not staged for commit:</code><br>&emsp;&emsp;<code>(use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</code><br>&emsp;&emsp;<code>(use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</code><br>&emsp;&emsp;_“你的工作区和我上次过来的时候不一样了，某某文件删掉了，某某文件变更了，你想确认更改或者删掉文件或者让我把这些文件按照 <strong>暂存区</strong> 恢复回来都可以。”_<br>&emsp;&emsp;你会注意到我上面说的，使用 <code>git restore file</code> 指令 git 小秘书是从<strong>暂存区</strong>来恢复文件的，如果需要从<strong>Git 仓库</strong>来恢复，小秘书需要去仓库查档案，而且你也需要告诉他是恢复成哪次存档的版本，也就是下面关于版本回退提到的<code>git reset</code>命令。</p><ul><li><code>git log</code> 可以查看 <strong>Git 仓库</strong> 的历史提交记录。记录中会显示你每次 commit 到 <strong>Git 仓库</strong> 的历史记录，包含每次提交的 id、提交人、日期、提交说明等信息。<div class="note info no-icon flat"><p>图形化显示快照<br>git log –decorate –oneline –graph –all<br>–graph 图形化显示<br>–all 显示所有快照</p></div></li></ul><h3 id="关于版本回退"><a href="#关于版本回退" class="headerlink" title="关于版本回退"></a>关于版本回退</h3><div class="note info no-icon flat"><pre><code>             -add-&gt;            -commit-&gt;</code></pre><p>WorkingDirectory —— Stage(Index) —— Repository(HEAD)<br>               &lt;-restore-          &lt;-reset-</p></div><ul><li><p>回滚指定快照<br><code>git reset 至少前5位的版本快照号</code></p></li><li><p>回滚个别文件<br><code>git reset 版本快照 文件名/路径</code></p></li><li><p><code>git reset HEAD~</code> 其中 <code>HEAD~</code>表示回滚到上个版本的快照,如果两个<code>~~</code>就表示回滚到上上个版本的快照,或写作 <code>git reset HEAD~2</code>往后同理， <em>你可以叫 Git 小秘书去<strong>Git 仓库</strong> 里查任意时候的档案</em></p></li></ul><p><em>一般情况下为了防止将你的工作区弄乱，你的小秘书一般都是将查到的档案记在她随身携带的笔记本（<strong>暂存区</strong>）上。</em><br>所以一般当你不设置<code>reset</code>指令的参数的时，Git 默认使用<code>--mixed</code>参数，如<code>git reset --mixed HEAD~</code><br><code>--mixed</code> 参数表示:</p><ol><li>移动 HEAD 的指向，将其指向上一个快照</li><li>将 HEAD 移动后指向的快照回滚到暂存区域</li></ol><p>与之相对的<code>reset</code>指令还有其他一些参数比如：</p><ul><li><code>git reset --soft HEAD~</code><br>–soft 参数表示 移动 HEAD 的指向将其指向上一个快照，并不会修改暂存区，也就相当于撤回上一次的提交。</li><li><code>git reset --hard HEAD~</code><br>–hard 参数表示:</li></ul><ol><li><p> 移动 HEAD 的指向，将其指向上一个快照</p></li><li><p> 将 HEAD 移动后指向的快照回滚到暂存区域</p></li><li><p> 将暂存区域的文件还原到工作目录 （会覆盖掉工作目录里最新的文件！！！）</p></li></ol><div class="note info no-icon flat"><p><code>reset</code> 指令不仅可以回滚还可以往前滚，如果上面使用了<code>reset</code>指令撤销了上次提交，这时<code>git log</code>是看不到前面版本的 ID 的，需要使用<code>git reflog</code>查看所有操作的日志。</p></div><h3 id="关于-diff-命令"><a href="#关于-diff-命令" class="headerlink" title="关于 diff 命令"></a>关于 diff 命令</h3><p>diff 顾名思义就是不同，使用<code>git diff</code>不加任何参数就是比较<strong>暂存区域</strong>和<strong>工作目录</strong>的差异。</p><ul><li><p>比较两个历史快照<br><code>git diff 快照ID1 快照ID2</code></p></li><li><p>比较当前工作目录和 GIt 仓库中的快照<br><code>git diff 快照ID</code></p></li><li><p>比较当前工作目录和 GIt 仓库中的快照<br><code>git diff 快照ID</code></p></li><li><p>比较最新的一份快照和当前工作目录<br><code>git diff HEAD</code></p></li><li><p>比较暂存区域和 Git 仓库快照<br><code>git diff --cached 快照 ID</code></p><div class="note info no-icon flat"><p>  显示的格式正是 Unix 通用的 diff 格式，查看常用如下键盘操作：</p><ul><li><p>移动命令<br>J 向下移一行 K 向上移一行<br>F 向下移一页 B 向上移一页<br>D 向下移半页 U 向上移半页</p></li><li><p>跳转命令<br>g 跳到第一行<br>G 跳到最后一行<br>num g 跳到第 num 行<br>num G 跳到倒数第 num 行</p></li><li><p>搜索命令<br>/ +关键词 从上往下搜索关键词<br>? +关键词 从下往上搜索关键词<br>n 跳转到下一个搜索结果</p></li><li><p>h 帮助文档</p></li><li><p>q 退出</p></li></ul></div></li></ul><h3 id="其他文件操作"><a href="#其他文件操作" class="headerlink" title="其他文件操作"></a>其他文件操作</h3><ul><li>删除文件<br><code>git rm 文件名</code>此命令会删除工作目录和暂存区域的文件，也就是取消跟踪，在下次提交时不纳入版本管理，不会删除在仓库快照里的文件。<blockquote><p>如果你工作区和暂存区有两个不同的文件 git 会不知道你删除哪个<br>使用-f 指令强制删除工作区和暂存区文件<br>使用–cached 文件名 只删除暂存区的文件</p></blockquote></li><li>重命名文件<br><code>git mv 旧文件名 新文件名</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
