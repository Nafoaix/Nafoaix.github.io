<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用WSL+VScode搭建C/C++开发环境</title>
      <link href="/archives/d3d975f8.html"/>
      <url>/archives/d3d975f8.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用WSL-VScode搭建C-C-开发环境"><a href="#使用WSL-VScode搭建C-C-开发环境" class="headerlink" title="使用WSL+VScode搭建C/C++开发环境"></a>使用WSL+VScode搭建C/C++开发环境</h1><div class="note info flat"><p>参考文档：<a href="https://docs.microsoft.com/zh-cn/windows/wsl/setup/environment">https://docs.microsoft.com/zh-cn/windows/wsl/setup/environment</a></p></div><h2 id="安装WSL"><a href="#安装WSL" class="headerlink" title="安装WSL"></a>安装WSL</h2><h3 id="新版本"><a href="#新版本" class="headerlink" title="新版本"></a>新版本</h3><p>对于最新版本的 Windows （内部版本 20262+）可以使用简化的 –install 命令安装WSL。若要检查 Windows 版本及内部版本号，选择 Windows 徽标键 + R，然后键入“winver”，选择“确定”。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wsl -<span class="literal">-install</span></span><br></pre></td></tr></table></figure><p>–install 命令执行以下操作：</p><ul><li>启用可选的 WSL 和虚拟机平台组件</li><li>下载并安装最新 Linux 内核</li><li>将 WSL 2 设置为默认值</li><li>下载并安装 Ubuntu Linux 发行版（可能需要重新启动）</li></ul><p>在此安装过程中，你将需要重启计算机。</p><h3 id="其他版本"><a href="#其他版本" class="headerlink" title="其他版本"></a>其他版本</h3><p>若要更新到 WSL 2，需要运行 Windows 10。<br>对于 x64 系统：版本 1903 或更高版本，采用内部版本 18362 或更高版本。<br>对于 ARM64 系统：版本 2004 或更高版本，采用内部版本 19041 或更高版本。<br>低于 18362 的版本不支持 WSL 2。 使用 Windows Update 助手更新 Windows 版本。</p><p>如不是最新版本可以以管理员身份运行powershell，按以下步骤安装：</p><h4 id="1-启用-Windows-Subsystem-Linux子系统"><a href="#1-启用-Windows-Subsystem-Linux子系统" class="headerlink" title="1.启用 Windows-Subsystem-Linux子系统"></a>1.启用 Windows-Subsystem-Linux子系统</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dism.exe /online /<span class="built_in">enable-feature</span> /featurename:Microsoft<span class="literal">-Windows</span><span class="literal">-Subsystem</span><span class="literal">-Linux</span> /all /norestart   </span><br></pre></td></tr></table></figure><h4 id="2-开启虚拟机功能"><a href="#2-开启虚拟机功能" class="headerlink" title="2.开启虚拟机功能"></a>2.开启虚拟机功能</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dism.exe /online /<span class="built_in">enable-feature</span> /featurename:VirtualMachinePlatform /all /norestart </span><br></pre></td></tr></table></figure><h4 id="3-重启后下载安装Linux内核更新包"><a href="#3-重启后下载安装Linux内核更新包" class="headerlink" title="3.重启后下载安装Linux内核更新包"></a>3.重启后下载安装Linux内核更新包</h4><p>下载地址： <a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">适用于 x64 计算机的 WSL2 Linux 内核更新包</a></p><h4 id="4-将wsl2设为默认版本"><a href="#4-将wsl2设为默认版本" class="headerlink" title="4.将wsl2设为默认版本"></a>4.将wsl2设为默认版本</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wsl -<span class="literal">-set</span><span class="literal">-default</span><span class="literal">-version</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="5-自己选择安装Linux发行版"><a href="#5-自己选择安装Linux发行版" class="headerlink" title="5.自己选择安装Linux发行版"></a>5.自己选择安装Linux发行版</h4><p>打开 <a href="https://www.microsoft.com/store/apps/9n6svws3rx71">Microsoft Store</a>，并选择你偏好的 Linux 分发版。</p><h2 id="配置开发环境"><a href="#配置开发环境" class="headerlink" title="配置开发环境"></a>配置开发环境</h2><p>安装完成后打开WSL的shell</p><h3 id="1-更新ubuntu软件"><a href="#1-更新ubuntu软件" class="headerlink" title="1.更新ubuntu软件"></a>1.更新ubuntu软件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><h3 id="2-安装编译器调试器"><a href="#2-安装编译器调试器" class="headerlink" title="2.安装编译器调试器"></a>2.安装编译器调试器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt -y install gcc g++ gdb</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Nafoaix/pic-repo/imgs/202205082315643.png"></p><h3 id="3-在VScode中安装wsl插件"><a href="#3-在VScode中安装wsl插件" class="headerlink" title="3.在VScode中安装wsl插件"></a>3.在VScode中安装wsl插件</h3><p>在子系统shell中输入<code>code .</code>就可以打开VScode，第一次从子系统打开VS Code会自动安装一些插件，等待安装完成后就可以在WSL中进行开发了。</p>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WSL </tag>
            
            <tag> VScode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云服务器部署个人网盘服务</title>
      <link href="/archives/fb8823a1.html"/>
      <url>/archives/fb8823a1.html</url>
      
        <content type="html"><![CDATA[<h1 id="阿里云服务器部署个人网盘服务"><a href="#阿里云服务器部署个人网盘服务" class="headerlink" title="阿里云服务器部署个人网盘服务"></a>阿里云服务器部署个人网盘服务</h1><blockquote><p>相关资源：<br>kiftd ： <a href="https://github.com/KOHGYLW/kiftd">https://github.com/KOHGYLW/kiftd</a></p></blockquote><h2 id="1-安装JAVA运行环境"><a href="#1-安装JAVA运行环境" class="headerlink" title="1.安装JAVA运行环境"></a>1.安装JAVA运行环境</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install java-11-openjdk-devel</span><br></pre></td></tr></table></figure><p>安装完成后查看版本，输出下面内容说明已经安装好。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@nafxali ~]<span class="comment"># java -version</span></span><br><span class="line">openjdk version <span class="string">&quot;11.0.9.1&quot;</span> 2020-11-04 LTS</span><br><span class="line">OpenJDK Runtime Environment 18.9 (build 11.0.9.1+1-LTS)</span><br><span class="line">OpenJDK 64-Bit Server VM 18.9 (build 11.0.9.1+1-LTS, mixed mode, sharing)</span><br></pre></td></tr></table></figure><p>CentOS 8还支持无头版本的OpenJDK，该版本提供了无需图形用户界面（不支持键盘，鼠标和显示系统）来执行应用程序所需的最少Java运行时，该版本具有更少的依赖性和更少的系统资源，因此它更适合于服务器应用程序。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install java-11-openjdk-headless</span><br></pre></td></tr></table></figure><h2 id="2-下载kiftd包并解压"><a href="#2-下载kiftd包并解压" class="headerlink" title="2.下载kiftd包并解压"></a>2.下载kiftd包并解压</h2><p>Linux压缩包：<a href="https://cloud.189.cn/t/ruIr2eyeyUVb">https://cloud.189.cn/t/ruIr2eyeyUVb</a> (访问码:v5pj)<br>下载压缩包并上传到服务器，在具备rwx权限且不含中文的文件夹中解压，即可以用命令直接启动kiftd服务。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar kiftd-x.x.x-xxx.jar -console </span><br></pre></td></tr></table></figure><h2 id="3-后台运行kiftd"><a href="#3-后台运行kiftd" class="headerlink" title="3.后台运行kiftd"></a>3.后台运行kiftd</h2><h3 id="Screen-工具"><a href="#Screen-工具" class="headerlink" title="Screen 工具"></a>Screen 工具</h3><p>Screen 工具能够虚拟出一个终端并执行相应的操作。使用前，您需要先安装<br>该工具，例如在 Ubnutu 系统中，您可以使用以下命令进行安装： </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install screen </span><br></pre></td></tr></table></figure><p>该工具安装完成后，您便可以使用它来运行 kiftd:  </p><h4 id="1-创建一个虚拟终端："><a href="#1-创建一个虚拟终端：" class="headerlink" title="1.创建一个虚拟终端："></a>1.创建一个虚拟终端：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -S &#123;自定义的虚拟终端名称&#125; </span><br></pre></td></tr></table></figure><p>例如： </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -S kiftd </span><br></pre></td></tr></table></figure><h4 id="2-在虚拟终端中以命令模式启动-kiftd："><a href="#2-在虚拟终端中以命令模式启动-kiftd：" class="headerlink" title="2.在虚拟终端中以命令模式启动 kiftd："></a>2.在虚拟终端中以命令模式启动 kiftd：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar kiftd-x.x.x-xxx.jar -console </span><br></pre></td></tr></table></figure><p>之后您便可以断开 SSH 连接或者使用 Ctrl+A Ctrl+D 键暂时退出虚拟终端以进行其他操作。</p><h4 id="3，当您需要继续操作-kiftd-时："><a href="#3，当您需要继续操作-kiftd-时：" class="headerlink" title="3，当您需要继续操作 kiftd 时："></a>3，当您需要继续操作 kiftd 时：</h4><p>请使用 SSH 重新链接至远程服务器，之后使用虚拟终端名重新回到 screen虚拟终端： </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -r &#123;自定义的虚拟终端名称&#125; </span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -r kiftd </span><br></pre></td></tr></table></figure><p>这样您便能返回之前的虚拟终端并继续操作 kiftd。</p><h2 id="4-开放端口"><a href="#4-开放端口" class="headerlink" title="4.开放端口"></a>4.开放端口</h2><h3 id="服务器防火墙开放端口"><a href="#服务器防火墙开放端口" class="headerlink" title="服务器防火墙开放端口"></a>服务器防火墙开放端口</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">查看防火墙某个端口是否开放</span><br><span class="line">firewall-cmd --query-port=3306/tcp</span><br><span class="line">开放防火墙端口3306</span><br><span class="line">firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class="line">注意：开放端口后要重启防火墙生效</span><br><span class="line">重启防火墙</span><br><span class="line">systemctl restart firewalld</span><br><span class="line">关闭防火墙端口</span><br><span class="line">firewall-cmd --remove-port=3306/tcp --permanent</span><br><span class="line">查看防火墙状态</span><br><span class="line">systemctl status firewalld</span><br><span class="line">关闭防火墙</span><br><span class="line">systemctl stop firewalld</span><br><span class="line">打开防火墙</span><br><span class="line">systemctl start firewalld</span><br><span class="line">开放一段端口</span><br><span class="line">firewall-cmd --zone=public --add-port=40000-45000/tcp --permanent</span><br><span class="line">查看开放的端口列表</span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line">查看被监听(Listen)的端口</span><br><span class="line">netstat -lntp</span><br><span class="line">检查端口被哪个进程占用</span><br><span class="line">netstat -lnp|grep 3306</span><br></pre></td></tr></table></figure><h3 id="阿里云开放端口"><a href="#阿里云开放端口" class="headerlink" title="阿里云开放端口"></a>阿里云开放端口</h3><p>实例=&gt;安全组=&gt;手动添加</p>]]></content>
      
      
      <categories>
          
          <category> LINUX </category>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPC-610E(电子组件的可接受性)</title>
      <link href="/archives/b3c014a2.html"/>
      <url>/archives/b3c014a2.html</url>
      
        <content type="html"><![CDATA[<h1 id="IPC-610E（电子组件的可接受性）"><a href="#IPC-610E（电子组件的可接受性）" class="headerlink" title="IPC-610E（电子组件的可接受性）"></a>IPC-610E（电子组件的可接受性）</h1><h2 id="IPC简介"><a href="#IPC简介" class="headerlink" title="IPC简介"></a>IPC简介</h2><!-- ![CD Projekt RED](https://cdn.jsdelivr.net/gh/Nafoaix/pic-repo@master/well-known_game/CDPR.jpg)> [`av16789674`](https://www.bilibili.com/video/av16789674/)《巫师 3》以及 CD Projekt 成功发展史-全 6 集游戏纪录片 --><p>&emsp;&emsp;IPC最初为“The Institute of Printed Circuit”的缩写，即美国“印制电路板协会”，后改名为“The Institute of the Interconnecting and Packing Electronic Circuit”(电子电路互连与封装协会)，1999年再次更名为“Associatation Of Connecting Electronics Industries”(电子制造业协会”)。由于IPC知名度很高，所以更名后，IPC的标记和缩写仍然没有改变。IPC拥有两千六百多个协会成员，包括世界著名的从事印制电路板设计、制造、组装、OEM（Original equipment manufacturer 即原始设备制造商）加工、EMS（electronics manufacture service 即电子制造服务）外包的大公司，IPC与IEC、ISO、IEEE、JEDC一样，是美国乃至全球电子制造业最有影响力的组织之一。 </p><p>&emsp;&emsp;IPC-A-610是国际上电子制造业界普遍公认的可作为国际通行的质量检验标准。IPC-A-610收集了有关电子组件的外观质量可接受要求，规定了怎样把元器件合格地组装到电路板上，对每种级别的标准都提供了可测量的元器件位置和焊点尺寸，并提供合格焊点的相应技术指标。</p><h2 id="IPC-A-610E电子产品等级"><a href="#IPC-A-610E电子产品等级" class="headerlink" title="IPC-A-610E电子产品等级"></a>IPC-A-610E电子产品等级</h2><ol><li>1级-普通类电⼦子产品<br>包括那些对外观要求不高而以其组装功能完整为主要要求的产品。（如玩具、计算器等）</li><li>2级-专⽤用服务类电⼦子产品<br>包括那些要求持续运行和较长使用寿命的产品，最好能保持不间断工作但该要求不严格。一般情况下不会因使用环境而导致故障。（如通讯设备等）</li><li>3级-⾼高性能电⼦子产品<br>包括以连续具有高性能或严格按指令运行为关键的产品。这类产品的服务间断是不可接受的，且最终产品使用环境异常苛刻；有要求时产品必须能够正常运行，例如救生设备或飞行控制系统等其他关键系统。</li></ol><h2 id="IPC-A-610E-验收条件"><a href="#IPC-A-610E-验收条件" class="headerlink" title="IPC-A-610E 验收条件"></a>IPC-A-610E 验收条件</h2><p>&emsp;&emsp;当合同要求使用IPC-A-610，本标准中所有适用的要求应当被实施于所有适用的分包合同中。如无，按以下优先次序执行：</p><ul><li>用户与制造商之间达成的采购文件。</li><li>反映用户具体要求的总图或总装图。</li><li>用户引用或合同协议引用IPC-A-610。<br>当其他文件同时与IPC-A-610被引用时，应当在采购文件中规定其优先顺序。  </li></ul><p><strong>四级验收条件：</strong></p><ul><li><p>目标条件<br>&emsp;&emsp;是指近乎完美/首选的情形，然而这是一种理想而非总能达到的情形，且对于保证组件在使用环境下的可靠性并非必要的情形。</p></li><li><p>可接受条件<br>&emsp;&emsp;是指组件不必完美但要在使用环境下保持完整性和可靠性的特征。</p></li><li><p>缺陷条件<br>&emsp;&emsp;缺陷是指组件在其最终使用环境下不足以确保外形、装配和功能（3F）的情况。缺陷情况应当由制造商根据设计、服务和客户要求进行处置（处置：决定缺陷应该作何种处理)。处置可以是返工、维修、报废或照样使用，但不限于以上处理方式。其中维修或“照样使用”必须取得客户的认可。<br>★1级缺陷自动成为2级和3级缺陷。2级缺陷意味着对3级也是缺陷。</p></li><li><p>制程警示条件<br>&emsp;&emsp;制程警示（非缺陷）是指没有影响到产品的外形、装配和功能（3F）的情况。且对于保证组件在使用环境下的可靠性并非必要的情形。这种情况是由于材料、设计或操作人员/机器设备等相关因素引起的，既不能完全满足可接受条件又非缺陷。应该将制程警示纳入过程控制系统而对其实行监控。当制程警示的数量表明制程发生变异或朝着不理想的趋势变化时，则应该对工艺进行分析。结果可能要求采取措施以降低制程变异程度并提高产量。不要求对单一性制程警示进行处置。</p></li></ul><h2 id="专业名词解释"><a href="#专业名词解释" class="headerlink" title="专业名词解释"></a>专业名词解释</h2><ul><li>主面<br>总设计图上定义的封装与互连结构(PCB)面。（通常为包含最复杂或数量最多的元器件那一面。该面在通孔插装技术中有时又称作元器件面或焊接终止面）。</li><li>辅面<br>与主面相对的封装与互连结构（PCB）面。（在通孔插装技术中有时称作焊接面或焊接起始面）</li><li>焊接起始面<br>焊接起始面是指印制电路板上施加焊料的那一面。采用波峰焊、浸焊或拖焊时，通常又是PCB的辅面。采用手工焊接时，焊接起始面也可能是PCB的主面。</li><li>焊接终止面<br>焊接终止面是指通孔插装中PCB上焊料流向的那一面，采用波峰焊、浸焊或拖焊时，通常又是PCB的主面。采用手工焊接时，焊接终止面也可能是PCB的辅面。</li><li>冷焊接连接<br>是指呈现很差的润湿性、外表灰暗、疏松的焊接连接。（这种现象是由于焊料中杂质过多，焊接前清洁不充分，和/或焊接过程中热量不足所致。）</li><li>浸析<br>指焊接过程中金属基材或涂覆层的流失或去除。</li><li>照明<br>对被检查的部件应当有足够的照明。工作台表面的照明至少应该达到1000 lm/m2[约93英尺烛光]。应该选择不会产生阴影的光源。<br>注：选择光源时，色温是一个需要考虑的重要因素。色温在3000-5000o K范围的光源，清晰度会逐步增加，使用户能够鉴别出印制电路板组<br>件的各种特征和污染物。</li></ul><h2 id="焊接可接受性要求"><a href="#焊接可接受性要求" class="headerlink" title="焊接可接受性要求"></a>焊接可接受性要求</h2><h3 id="目标-1-2-3级"><a href="#目标-1-2-3级" class="headerlink" title="目标-1,2,3级"></a>目标-1,2,3级</h3><ul><li>焊料填充基本平滑，对连接的零部件呈现良好润湿。</li><li>零部件的轮廓容易分辨。</li><li>焊料在被连接部件上形成羽毛状边缘。</li><li>填充呈凹面状。<h3 id="可接受-1-2-3级"><a href="#可接受-1-2-3级" class="headerlink" title="可接受-1,2,3级"></a>可接受-1,2,3级</h3></li><li>有些材料和工艺，例如：无铅合金、大热容PCB引起的慢冷却，可能导致干枯粗糙、灰暗、或颗粒状这种与材料和工艺相关的焊料外观，属正常现象。这样的焊接连接是可接受的。</li><li>焊接连接润湿角（焊料与元器件之间和焊料与焊盘之间）不超过90o （图5-1的A和B）。–例外的情况是当焊料轮廓延伸到可焊端边缘或阻焊膜时，润湿角可以超过90o（图5-1的C和D）</li><li>典型的锡铅焊点特征：光亮 平滑  凹形表面  轮廓清晰</li></ul><blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> IPC-610E </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IPC-610E </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环境温湿度监控系统（51+DHT11+1602液晶）</title>
      <link href="/archives/3003c9dd.html"/>
      <url>/archives/3003c9dd.html</url>
      
        <content type="html"><![CDATA[<h1 id="环境温湿度监控系统（51-DHT11-1602液晶）"><a href="#环境温湿度监控系统（51-DHT11-1602液晶）" class="headerlink" title="环境温湿度监控系统（51+DHT11+1602液晶）"></a>环境温湿度监控系统（51+DHT11+1602液晶）</h1><div class="note info flat"><p>使用模块：<br>DHT11 Datasheet: <a href="https://www.alldatasheetcn.com/datasheet-pdf/pdf/1132088/ETC2/DHT11.html">https://www.alldatasheetcn.com/datasheet-pdf/pdf/1132088/ETC2/DHT11.html</a><br>SMC1602 Datasheet: <a href="https://www.alldatasheetcn.com/datasheet-pdf/pdf/106031/ETC/SMC1602A.html">https://www.alldatasheetcn.com/datasheet-pdf/pdf/106031/ETC/SMC1602A.html</a><br>89C52 Datasheet: <a href="https://www.alldatasheet.com/datasheet-pdf/pdf/240685/ATMEL/AT89C52.html">https://www.alldatasheet.com/datasheet-pdf/pdf/240685/ATMEL/AT89C52.html</a></p></div><h2 id="一-原理图"><a href="#一-原理图" class="headerlink" title="一.原理图"></a>一.原理图</h2><p><img src="https://cdn.jsdelivr.net/gh/Nafoaix/pic-repo@master/DHT111602/Schematic.png" alt="Schematic"></p><h2 id="二-1602显示模块"><a href="#二-1602显示模块" class="headerlink" title="二.1602显示模块"></a>二.1602显示模块</h2><p>模块头文件：引脚定义，接口定义。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _1602_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _1602_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_Bus P2 <span class="comment">//LCD1602数据总线</span></span></span><br><span class="line">sbit RS = P0^<span class="number">7</span>;<span class="comment">// LCD数据/命令选择端</span></span><br><span class="line">sbit RW = P0^<span class="number">6</span>;<span class="comment">// LCD读写选择端</span></span><br><span class="line">sbit EN = P0^<span class="number">5</span>;<span class="comment">// LCD使能端，高脉冲有效</span></span><br><span class="line"></span><br><span class="line">sbit busy_led1 = P1^<span class="number">0</span>; <span class="comment">//LCD忙指示灯</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Lcd_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;                    <span class="comment">//1602初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Lcd_WriteData</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> Data)</span></span>; <span class="comment">//写数据</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Lcd_WriteCmd</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> Cmd)</span></span>; <span class="comment">//写指令</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Lcd_WriteStr</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *Str)</span></span>; <span class="comment">//写一串字符串</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>函数实现见<a href="https://github.com/Nafoaix/DHT11-1602.git"><code>GIT仓库</code></a>或参考<a href="https://www.alldatasheetcn.com/datasheet-pdf/pdf/106031/ETC/SMC1602A.html"><code>SMC1602 Datasheet</code></a>编写。</p><h2 id="三-DHT11模块"><a href="#三-DHT11模块" class="headerlink" title="三.DHT11模块"></a>三.DHT11模块</h2><p>模块头文件：引脚定义，接口定义。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _DHT11_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DHT11_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrins.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit DHT11_Data = P0^<span class="number">4</span>;   <span class="comment">//dht11数据端口</span></span><br><span class="line"></span><br><span class="line">sbit NOresponse_led2 = P1^<span class="number">1</span>;</span><br><span class="line">sbit start_led3 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ERRORREVISE_LED4 = P1^<span class="number">3</span>;</span><br><span class="line">sbit test_led5 = P1^<span class="number">4</span>;</span><br><span class="line">sbit ASK_LED6 = P1^<span class="number">5</span>;</span><br><span class="line">sbit rec_byte_led7 = P1^<span class="number">6</span>;</span><br><span class="line">sbit rec_40_led8 = P1^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DHT11 测量范围 20~90%RH(5%RH) 0~50C(2C) 工作电压3~ 5.5V*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> rec_dat[<span class="number">16</span>];<span class="comment">//全局变量 用于显示的接收数据数组             </span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> RH,TH;</span><br><span class="line"><span class="comment">//extern void DHT11_delay_us(unsigned char us); //11.0592大概每次循环延时4.3us</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">DHT11_delay_ms</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> ms)</span></span>;  <span class="comment">//ms延时</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">DHT11_rec_40</span><span class="params">(<span class="keyword">void</span>)</span></span>;   <span class="comment">//接收40位全部数据</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>函数实现见<a href="https://github.com/Nafoaix/DHT11-1602.git"><code>GIT仓库</code></a>或参考<a href="https://www.alldatasheetcn.com/datasheet-pdf/pdf/1132088/ETC2/DHT11.html"><code>DHT11 Datasheet</code></a>编写。</p><h2 id="四-功能模块"><a href="#四-功能模块" class="headerlink" title="四.功能模块"></a>四.功能模块</h2><p>主函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;1602.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;DHT11.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar unsigned char</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="comment">/*------------按键引脚---------------*/</span></span><br><span class="line">sbit ok_SW1 = P3^<span class="number">5</span>; <span class="comment">//确定-SW1</span></span><br><span class="line">sbit add_SW2 = P3^<span class="number">4</span>;<span class="comment">//增加-SW2</span></span><br><span class="line">sbit sub_SW3 = P3^<span class="number">3</span>;<span class="comment">//减少-SW3</span></span><br><span class="line">sbit sw_SW4 = P3^<span class="number">2</span>; <span class="comment">//选择-SW4</span></span><br><span class="line"><span class="comment">/*------------蜂鸣器引脚---------------*/</span></span><br><span class="line">sbit bell = P3^<span class="number">6</span>;</span><br><span class="line"><span class="comment">/*------------变量声明---------------*/</span></span><br><span class="line">uchar HTemp,LTemp,HRH,LRH,<span class="built_in">set</span>;</span><br><span class="line"><span class="comment">/*------------函数声明---------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">Key_Scan</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_Alarm_Timer0</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uchar i;   <span class="comment">//rec_dat[]数组显示用</span></span><br><span class="line">DHT11_delay_ms(<span class="number">1500</span>);   <span class="comment">//DHT11上电后要等待1S以越过不稳定状态在此期间不能发送任何指令</span></span><br><span class="line">DHT11_rec_40();</span><br><span class="line">Lcd_Init();<span class="comment">//Lcd初始化</span></span><br><span class="line">HTemp=<span class="number">35</span>,LTemp=<span class="number">15</span>;HRH=<span class="number">80</span>,LRH=<span class="number">20</span>;<span class="built_in">set</span>=<span class="number">2</span>;</span><br><span class="line">Init_Alarm_Timer0();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span>(<span class="built_in">set</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;Press S1 to set &quot;</span>);</span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span> + <span class="number">0x40</span>);<span class="comment">//设置数据指针到第二行首</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)&#123;Lcd_WriteData(rec_dat[i]);&#125;   <span class="comment">//显示数据 </span></span><br><span class="line"><span class="keyword">if</span>(Key_Scan() == <span class="number">1</span>) &#123;<span class="built_in">set</span> = <span class="number">2</span>;&#125;</span><br><span class="line">                DHT11_delay_ms(<span class="number">2500</span>);</span><br><span class="line">DHT11_rec_40();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;Set the max RH  &quot;</span>);</span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span> + <span class="number">0x40</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;Maximum RH: &quot;</span>);</span><br><span class="line">Lcd_WriteData(<span class="string">&#x27;0&#x27;</span>+(HRH/<span class="number">10</span>));</span><br><span class="line">Lcd_WriteData(<span class="string">&#x27;0&#x27;</span>+(HRH%<span class="number">10</span>));</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;%  &quot;</span>);</span><br><span class="line"><span class="keyword">switch</span>(Key_Scan())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">set</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">HRH+=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">HRH-=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;Set the min RH  &quot;</span>);</span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span> + <span class="number">0x40</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;Minimum RH: &quot;</span>);</span><br><span class="line">Lcd_WriteData(<span class="string">&#x27;0&#x27;</span>+(LRH/<span class="number">10</span>));</span><br><span class="line">Lcd_WriteData(<span class="string">&#x27;0&#x27;</span>+(LRH%<span class="number">10</span>));</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;%  &quot;</span>);</span><br><span class="line"><span class="keyword">switch</span>(Key_Scan())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">set</span> = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">LRH+=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">LRH-=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;Set the max Temp &quot;</span>);</span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span> + <span class="number">0x40</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;Max Temp:  &quot;</span>);</span><br><span class="line">Lcd_WriteData(<span class="string">&#x27;0&#x27;</span>+(HTemp/<span class="number">10</span>));</span><br><span class="line">Lcd_WriteData(<span class="string">&#x27;0&#x27;</span>+(HTemp%<span class="number">10</span>));</span><br><span class="line">Lcd_WriteData(<span class="string">&#x27;0&#x27;</span>+<span class="number">175</span>); </span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;C   &quot;</span>);</span><br><span class="line"><span class="keyword">switch</span>(Key_Scan())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">set</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">HTemp+=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">HTemp-=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;Set the min Temp &quot;</span>);</span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span> + <span class="number">0x40</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;Min Temp:  &quot;</span>);</span><br><span class="line">Lcd_WriteData(<span class="string">&#x27;0&#x27;</span>+(LTemp/<span class="number">10</span>));</span><br><span class="line">Lcd_WriteData(<span class="string">&#x27;0&#x27;</span>+(LTemp%<span class="number">10</span>));</span><br><span class="line">Lcd_WriteData(<span class="string">&#x27;0&#x27;</span>+<span class="number">175</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;C   &quot;</span>);</span><br><span class="line"><span class="keyword">switch</span>(Key_Scan())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">set</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">LTemp+=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">LTemp-=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>: </span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;Over Temp alarm &quot;</span>);</span><br><span class="line">bell = ~bell;</span><br><span class="line"><span class="keyword">if</span>(Key_Scan()) &#123; <span class="built_in">set</span> = <span class="number">4</span>; &#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>: </span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;Over RH alarm   &quot;</span>);</span><br><span class="line">bell = ~bell;</span><br><span class="line"><span class="keyword">if</span>(Key_Scan()) &#123; <span class="built_in">set</span> = <span class="number">2</span>; &#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span> :</span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;ERROR 101       &quot;</span>);</span><br><span class="line">Lcd_WriteCmd(<span class="number">0x80</span> + <span class="number">0x40</span>);</span><br><span class="line">Lcd_WriteStr(<span class="string">&quot;UNKNOW SET VALUE&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(Key_Scan()) &#123; <span class="built_in">set</span> = <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_Alarm_Timer0</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TMOD |= <span class="number">0x01</span>;  <span class="comment">//使用工作模式1，16位定时器，使用&quot;|&quot;或等符号可以在使用多个定时器时不受影响     </span></span><br><span class="line">TH0 = (<span class="number">65535</span><span class="number">-46082</span>) / <span class="number">256</span>;<span class="comment">//给定初值50ms</span></span><br><span class="line">TL0 = (<span class="number">65535</span><span class="number">-46082</span>) % <span class="number">256</span>;</span><br><span class="line">EA=<span class="number">1</span>;             <span class="comment">//打开总中断</span></span><br><span class="line">ET0=<span class="number">1</span>;            <span class="comment">//定时器中断打开 T0的溢出中断允许位</span></span><br><span class="line">TR0 = <span class="number">1</span>;  <span class="comment">//打开定时器开关</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer0_Alarm</span><span class="params">(<span class="keyword">void</span>)</span> interrupt 1</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TH0 = (<span class="number">65535</span><span class="number">-46082</span>) / <span class="number">256</span>;<span class="comment">//重设初值</span></span><br><span class="line">TL0 = (<span class="number">65535</span><span class="number">-46082</span>) % <span class="number">256</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">set</span> == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(TH&lt;LTemp||TH&gt;HTemp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">set</span> = <span class="number">6</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(RH&lt;LRH||RH&gt;HRH)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">set</span> = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">Key_Scan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> keyValue = <span class="number">0</span> , i; <span class="comment">//保存键值</span></span><br><span class="line">    <span class="comment">//--检测按键SW1--//</span></span><br><span class="line">    <span class="keyword">if</span> (ok_SW1 != <span class="number">1</span>)<span class="comment">//检测按键&#x27;确定-SW1&#x27;是否按下 按键被按下VCC上拉电阻接地，输入线线路电压0V</span></span><br><span class="line">    &#123;</span><br><span class="line">    DHT11_delay_ms(<span class="number">10</span>);<span class="comment">//消除抖动</span></span><br><span class="line">        <span class="keyword">if</span> (ok_SW1 != <span class="number">1</span>)<span class="comment">//再次检测按键是否按下</span></span><br><span class="line">        &#123;</span><br><span class="line">            keyValue = <span class="number">1</span>;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((i&lt;<span class="number">50</span>) &amp;&amp; (ok_SW1 != <span class="number">1</span>)) <span class="comment">//检测按键是否松开</span></span><br><span class="line">            &#123;</span><br><span class="line">                DHT11_delay_ms(<span class="number">10</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//--检测按键SW2--//</span></span><br><span class="line">    <span class="keyword">if</span> (add_SW2 != <span class="number">1</span>)<span class="comment">//检测&#x27;增加-SW2&#x27;是否按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        DHT11_delay_ms(<span class="number">10</span>);<span class="comment">//消除抖动</span></span><br><span class="line">        <span class="keyword">if</span> (add_SW2!= <span class="number">1</span>)<span class="comment">//再次检测按键是否按下</span></span><br><span class="line">        &#123;</span><br><span class="line">            keyValue = <span class="number">2</span>;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((i&lt;<span class="number">50</span>) &amp;&amp; (add_SW2 != <span class="number">1</span>)) <span class="comment">//检测按键是否松开</span></span><br><span class="line">            &#123;</span><br><span class="line">                DHT11_delay_ms(<span class="number">10</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//--检测按键SW3--//</span></span><br><span class="line">    <span class="keyword">if</span> (sub_SW3 != <span class="number">1</span>)<span class="comment">//检测&#x27;减少-SW3&#x27;是否按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        DHT11_delay_ms(<span class="number">10</span>);<span class="comment">//消除抖动</span></span><br><span class="line">        <span class="keyword">if</span> (sub_SW3 != <span class="number">1</span>)<span class="comment">//再次检测按键是否按下</span></span><br><span class="line">        &#123;</span><br><span class="line">            keyValue = <span class="number">3</span>;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((i&lt;<span class="number">50</span>) &amp;&amp; (sub_SW3 != <span class="number">1</span>)) <span class="comment">//检测按键是否松开</span></span><br><span class="line">            &#123;</span><br><span class="line">                DHT11_delay_ms(<span class="number">10</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//--检测按键SW4--//</span></span><br><span class="line">    <span class="keyword">if</span> (sw_SW4 != <span class="number">1</span>)<span class="comment">//检测&#x27;选择-SW4&#x27;是否按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        DHT11_delay_ms(<span class="number">10</span>);<span class="comment">//消除抖动</span></span><br><span class="line">        <span class="keyword">if</span> (sw_SW4!= <span class="number">1</span>)<span class="comment">//再次检测按键是否按下</span></span><br><span class="line">        &#123;</span><br><span class="line">            keyValue = <span class="number">4</span>;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((i&lt;<span class="number">50</span>) &amp;&amp; (sw_SW4 != <span class="number">1</span>)) <span class="comment">//检测按键是否松开</span></span><br><span class="line">            &#123;</span><br><span class="line">                DHT11_delay_ms(<span class="number">10</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyValue;   <span class="comment">//将读取到键值的值返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tips:</p><p>nop指令的作用：<br>1）就是通过nop指令的填充（nop指令一个字节），使指令按字对齐，从而减少取指令时的内存访问次数。（一般用来内存地址偶数对齐，比如有一条指令，占3字节，这时候使用nop指令，cpu 就可以从第四个字节处读取指令了。）<br>2）通过nop指令产生一定的延迟，但是对于快速的CPU来说效果不明显，可以使用rep前缀，多延迟几个时钟。<br>3）i/o传输时，也会用一下 nop，等待缓冲区清空，总线恢复；<br>4）清除由上一个算术逻辑指令设置的flag位；</p><p>该函数是在51单片机中用的延时函数，表示执行一条没有什么意义的指令，延时一个指令周期，有的指令周期是两个或两个以上的机械周期，但是_nop_();指令需要的只是一个机械周期也就是12个时钟周期（震荡周期）。<br>51单片机中，1个机械周期 = 12个时钟周期 = 12 * （ 1 / f）。（f 为晶振频率）。<br>如果只用的是12MHZ的晶振，那么 一个机械周期就是1us；也就是说：<br>nop(); 指令的延迟时间为 1us。可以较为精确得控制延迟时间。</p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
          <category> 51 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 51 </tag>
            
            <tag> 1602 </tag>
            
            <tag> DHT11 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在浏览器中输入 URL 回车之后发生了什么</title>
      <link href="/archives/c0d06efd.html"/>
      <url>/archives/c0d06efd.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>本文转自<a href="https://4ark.me//post/b6c7c0a2.html">4Ark</a><br>注意: 本文的步骤是建立在，请求的是一个简单的 HTTP 请求，没有 HTTPS、HTTP2、最简单的 DNS、没有代理、并且服务器没有任何问题的基础上，儘管这是不切实际的。</p></div><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><ol><li>URL 解析</li><li>DNS 查询</li><li>TCP 连接</li><li>处理请求</li><li>接受响应</li><li>渲染页面</li></ol><h3 id="一、URL-解析"><a href="#一、URL-解析" class="headerlink" title="一、URL 解析"></a>一、URL 解析</h3><ul><li>地址解析<br>  首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。</li><li>HSTS（HTTP Strict Transport Security）<br>  由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面</li><li>其他操作<br>  浏览器还会进行一些额外的操作，比如安全检查、访问限制（之前国产浏览器限制 996.icu）。</li><li>检查缓存<br>  <img src="https://cdn.jsdelivr.net/gh/Nafoaix/pic-repo@master/imgs/What_happens_when_you_type_an_URL_in_the_browser_and_press_enter.png" alt="What_happens_when_you_type_an_URL_in_the_browser_and_press_enter"></li></ul><h3 id="二、DNS-查询"><a href="#二、DNS-查询" class="headerlink" title="二、DNS 查询"></a>二、DNS 查询</h3><p><strong>基本步骤</strong><br><img src="https://cdn.jsdelivr.net/gh/Nafoaix/pic-repo@master/imgs/DNSchaxun.png" alt="DNS查询"></p><ol><li><p>浏览器缓存<br>浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。</p></li><li><p>操作系统缓存<br>操作系统也有自己的 DNS 缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。</p></li><li><p>路由器缓存<br>路由器也有自己的缓存。</p></li><li><p>ISP DNS 缓存<br>ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。</p></li><li><p>根域名服务器查询<br>在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程：<br><img src="https://cdn.jsdelivr.net/gh/Nafoaix/pic-repo@master/imgs/DNSfuwuqichaxun.png" alt="DNS服务器查询"></p><blockquote><p>根域名服务器：<a href="https://zh.wikipedia.org/wiki/%E6%A0%B9%E7%B6%B2%E5%9F%9F%E5%90%8D%E7%A8%B1%E4%BC%BA%E6%9C%8D%E5%99%A8">维基百科</a></p></blockquote><p> <strong>需要注意的点</strong></p><ul><li>递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地 DNS 服务器的过程）</li><li>迭代方式，就是本地 DNS 服务器到根域名服务器查询的方式。</li><li>什么是 DNS 劫持</li><li>前端 dns-prefetch 优化</li></ul></li></ol><h3 id="三、TCP-连接"><a href="#三、TCP-连接" class="headerlink" title="三、TCP 连接"></a>三、TCP 连接</h3><p>TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装：<br><img src="https://cdn.jsdelivr.net/gh/Nafoaix/pic-repo@master/imgs/TCPIP.png" alt="TCPIP"></p><ol><li><p>应用层：发送 HTTP 请求<br>在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括：</p><blockquote><p>1.请求报头（Request Header）：请求方法、目标地址、遵循的协议等等<br>2.请求主体（其他参数）</p></blockquote></li><li><p>传输层：TCP 传输报文<br>传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。<br>在建立连接前，会先进行 TCP 三次握手。</p><blockquote><p>关于 TCP/IP 三次握手，网上已经有很多段子和图片生动地描述了。<br>相关知识点：<br>SYN 泛洪攻击</p></blockquote></li><li><p>网络层：IP 协议查询 Mac 地址<br>将数据段打包，并加入源及目标的 IP 地址，并且负责寻找传输路线。<br>判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。</p><blockquote><p>注意：在 OSI 参考模型中 ARP 协议位于链路层，但在 TCP/IP 中，它位于网络层。</p></blockquote></li><li><p>链路层：以太网协议</p></li></ol><h4 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h4><p>根据以太网协议将数据分为以“帧”为单位的数据包，每一帧分为两个部分：</p><ul><li>标头：数据包的发送者、接受者、数据类型</li><li>数据：数据包具体内容</li></ul><h4 id="Mac-地址"><a href="#Mac-地址" class="headerlink" title="Mac 地址"></a>Mac 地址</h4><p>以太网规定了连入网络的所有设备都必须具备“网卡”接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力。</p><h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><p>发送数据的方法很原始，直接把数据通过 ARP 协议，向本网络的所有机器发送，接收方根据标头信息与自身 Mac 地址比较，一致就接受，否则丢弃。</p><p>注意：接收方回应是单播。</p><blockquote><p>相关知识点：<br>ARP 攻击</p></blockquote><p><strong>服务器接受请求</strong><br>接受过程就是把以上步骤逆转过来，参见上图。</p><h3 id="四、服务器处理请求"><a href="#四、服务器处理请求" class="headerlink" title="四、服务器处理请求"></a>四、服务器处理请求</h3><p><strong>大致流程</strong><br><img src="https://cdn.jsdelivr.net/gh/Nafoaix/pic-repo@master/imgs/fuwuqichuliqingqiu.png" alt="大致流程"></p><h4 id="HTTPD"><a href="#HTTPD" class="headerlink" title="HTTPD"></a>HTTPD</h4><p>最常见的 HTTPD 有 Linux 上常用的 Apache 和 Nginx，以及 Windows 上的 IIS。</p><p>它会监听得到的请求，然后开启一个子进程去处理这个请求。</p><h4 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h4><p>接受 TCP 报文后，会对连接进行处理，对 HTTP 协议进行解析（请求方法、域名、路径等），并且进行一些验证：</p><pre><code>验证是否配置虚拟主机验证虚拟主机是否接受此方法验证该用户可以使用该方法（根据 IP 地址、身份信息等）</code></pre><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>假如服务器配置了 HTTP 重定向，就会返回一个 301 永久重定向响应，浏览器就会根据响应，重新发送 HTTP 请求（重新执行上面的过程）。</p><blockquote><p>关于更多：<a href="https://www.cnblogs.com/workest/p/3891321.html">详见这篇文章</a></p></blockquote><h4 id="URL-重写"><a href="#URL-重写" class="headerlink" title="URL 重写"></a>URL 重写</h4><p>然后会查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js 文件等，则会直接把这个文件返回。</p><p>否则服务器会按照规则把请求重写到 一个 REST 风格的 URL 上。</p><p>然后根据动态语言的脚本，来决定调用什么类型的动态文件解释器来处理这个请求。</p><p>以 PHP 语言的 MVC 框架举例，它首先会初始化一些环境的参数，根据 URL 由上到下地去匹配路由，然后让路由所定义的方法去处理请求。</p><h3 id="五、浏览器接受响应"><a href="#五、浏览器接受响应" class="headerlink" title="五、浏览器接受响应"></a>五、浏览器接受响应</h3><p>浏览器接收到来自服务器的响应资源后，会对资源进行分析。<br>首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。<br>如果响应资源进行了压缩（比如 gzip），还需要进行解压。<br>然后，对响应资源做缓存。<br>接下来，根据响应资源里的 MIME 类型去解析响应内容（比如 HTML、Image 各有不同的解析方式）。</p><h3 id="六、渲染页面"><a href="#六、渲染页面" class="headerlink" title="六、渲染页面"></a>六、渲染页面</h3><h4 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h4><p><img src="https://cdn.jsdelivr.net/gh/Nafoaix/pic-repo@master/imgs/lilanqineihe.png" alt="浏览器内核"></p><p>不同的浏览器内核，渲染过程也不完全相同，但大致流程都差不多。</p><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p><img src="https://cdn.jsdelivr.net/gh/Nafoaix/pic-repo@master/imgs/xuanranyemian.png" alt="基本流程"></p><h4 id="1-HTML-解析"><a href="#1-HTML-解析" class="headerlink" title="1.HTML 解析"></a>1.HTML 解析</h4><p>首先要知道浏览器解析是从上往下一行一行地解析的。</p><p>解析的过程可以分为四个步骤：</p><ol><li><p>解码（encoding）<br>传输回来的其实都是一些二进制字节数据，浏览器需要根据文件指定编码（例如 UTF-8）转换成字符串，也就是 HTML 代码。</p></li><li><p>预解析（pre-parsing）<br>预解析做的事情是提前加载资源，减少处理时间，它会识别一些会请求资源的属性，比如 img 标签的 src 属性，并将这个请求加到请求队列中。</p></li><li><p>符号化（Tokenization）<br>符号化是词法分析的过程，将输入解析成符号，HTML 符号包括，开始标签、结束标签、属性名和属性值。<br>它通过一个状态机去识别符号的状态，比如遇到&lt;，&gt;状态都会产生变化。</p></li><li><p>构建树（tree construction）</p><blockquote><p>注意：符号化和构建树是并行操作的，也就是说只要解析到一个开始标签，就会创建一个 DOM 节点。</p></blockquote></li></ol><p>在上一步符号化中，解析器获得这些标记，然后以合适的方法创建 DOM 对象并把这些符号插入到 DOM 对象中。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is an example Web page.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Nafoaix/pic-repo@master/imgs/DOM.png" alt="HTML"></p><p><strong>浏览器容错进制</strong><br>你从来没有在浏览器看过类似”语法无效”的错误，这是因为浏览器去纠正错误的语法，然后继续工作。</p><p><strong>事件</strong><br>当整个解析的过程完成以后，浏览器会通过 <code>DOMContentLoaded</code> 事件来通知 <code>DOM</code> 解析完成。</p><h4 id="2-CSS-解析"><a href="#2-CSS-解析" class="headerlink" title="2. CSS 解析"></a>2. CSS 解析</h4><p>一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 <code>CSS</code>，根据语法<a href="https://drafts.csswg.org/css-syntax-3/">规范解析</a>出所有的 <code>CSS</code> 并进行标记化，然后我们得到一个规则表。</p><p><strong>CSS 匹配规则</strong><br>在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如：<code>div p &#123; font-size :14px &#125;</code>会先寻找所有的<code>p</code>标签然后判断它的父元素是否为 <code>div</code>。</p><p>所以我们写 <code>CSS</code> 时，尽量用 <code>id</code> 和 <code>class</code>，千万不要过度层叠。</p><h4 id="3-渲染树"><a href="#3-渲染树" class="headerlink" title="3. 渲染树"></a>3. 渲染树</h4><p>其实这就是一个 <code>DOM</code> 树和 <code>CSS</code> 规则树合并的过程。</p><blockquote><p>注意：渲染树会忽略那些不需要渲染的节点，比如设置了<code>display:none</code>的节点。</p></blockquote><p><strong>计算</strong><br>通过计算让任何尺寸值都减少到三个可能之一：<code>auto</code>、百分比、<code>px</code>，比如把 <code>rem</code> 转化为 <code>px</code>。</p><p><strong>级联</strong><br>浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做 specificity 的公式，这个公式会通过：</p><pre><code>  1.  标签名、class、id  2.  是否内联样式  3.  !important</code></pre><p>然后得出一个权重值，取最高的那个。</p><p><strong>渲染阻塞</strong><br>当遇到一个 script 标签时，DOM 构建会被暂停，直至脚本完成执行，然后继续构建 DOM 树。<br>但如果 JS 依赖 CSS 样式，而它还没有被下载和构建时，浏览器就会延迟脚本执行，直至 CSS Rules 被构建。</p><p>所有我们知道：</p><pre><code>  - CSS 会阻塞 JS 执行  - JS 会阻塞后面的 DOM 解析</code></pre><p>为了避免这种情况，应该以下原则：</p><pre><code>- CSS 资源排在 JavaScript 资源前面- JS 放在 HTML 最底部，也就是 &lt;/body&gt;前</code></pre><p>另外，如果要改变阻塞模式，可以使用 defer 与 async，详见：<a href="https://github.com/xiaoyu2er/blog/issues/8">这篇文章</a></p><h4 id="4-布局与绘制"><a href="#4-布局与绘制" class="headerlink" title="4. 布局与绘制"></a>4. 布局与绘制</h4><p>确定渲染树种所有节点的几何属性，比如：位置、大小等等，最后输入一个盒子模型，它能精准地捕获到每个元素在屏幕内的准确位置与大小。</p><p>然后遍历渲染树，调用渲染器的 paint() 方法在屏幕上显示其内容。</p><h4 id="5-合并渲染层"><a href="#5-合并渲染层" class="headerlink" title="5. 合并渲染层"></a>5. 合并渲染层</h4><p>把以上绘制的所有图片合并，最终输出一张图片。</p><h4 id="6-回流与重绘"><a href="#6-回流与重绘" class="headerlink" title="6. 回流与重绘"></a>6. 回流与重绘</h4><p><strong>回流(reflow)</strong><br>当浏览器发现某个部分发现变化影响了布局时，需要倒回去重新渲染，会从 html 标签开始递归往下，重新计算位置和大小。<br>reflow 基本是无法避免的，因为当你滑动一下鼠标、resize 窗口，页面就会产生变化。</p><p><strong>重绘(repaint)</strong><br>改变了某个元素的背景色、文字颜色等等不会影响周围元素的位置变化时，就会发生重绘。<br>每次重绘后，浏览器还需要合并渲染层并输出到屏幕上。<br>回流的成本要比重绘高很多，所以我们应该尽量避免产生回流。<br>比如：<br>    - <code>display:none</code> 会触发回流，而 <code>visibility:hidden</code> 只会触发重绘。</p><h4 id="7-JavaScript-编译执行"><a href="#7-JavaScript-编译执行" class="headerlink" title="7. JavaScript 编译执行"></a>7. JavaScript 编译执行</h4><p><strong>大致流程</strong><br>可以分为三个阶段：<br><img src="https://cdn.jsdelivr.net/gh/Nafoaix/pic-repo@master/imgs/JSbianyizhixing.png" alt="JavaScript 编译执行流程"></p><h5 id="1-词法分析"><a href="#1-词法分析" class="headerlink" title="1. 词法分析"></a>1. 词法分析</h5><p>JS 脚本加载完毕后，会首先进入语法分析阶段，它首先会分析代码块的语法是否正确，不正确则抛出“语法错误”，停止执行。</p><p>几个步骤：</p><ul><li>分词，例如将 var a = 2，，分成 var、a、=、2 这样的词法单元。</li><li>解析，将词法单元转换成抽象语法树（AST）。</li><li>代码生成，将抽象语法树转换成机器指令。</li></ul><h5 id="2-预编译"><a href="#2-预编译" class="headerlink" title="2. 预编译"></a>2. 预编译</h5><p>JS 有三种运行环境：</p><ul><li>全局环境</li><li>函数环境</li><li>eval</li></ul><p>每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。</p><p><strong>创建执行上下文</strong><br>创建执行上下文的过程中，主要做了以下三件事：</p><ul><li>创建变量对象<pre><code>- 参数、函数、变量</code></pre></li><li>建立作用域链  <pre><code>- 确认当前执行环境是否能访问变量</code></pre></li><li>确定 This 指向</li></ul><h5 id="3-执行"><a href="#3-执行" class="headerlink" title="3. 执行"></a>3. 执行</h5><p><strong>JS 线程</strong><br><img src="https://cdn.jsdelivr.net/gh/Nafoaix/pic-repo@master/imgs/JSxiancheng.png" alt="JS 线程"><br>虽然 JS 是单线程的，但实际上参与工作的线程一共有四个：</p><blockquote><p>其中三个只是协助，只有 JS 引擎线程是真正执行的</p></blockquote><ul><li>JS 引擎线程：也叫 JS 内核，负责解析执行 JS 脚本程序的主线程，例如 V8 引擎</li><li>事件触发线程：属于浏览器内核线程，主要用于控制事件，例如鼠标、键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待 JS 引擎线程执行</li><li>定时器触发线程：主要控制setInterval和setTimeout，用来计时，计时完毕后，则把定时器的处理函数推进事件队列中，等待 JS 引擎线程。</li><li>HTTP 异步请求线程：通过XMLHttpRequest连接后，通过浏览器新开的一个线程，监控readyState状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待JS引擎线程执行。</li></ul><p><strong>注：浏览器对同一域名的并发连接数是有限的，通常为 6 个。</strong></p><p><strong>宏任务</strong><br>分为：</p><ul><li>同步任务：按照顺序执行，只有前一个任务完成后，才能执行后一个任务</li><li>异步任务：不直接执行，只有满足触发条件时，相关的线程将该异步任务推进任务队列中，等待JS引擎主线程上的任务执行完毕时才开始执行，例如异步Ajax、DOM事件，setTimeout等。</li></ul><p><strong>微任务</strong><br>微任务是 ES6 和 Node 环境下的，主要 API 有：<code>Promise</code>，<code>process.nextTick</code>。</p><p>微任务的执行在宏任务的同步任务之后，在异步任务之前。</p><p><img src="https://cdn.jsdelivr.net/gh/Nafoaix/pic-repo@master/imgs/weirenwu.png" alt="微任务"></p><p>代码例子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>); <span class="comment">// 宏任务 同步</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>); <span class="comment">// 宏任务 异步</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>); <span class="comment">// 宏任务 同步</span></span><br><span class="line">resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>) <span class="comment">// 微任务</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>) <span class="comment">// 宏任务 同步</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上代码输出顺序为：1,3,5,4,2</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://github.com/skyline75489/what-happens-when-zh_CN">what-happens-when-zh_CN</a></li><li><a href="https://alistapart.com/article/tags-to-dom/">Tags to DOM</a></li><li><a href="https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/">彻底理解浏览器的缓存机制</a></li><li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#The_rendering_engine">浏览器的工作原理：新式网络浏览器幕后揭秘</a></li><li><a href="https://blog.fundebug.com/2019/01/03/understand-browser-rendering/">深入浅出浏览器渲染原理</a></li><li><a href="https://heyingye.github.io/2018/03/19/js%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/#%E9%A2%84%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5">js 引擎的执行过程（一）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫学习笔记（一）</title>
      <link href="/archives/60acca91.html"/>
      <url>/archives/60acca91.html</url>
      
        <content type="html"><![CDATA[<p>null</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盘点国外知名游戏厂商（一）CD Projekt</title>
      <link href="/archives/29f83498.html"/>
      <url>/archives/29f83498.html</url>
      
        <content type="html"><![CDATA[<h1 id="盘点国外知名游戏厂商（一）CD-Projekt"><a href="#盘点国外知名游戏厂商（一）CD-Projekt" class="headerlink" title="盘点国外知名游戏厂商（一）CD Projekt"></a>盘点国外知名游戏厂商（一）CD Projekt</h1><div class="note info flat"><p>本篇文章写于 2020 年 4 月，在赛博朋克 2077 漫长而又煎熬的等待之余我我决定以我<strong>个人视角</strong>盘点下那些带给我无数爱恨、惊喜与感动的游戏厂商们。文章资料同通过互联网搜集整理，如有错误还请指正，本文内容仅代表个人观点。</p></div><h2 id="CD-Projekt-RED"><a href="#CD-Projekt-RED" class="headerlink" title="CD Projekt RED"></a>CD Projekt RED</h2><p><img src="https://cdn.jsdelivr.net/gh/Nafoaix/pic-repo@master/well-known_game/CDPR.jpg" alt="CD Projekt RED"></p><blockquote><p><a href="https://www.bilibili.com/video/av16789674/"><code>av16789674</code></a>《巫师 3》以及 CD Projekt 成功发展史-全 6 集游戏纪录片</p></blockquote><p>&emsp;&emsp;第一个就提到“波兰蠢驴”的原因<del>肯定不是馋 9 月即将登陆的《赛博朋克 2077》 的身子</del>，也不是《巫师》三部曲那出色的游戏质量，而是他们心中那份对玩家足够的诚意与对游戏的热爱，让我将其视作当代游戏界的绿洲。</p><p>&emsp;&emsp;CD Projekt Red（后面简称 CDPR） 是波兰电子游戏研发商 CD Projekt 下的游戏开发部门，我们还是先从 CD Projekt 旗下的数字发行平台 GOG.com 今年推出的<code>[30 天内退款政策]</code>说起吧。这个政策毫无疑问是将目前市面上的数字发行平台的退换政策戳出了一个大窟窿，本来 STEAM 平台的<code>[14 天 2 小时]</code>已经足够宽松了，但 CD Projekt 这番举措瞬间在全世界的游戏厂商、平台和玩家群体间炸开了锅，其实我觉得这本来就是“波兰蠢驴”玩家至上理念的一贯体现，在这先不论这是不是一次精心设计的 PR 行为，这一举措确实给玩家们带来了大量的利好，你可以有更大的余地选择更精良自己更喜欢的游戏。也有不少人担心目前的玩家群体还没形成完全自觉的良好氛围来从中恶意牟利，担心这项举措会导致大量 3A 游戏不选择在 GOG 上发售，确实“波兰蠢驴”自己这也是在赌，但是他们已经赌了太多次了，他们也甘愿为了给玩家们一个更好的游戏环境去赌不是吗？</p><p>&emsp;&emsp;1994 年在受历史等因素影响下，社会环境、经济环境动荡贫瘠的波兰，想要用电脑或是想玩被视为“资本主义的精神毒品”的游戏只能通过地下的集市，而这种本就灰色的地带也滋生了大量盗版游戏。作为 CD Projekt 的联合创始人马尔钦（Marcin Iwinski）和米卡（Michal Kicinski）深知在当时盗版如此猖獗环境之下，想要从头开发游戏赚钱是不现实的事，于是两人做起了波兰国内鲜有的游戏代理发行商业务。在卖游戏赚到了第一桶金之后他们并不满足于此，于是他们两个人加上一台电脑一间公寓的 CD Projekt 便注册成立了。公司成立后的第一件事便是与当时波兰国内盗版横行的游戏环境对抗，作为热爱游戏的二人，他们深知玩家们的需求，他们在 1996 年开始做游戏的本地化，将游戏翻译成波兰语投放到市场。恰逢 1998 年龙与地下城旷世神作《博德之门》发售，马尔钦坚信这款游戏能在波兰市场上获得成功，于是第一时间与 bioware 签订协议，当时的盗版游戏很少有翻译或翻译质量尚可的，CD Projekt 决定用本地化打败盗版势力让玩家心甘情愿地掏钱买正版。但是《博德之门》在当时作为一款优秀的作品有海量的文本和丰富的语音，本地化成本非常之高。CD Projekt 之前几年的利润都用在了海量的文本翻译、邀请顶级的配音演员进行出演、前所未有的大规模推广上，更是在光盘的基础之上送了一份火漆封缄的羊皮纸地图、一本厚实的龙与地下城规则手册以及一张原声 CD，这几乎耗尽了公司所有的积蓄，CD Projekt 的命运全赌在这款游戏上了。然而“波兰蠢驴”的这份良心让他们赢得了对盗版的战争，仅发售当日就卖出了 18000 套游戏，这次的成功更是加深了他们对于玩家至上的理念，他们认为只要你做的足够好，玩家没理由不买你的正版产品。廉价的盗版可能并不足以成为失败的借口。</p><p><img src="https://cdn.jsdelivr.net/gh/Nafoaix/pic-repo@master/well-known_game/CDPR.png" alt="CD Projekt RED"><br>&emsp;&emsp;这时开始他们决定自己开发游戏来贯彻自己的理念，这就有了现在的 CDPR（CD Projekt Red）工作室，成立之初 CDPR 是一个仅有 15 人的工作室，虽然从之前合作过的 Bioware 那里借到了引擎，但是这么小的团队甚至没有游戏开发流程经验的 CDPR 明显是没办法开发出他们要的作品的，为了他们心中那份对游戏的热爱他们花了近五年时间，一路扩充到 100 人的工作室，发售时间不断跳票,几乎耗尽了资金的“波兰蠢驴”将自己的命运赌在了《巫师 1》上，用马尔钦的话说，“那是我们所拥有的全部资金，还要再多些。”幸运的是《巫师 1》虽然有着游戏节奏过慢等的缺点，但终究瑕不掩瑜，及其出色的叙事，加上独特的战斗系统和当时在波兰国民级小说《猎魔人》IP 加成下，《巫师 1》取得了超 200 万的销量并大获好评，“波兰蠢驴”又赌赢了。由此受到了极大鼓励的 CDPR 马上立项了《巫师 2》，虽然有了前作的成功但后面的《巫师 2》也是历经挫折，由于雅达利 <em>(前面《巫师 1》研发使公司快要弹尽粮绝时 CDPR 与雅达利谈成协议获得了几万美元的投资但是发行权交给了雅达利)</em> 想要求把《巫师》移植到主机平台上，由于专心开发《巫师 2》CDPR 没有太多精力，于是将移植工作交给一个法国的开发商，最后这个主机移植项目在耗费了 CDPR 大量的资金后被取消了。</p><blockquote><p>马尔钦曾在媒体采访时抱怨称对方总是还要更多的钱、开发者、时间，以至于他们在对方身上花了几百万美元，比自己公司的支出还要高。</p></blockquote><p>&emsp;&emsp;恰逢 2008 年金融危机,他们还要偿还雅达利之前的巨额投资，导致公司又又濒临破产躺在了现实的断头台前，马尔钦为了解决财政危机，公司解散了一批子公司 <code>（这里面一部分员工组建了另一个公司——11bit 也就是后面推出《这是我的战争》《冰气时代》的工作室)</code> 公司人数从 350 减少到不到 200 人，,削减开支，削减《巫师 2》项目的内容，并对一家 IT 公司进行反向收购，借壳在华沙证券交易所上市。这些注入的资金使得 CDPR 可以专心制作《巫师 2》和自研引擎的开发<code>（之前从 Bioware 借到的 Aurora 引擎难以满足当时 PC 得的要求了，CDPR 在重写了引擎近 80%的代码后不得已放弃转而自研引擎）</code>，经过三年半的研发时间后，2011 年《巫师 2：国王刺客》正式发售第一年在 PC 就卖了 110 万套，而且由于自研引擎使得游戏更为方便的移植到当时的两大主机平台<code>（PS3、XBOX360）</code>。《巫师 2》和当年的“老滚 5”平分秋色，收获国际声誉的 CDPR 已然成为了波兰的骄傲，使政府开始极大重视并鼓励游戏行业的发展。甚至 2011 年奥巴马赴波兰进行国事访问时波兰总理将《巫师 2》作为国礼相赠。“波兰蠢驴”们为了回馈玩家对《巫师 2》的支持，在游戏正式发售一年后公布了《巫师 2》的增强版，除了在原版基础上进行了画质增强外，还加入了当初砍掉的那些内容，并将这些内容全部免费送给玩家。</p><p><img src="https://cdn.jsdelivr.net/gh/Nafoaix/pic-repo@master/well-known_game/CDPR2.png" alt="CD Projekt RED"><br>&emsp;&emsp;后面发生的事相信大家都已经知道了，就是大家津津乐道的“波兰蠢驴”封神之作《巫师 3》了，三年半的开发时间，3.06 亿波兰兹罗提（8100 万美元）的开发成本，交出了一份他们满意的答卷，高达 92 的媒体平均分，以及 IGN <em>“《巫师 3：狂猎》提升到了一个其他许多 RPG 无法企及的高度”</em> 的评价，加上各种年度 RPG 奖项，足够说明《巫师 3》有多好了。就更不用说“波兰蠢驴”之后还追加了 16 个免费 DLC 和把两个新游戏《石之心》与《血与酒》当 DLC 卖有多良心了。<code>（《血与酒》更是获得了 TGA2016 最佳 RPG 游戏的奖项）</code>《巫师 3》让 CDPR 彻底的成为了世界级公司，能取得今天的成就可谓实至名归。<br>&emsp;&emsp;他们出于对游戏的热爱而投身游戏领域，尽管知道盗版猖獗但仍未向其妥协，习惯用用实实在在的品质和后续的服务让玩家心甘情愿的掏钱，这就是我们的“波兰蠢驴”。回到开头，这就不难理解为什么《赛博朋克 2077》开放预购一小时后就一举夺得 STEAM 销量榜的冠军，受无数游戏玩家期待。没有他们心中那份对玩家足够的诚意与对游戏的热爱，怎么会有 CDPR 数次把公司前途押上的豪赌？怎么会有诺维格瑞的万家灯火？怎么会有凯尔莫罕天空中略过的飞鸟？我们 2077 年的不夜城见！也希望 CDPR 能继续做我们心中的绿洲。</p><p><img src="https://cdn.jsdelivr.net/gh/Nafoaix/pic-repo@master/well-known_game/cyberpunk-2077.png" alt="Cyberpunk2077"><br><em>“波兰蠢驴”你们可千万别破产了呀！</em></p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记(一)-从本地库开始</title>
      <link href="/archives/3cb7cd1a.html"/>
      <url>/archives/3cb7cd1a.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-学习笔记-一"><a href="#Git-学习笔记-一" class="headerlink" title="Git 学习笔记(一)"></a>Git 学习笔记(一)</h1><div class="note info flat"><p>作为一个刚接触 Git 不久的小白，该笔记是这两天我在网上看视频和教程自己总结记录下来的，主要为了方便未来自己查阅和帮助像我一样的小白学习 Git。文章中斜体部分为我自己方便记忆的理解，如有错误还请指正，见谅！</p></div><h2 id="Git-的一点介绍"><a href="#Git-的一点介绍" class="headerlink" title="Git 的一点介绍"></a>Git 的一点介绍</h2><h3 id="Git-下载地址："><a href="#Git-下载地址：" class="headerlink" title="Git 下载地址："></a>Git 下载地址：</h3><p><code>https://git-scm.com/</code></p><h3 id="Git-是什么"><a href="#Git-是什么" class="headerlink" title="Git 是什么"></a>Git 是什么</h3><p>&emsp;百度百科的介绍是：</p><blockquote><p>Git 是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。</p></blockquote><p><em>可以理解为一个小秘书来帮你打理你的项目，让你专注于项目上，而不是被错综复杂的项目版本和文件弄晕。</em></p><h3 id="Git-记录的是什么"><a href="#Git-记录的是什么" class="headerlink" title="Git 记录的是什么"></a>Git 记录的是什么</h3><p>&emsp;集中式版本控制系统 SVN 记录的是每一次版本变动的内容，Git 则是将项目的每个版本独立保存。Git 通过维护 <strong>工作区域</strong> <strong>暂存区域</strong> <strong>Git 仓库</strong> 来实现版本控制。<em>你可以理解为三座在本地的仓库。</em></p><h3 id="Git-管理的文件的三种状态"><a href="#Git-管理的文件的三种状态" class="headerlink" title="Git 管理的文件的三种状态"></a>Git 管理的文件的三种状态</h3><ul><li>已修改（modified）</li><li>已暂存（staged）</li><li>已提交（committed）</li></ul><h2 id="Git-的使用流程"><a href="#Git-的使用流程" class="headerlink" title="Git 的使用流程"></a>Git 的使用流程</h2><h3 id="Git-初始化"><a href="#Git-初始化" class="headerlink" title="Git 初始化"></a>Git 初始化</h3><p>&emsp;和游戏或 APP 一样，下载完之后要在命令行或在 GitBash 中输入以下命令来注册个账号<br>&emsp; <code>git config --global user.name &quot;你随便起的ID&quot;</code><br>&emsp; <code>git config --global user.email &quot;你的邮箱&quot;</code><br>&emsp;使用时首先要在工作的文件夹初始化 Git，你可以在命令行中进入工作文件夹目录也可以以直接在文件夹右键选择 Git Bash Here 然后输入：<br>&emsp;<code>git init</code><br>&emsp;<em>这样就相当于你告诉了 git：“这个文件夹需要你帮我管理。”</em><br>&emsp;这里就成了这个项目的根目录，也就是<strong>工作区域</strong>。初始化完成后该目录下会多了一个<code>.git</code>的目录，这个目录就是 Git 用来跟踪管理版本库的，没事不要手动修改这个目录里的文件。（如果没看到也没关系，因为该目录默认是隐藏的。）</p><h3 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h3><ul><li><p>当你对项目进行一顿操作后可以使用<br><code>git add 文件名 ---就是将指定文件添加到暂存区</code><br><code>git add ./-A/--all/* ---可以提交工作区中所有的文件</code><br>将文件添加到<strong>暂存区</strong>，也就是上面提到三座仓库中的第二座，这个区域区如其名，只是临时保存你的改动。<br><em>可以理解为小秘书记在随身携带的临时笔记本上。</em></p></li><li><p>当你完成了某个改动、变更了某项设置、写完了一个章节就可以使用<br><code>git commit -m &quot;提交说明(你干了啥)&quot;</code><br>&emsp;将暂存区文件提交到 <strong>Git 仓库</strong>，也就是上面提到的本地的第三座仓库。就相当于你告诉秘书：<em>“这些你都帮我打印出来放到 <strong>Git 仓库</strong>存个档。”</em><br>&emsp;<em>提交说明就相当于一个档案上贴的小标签比如‘三年二班期末考试成绩’方便自己或别人查阅仓库中存档的档案</em></p><div class="note info no-icon flat"><p>修改最后一次提交:<br> 执行带 –amend 选项的 commit 提交命令 Git 就会更正最近的一次提交<br>git commit –amend<br>如果不希望修改:q!退出后包保留旧的说明</p></div></li></ul><h3 id="查看状态与提交历史"><a href="#查看状态与提交历史" class="headerlink" title="查看状态与提交历史"></a>查看状态与提交历史</h3><ul><li><code>git status</code>可以查看目前工作区和暂存区的状态。 <em>就相当于你把秘书叫过来核对下</em><br> 当你在工作区新增了某些文件后使用此命令秘书就会告诉你:<br><code>Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</code><br><em>“你放了个文件进来怎么都不和我说一声，快用 add 命令添加进仓库里。”</em>:</li></ul><p>&emsp;&emsp;当你在工作区删除或者更改了某些文件后使用此命令秘书就会告诉你:<br>&emsp;&emsp;<code>Changes not staged for commit:</code><br>&emsp;&emsp;<code>(use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</code><br>&emsp;&emsp;<code>(use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</code><br>&emsp;&emsp;_“你的工作区和我上次过来的时候不一样了，某某文件删掉了，某某文件变更了，你想确认更改或者删掉文件或者让我把这些文件按照 <strong>暂存区</strong> 恢复回来都可以。”_<br>&emsp;&emsp;你会注意到我上面说的，使用 <code>git restore file</code> 指令 git 小秘书是从<strong>暂存区</strong>来恢复文件的，如果需要从<strong>Git 仓库</strong>来恢复，小秘书需要去仓库查档案，而且你也需要告诉他是恢复成哪次存档的版本，也就是下面关于版本回退提到的<code>git reset</code>命令。</p><ul><li><code>git log</code> 可以查看 <strong>Git 仓库</strong> 的历史提交记录。记录中会显示你每次 commit 到 <strong>Git 仓库</strong> 的历史记录，包含每次提交的 id、提交人、日期、提交说明等信息。<div class="note info no-icon flat"><p>图形化显示快照<br>git log –decorate –oneline –graph –all<br>–graph 图形化显示<br>–all 显示所有快照</p></div></li></ul><h3 id="关于版本回退"><a href="#关于版本回退" class="headerlink" title="关于版本回退"></a>关于版本回退</h3><pre>                   -add->            -commit->  WorkingDirectory ------ Stage(Index) ------ Repository(HEAD)                 <-restore-          <-reset-</pre><ul><li><p>回滚指定快照<br><code>git reset 至少前5位的版本快照号</code></p></li><li><p>回滚个别文件<br><code>git reset 版本快照 文件名/路径</code></p></li><li><p><code>git reset HEAD~</code> 其中 <code>HEAD~</code>表示回滚到上个版本的快照,如果两个<code>~~</code>就表示回滚到上上个版本的快照,或写作 <code>git reset HEAD~2</code>往后同理， <em>你可以叫 Git 小秘书去<strong>Git 仓库</strong> 里查任意时候的档案</em></p></li></ul><p><em>一般情况下为了防止将你的工作区弄乱，你的小秘书一般都是将查到的档案记在她随身携带的笔记本（<strong>暂存区</strong>）上。</em><br>所以一般当你不设置<code>reset</code>指令的参数的时，Git 默认使用<code>--mixed</code>参数，如<code>git reset --mixed HEAD~</code><br><code>--mixed</code> 参数表示:</p><ol><li>移动 HEAD 的指向，将其指向上一个快照</li><li>将 HEAD 移动后指向的快照回滚到暂存区域</li></ol><p>与之相对的<code>reset</code>指令还有其他一些参数比如：</p><ul><li><code>git reset --soft HEAD~</code><br>–soft 参数表示 移动 HEAD 的指向将其指向上一个快照，并不会修改暂存区，也就相当于撤回上一次的提交。</li><li><code>git reset --hard HEAD~</code><br>–hard 参数表示:</li></ul><ol><li><p> 移动 HEAD 的指向，将其指向上一个快照</p></li><li><p> 将 HEAD 移动后指向的快照回滚到暂存区域</p></li><li><p> 将暂存区域的文件还原到工作目录 （会覆盖掉工作目录里最新的文件！！！）</p></li></ol><div class="note info no-icon flat"><p><code>reset</code> 指令不仅可以回滚还可以往前滚，如果上面使用了<code>reset</code>指令撤销了上次提交，这时<code>git log</code>是看不到前面版本的 ID 的，需要使用<code>git reflog</code>查看所有操作的日志。</p></div><h3 id="关于-diff-命令"><a href="#关于-diff-命令" class="headerlink" title="关于 diff 命令"></a>关于 diff 命令</h3><p>diff 顾名思义就是不同，使用<code>git diff</code>不加任何参数就是比较<strong>暂存区域</strong>和<strong>工作目录</strong>的差异。</p><ul><li><p>比较两个历史快照<br><code>git diff 快照ID1 快照ID2</code></p></li><li><p>比较当前工作目录和 GIt 仓库中的快照<br><code>git diff 快照ID</code></p></li><li><p>比较当前工作目录和 GIt 仓库中的快照<br><code>git diff 快照ID</code></p></li><li><p>比较最新的一份快照和当前工作目录<br><code>git diff HEAD</code></p></li><li><p>比较暂存区域和 Git 仓库快照<br><code>git diff --cached 快照 ID</code></p><div class="note info no-icon flat"><p>  显示的格式正是 Unix 通用的 diff 格式，查看常用如下键盘操作：</p><ul><li><p>移动命令<br>J 向下移一行 K 向上移一行<br>F 向下移一页 B 向上移一页<br>D 向下移半页 U 向上移半页</p></li><li><p>跳转命令<br>g 跳到第一行<br>G 跳到最后一行<br>num g 跳到第 num 行<br>num G 跳到倒数第 num 行</p></li><li><p>搜索命令<br>/ +关键词 从上往下搜索关键词<br>? +关键词 从下往上搜索关键词<br>n 跳转到下一个搜索结果</p></li><li><p>h 帮助文档</p></li><li><p>q 退出</p></li></ul></div></li></ul><h3 id="其他文件操作"><a href="#其他文件操作" class="headerlink" title="其他文件操作"></a>其他文件操作</h3><ul><li>删除文件<br><code>git rm 文件名</code>此命令会删除工作目录和暂存区域的文件，也就是取消跟踪，在下次提交时不纳入版本管理，不会删除在仓库快照里的文件。<blockquote><p>如果你工作区和暂存区有两个不同的文件 git 会不知道你删除哪个<br>使用-f 指令强制删除工作区和暂存区文件<br>使用–cached 文件名 只删除暂存区的文件</p></blockquote></li><li>重命名文件<br><code>git mv 旧文件名 新文件名</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
